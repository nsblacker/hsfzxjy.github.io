<a id="rocket" href="#top" class="show"></a><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description"/><title>编程 | thoughts of hsfzxjy</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">thoughts of hsfzxjy</h1><a id="logo" href="/">thoughts of hsfzxjy</a><p class="description">不忌讳空山无人，不害怕遥望星辰</p><iframe src="https://ghbtns.com/github-btn.html?user=hsfzxjy&amp;type=follow&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px" class="github-btn"></iframe></div><div id="nav-menu"><a href="/"><i class="icon-home"> 首页</i></a><a href="/categories/编程/" class="current"><i class="icon-code"> 码海拾贝</i></a><a href="/categories/杂感/"><i class="icon-life"> 五味杂感</i></a><a href="/about/"><i class="icon-about"> 我</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/uva10285-longest-run-on-a-snowboard/">UVa10285 Longest Run on a Snowboard</a></h2><div class="post-meta">2014-09-29</div><span data-thread-key="/uva10285-longest-run-on-a-snowboard/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=14&amp;problem=1226&amp;mosmsg=Submission%20received%20with%20ID%2014282250" target="_blank" rel="external">Link</a> 耗时：0.028s</p>
</blockquote>
<p>一道简单的动态规划，主要思路就是：</p>
<blockquote>
<p><strong>用f[i,j]表示到达(i,j)的最长路径的长度。</strong>找到每个最高点，从其开始向四周的低处搜索。如果该点已搜过并且f值大于当前长度则退出回溯。直到达到某个最低点为止。</p>
</blockquote>
<p>不多说了，直接上代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const&#10;    delta :array [1..4, 1..2] of integer = ((-1, 0), (1, 0), (0, 1), (0, -1)); //&#22235;&#20010;&#26041;&#21521;&#21521;&#37327;&#10;var&#10;    _: Integer;&#10;    name: string;&#10;    n, m, i, j, x: Integer;&#10;    ans: longint;&#10;    map: array [0..101, 0..101] of integer;&#10;    f: array [1..100, 1..100] of longint;&#10;&#10;function max(x, y: longint): longint; inline;&#10;begin&#10;    if x&#38;gt;y then exit(x) else exit(y);&#10;end;&#10;&#10;function can(x, y: integer): Boolean; inline; //&#21028;&#26029;&#26159;&#21542;&#26159;&#26368;&#39640;&#28857;&#10;var&#10;    i: Integer;&#10;    tx, ty: integer;&#10;begin&#10;    can := true;&#10;    for i := 1 to 4 do&#10;    begin&#10;        tx := x + delta[i, 1];&#10;        ty := y + delta[i, 2];&#10;        can := can and (map[x, y] &#38;gt;= map[tx, ty]);&#10;        if not can then break;&#10;    end;&#10;end;&#10;&#10;procedure dp(x, y: integer; len: longint); //&#22238;&#28335;&#36827;&#34892;&#21160;&#24577;&#35268;&#21010;&#10;var&#10;    i: Integer;&#10;    tx, ty: integer;&#10;begin&#10;    inc(len);&#10;    if f[x, y] &#38;gt; len then exit;&#10;    f[x, y] := len;&#10;    ans := max(ans, len);&#10;    for i := 1 to 4 do&#10;    begin&#10;        tx := delta[i, 1] + x;&#10;        ty := delta[i, 2] + y;&#10;        if (tx = 0) or (tx &#38;gt; n) or (ty = 0) or (ty &#38;gt; m) then continue;&#10;        if map[x, y] &#38;lt;= map[tx, ty] then continue;&#10;        dp(tx, ty, len);&#10;    end;&#10;end;&#10;&#10;procedure ReadAndProcessName; //&#22788;&#29702;&#37027;&#34892;&#35813;&#27515;&#30340;&#21517;&#23383;&#65281;&#65281;&#10;var&#10;    s: string;&#10;    i: integer;&#10;begin&#10;    readln(s);&#10;    i := 1;&#10;    name := &#39;&#39;;&#10;    n := 0;&#10;    m := 0;&#10;    while s[i] &#38;lt;&#38;gt; &#39; &#39; do&#10;    begin&#10;        name := name + s[i];&#10;        inc(i);&#10;    end;&#10;    inc(i);&#10;    while s[i] &#38;lt;&#38;gt; &#39; &#39; do&#10;    begin&#10;        n := n * 10 + ord(s[i]) - ord(&#39;0&#39;);&#10;        inc(i);&#10;    end;&#10;    inc(i);&#10;    while i &#38;lt;= length(s) do&#10;    begin&#10;        m := m * 10 + ord(s[i]) - ord(&#39;0&#39;);&#10;        inc(i);&#10;    end;&#10;end;&#10;&#10;begin&#10;    assign(input, &#39;main.in&#39;);reset(input);&#10;    assign(output, &#39;main.out&#39;);rewrite(output);&#10;    readln(_);&#10;    while _&#38;gt;0 do&#10;    begin&#10;        dec(_);&#10;        fillchar(map, sizeof(map), 0);&#10;        ReadAndProcessName;&#10;&#10;        for i := 1 to n do&#10;            for j := 1 to m do&#10;            begin&#10;                read(x);&#10;                map[i, j] := x+1;&#10;            end;&#10;        readln;&#10;&#10;        fillchar(f, sizeof(f), 0);&#10;        ans := 0;&#10;        for i := 1 to n do&#10;            for j := 1 to m do&#10;                if can(i, j) then&#10;                    dp(i, j, 0);&#10;        writeln(name, &#39;: &#39;, ans);&#10;    end;&#10;    close(input);close(output);&#10;end.</span><br></pre></td></tr></table></figure>
</div></div><div class="post"><h2 class="post-title"><a href="/uva12186-another-crisis-dynamic-arrays-in-pascal/">UVa12186 Another Crisis &amp;&amp; [Dynamic Arrays in Pascal]</a></h2><div class="post-meta">2014-09-27</div><span data-thread-key="/uva12186-another-crisis-dynamic-arrays-in-pascal/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=243&amp;page=show_problem&amp;problem=3338" target="_blank" rel="external">Link</a> 耗时：0.586s </p>
</blockquote>
<p>昨晚做的太急了，没时间写总结，正好下午有空，补上。</p>
<p>这是一道典型的树形动态规划，不是很难，但十分坑语言。思路大致如下：</p>
<p>对于第i个节点，用d(i)表示其上诉所需的最小工人数。若i为叶节点，则d(i)=1；否则，遍历求出i的子节点所对应的d值，并由小到大排序，取出最小的几个相加，即为d(i)。</p>
<p>很容易想到用递归来实现。但对于“子节点的d值的排序”实现起来却十分困难：因为事先不知道有多少个数。当然啦，如果是C++组，用vector可以轻松搞定，可至于P党，实现起来却难上加难。思来想去，决定试试Pascal的动态数组。磕磕碰碰调了近1个小时，终于AC了。</p>
<p>Code:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Accepted&#10;var&#10;    tree: array [0..100000] of array of int64;&#10;    T: Integer;&#10;    f: array [0..100000] of int64;&#10;    i,l,n,x:longint;&#10;&#10;function min(x,y: int64): int64;&#10;begin&#10;    if x&#38;lt;y then exit(x) else exit(y);&#10;end;&#10;&#10;procedure sort(var arr: array of int64;l,r:longint); overload;&#10;var&#10;  i,j:longint;&#10;  m,t: int64;&#10;begin&#10;  i := l;&#10;  j := r;&#10;  m := arr[(l+r) &#38;gt;&#38;gt; 1];&#10;  repeat&#10;    while arr[i]&#38;lt;m do inc(i);&#10;    while arr[j]&#38;gt;m do dec(j);&#10;    if i&#38;lt;=j then&#10;    begin&#10;      t := arr[i];&#10;      arr[i] := arr[j];&#10;      arr[j] := t;&#10;      inc(i);&#10;      dec(j);&#10;    end;&#10;  until i&#38;gt;j;&#10;  if i&#38;lt;r then sort(arr, i, r);&#10;  if l&#38;lt;j then sort(arr, l, j);&#10;end;&#10;&#10;procedure sort(var arr: array of int64); overload;&#10;begin&#10;  sort(arr, low(arr), high(arr));&#10;end;&#10;function dp(x: longint): int64;&#10;var&#10;  arr: array of int64;&#10;  l,i, num: longint;&#10;begin&#10;    if f[x] &#38;lt;&#38;gt; 0 then&#10;    begin&#10;        dp := f[x];&#10;        exit;&#10;    end;&#10;    if length(tree[x]) = 0 then&#10;    begin&#10;      dp := 1;&#10;      f[x] := 1;&#10;      exit;&#10;    end;&#10;    l := length(tree[x]);&#10;    SetLength(arr, l);&#10;    for i := Low(tree[x]) to High(Tree[x]) do&#10;      arr[i] := dp(tree[x][i]);&#10;    Sort(arr);&#10;    num := (l*T-1) div 100+1;&#10;    for i := Low(arr) to num-1 do&#10;      f[x] := f[x] + arr[i];&#10;    dp := f[x];&#10;end;&#10;&#10;begin&#10;    assign(input, &#39;main.in&#39;);reset(input);&#10;    assign(output,&#39;main.out&#39;);rewrite(output);&#10;    readln(n, T);&#10;    while n&#38;gt;0 do&#10;    begin&#10;        fillchar(f, sizeof(f), 0);&#10;        fillchar(tree, sizeof(tree), 0);&#10;        for i := 1 to n do&#10;        begin&#10;            read(x);&#10;            SetLength(tree[x], length(tree[x])+1);&#10;            tree[x][high(tree[x])] := i;&#10;        end;&#10;        readln;&#10;        dp(0);&#10;        writeln(f[0]);&#10;        readln(n, T);&#10;    end;&#10;    close(input); close(output);&#10;end.</span><br></pre></td></tr></table></figure>
<h2 id="Dynamic_Arrays">Dynamic Arrays</h2><p>这里，再总结一下动态数组的用法。</p>
<ol>
<li>定义：<code>a: array of [type];</code></li>
<li>设置长度： <code>SetLength(a, 10);</code></li>
<li>长度加一： <code>SetLength(a, Length(a)+1);</code></li>
<li>取得最大、最小下标： <code>High(a)</code>, <code>Low(a)</code></li>
</ol>
<p>事实上，从<a href="http://freepascal.org/docs-html/ref/refsu18.html#x42-480003.3.1" target="_blank" rel="external">1.1</a>版本开始FPC就支持Dynamic Arrays了。所以在NOIP竞赛中我们大可放心使用。</p>
</div></div><div class="post"><h2 class="post-title"><a href="/uva-11584-partitioning-by-palindromes/">UVa11584 Partitioning by Palindromes</a></h2><div class="post-meta">2014-09-24</div><span data-thread-key="/uva-11584-partitioning-by-palindromes/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>这是一道区间型DP，转移方程很简单，但在实现的过程中却遇见了很多坑，在此记录一下。 链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=27&amp;problem=2631&amp;mosmsg=Submission%20received%20with%20ID%2014256745&quot;" target="_blank" rel="external">Link</a> 耗时：0.368s</p>
</blockquote>
<p>容易想到，前i个数的划分情况可以由1,2,3…,i-1的划分情况来决定。因此很容易得到状态转移方程：</p>
<blockquote>
<p>d[i] = min(d[i], d[j]+1) //j = 0, 1, 2…n-1 并且 s[j+1, i]为回文串，初始条件：d[i] = i。</p>
</blockquote>
<p><code>d[i]</code>表示前i项的最小划分。这样一来状态转移的复杂度就为O($n^2$)。</p>
<p>但状态转移的判断呢？“回文串”是一个复杂的条件，判断一个串是否为回文串需要将该串至少遍历一遍。这样一来时间复杂度就上升为O($n^3$)了。而事实上在这种算法中有许多无谓的计算，因此我们可以先对字符串进行预处理：用huiwen[i,j]表示s[i,j]是否为回文串（奇怪的名字。。。）。如此一来，时间复杂度就降为O($n^2$)了。</p>
<p>Code：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var&#10;    s: AnsiString;&#10;    n, _, i, j, l: integer;&#10;    huiwen: array [1..1000, 1..1000] of boolean; //s[i,j]&#26159;&#21542;&#20026;&#22238;&#25991;&#20018;&#10;    dp: array [0..1000] of integer; //&#19968;&#23450;&#20174;0&#24320;&#22987;&#65292;&#21542;&#21017;&#24403;&#25972;&#20018;&#20026;&#22238;&#25991;&#20018;&#26102;&#23601;&#32771;&#34385;&#19981;&#21040;&#20102;&#12290;&#10;&#10;function min(x,y: integer): integer;&#10;begin&#10;    if x&#38;lt;y then exit(x) else exit(y);&#10;end;&#10;&#10;procedure process(i,j: integer); //&#23545;&#22238;&#25991;&#20018;&#36827;&#34892;&#39044;&#22788;&#29702;&#10;var&#10;    mid: Integer;&#10;    x,y: integer;&#10;begin&#10;    if j = i then&#10;    begin&#10;        huiwen[i,j] := true;&#10;        exit;&#10;    end;&#10;    mid := i + (j-i+1) shr 1;&#10;    x := i;&#10;    y := j;&#10;    while (x &#38;lt;= mid) and (s[x] = s[y]) do&#10;    begin&#10;        inc(x);&#10;        dec(y);&#10;    end;&#10;    huiwen[i, j] := x &#38;gt; mid;&#10;end;&#10;&#10;begin&#10;    //assign(input, &#39;main.in&#39;); reset(input);&#10;    //assign(output, &#39;main.out&#39;); rewrite(output);&#10;    readln(n);&#10;    for _ := 1 to n do&#10;    begin&#10;        readln(s);&#10;        l := length(s);&#10;        //Pre-process&#10;        fillchar(huiwen, sizeof(huiwen), 0);&#10;        for i := 1 to l do&#10;            for j := i to l do //&#19968;&#23450;&#26159;&#20174;i&#24320;&#22987;&#65292;&#36825;&#20010;&#38169;&#21345;&#20102;&#25105;&#24456;&#20037;&#12290;&#10;                process(i, j);&#10;        //DP&#10;        for i := 1 to l do&#10;        begin&#10;            dp[i] := i;&#10;            for j := 0 to i-1 do&#10;                if huiwen[j+1, i] then&#10;                    dp[i] := min(dp[i], dp[j]+1);&#10;        end;&#10;        write(dp[l]);&#10;        &#123;if _ &#38;lt;&#38;gt;n then &#125;writeln; //&#21520;&#27133;&#19968;&#19979;&#65306;&#19968;&#24320;&#22987;&#25105;&#36824;&#35880;&#24910;&#22320;&#21152;&#19978;&#36825;&#21477;&#20197;&#36991;&#20813;&#34892;&#26411;&#22238;&#36710;&#65292;&#27809;&#24819;&#21040;UVa&#23621;&#28982;&#25253;&#38169;&#20102;&#12290;&#12290;&#30475;&#26469;UVa&#30340;&#27604;&#36739;&#31639;&#27861;&#36824;&#26377;&#24453;&#25913;&#36827;&#21834;&#12290;&#10;    end;&#10;&#10;    //close(input);close(output);&#10;end.</span><br></pre></td></tr></table></figure></div></div><div class="post"><h2 class="post-title"><a href="/uva437-the-tower-of-babylon/">UVa437 The Tower of Babylon</a></h2><div class="post-meta">2014-09-23</div><span data-thread-key="/uva437-the-tower-of-babylon/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=6&amp;page=show_problem&amp;problem=378" target="_blank" rel="external">The Tower of Babylon</a> 耗时：0.015s</p>
</blockquote>
<p>这是刘汝佳的紫书中”DAG中的动态规划”中的习题，我拿它用来熟悉DAG中的动态规划。</p>
<p>我们不妨进行逆向考虑：现堆上面的方块，然后考虑在下面进行叠加。这样子一来，影响决策的就只是最下面方块的尺寸了。</p>
<p>对于这种出现了”大套小”这样的二元关系的题，我们可以将其视为一个有向无环图：<strong>其中每个节点为一个状态，状态的转移是有固定的方向的</strong>（在此题中，状态转移为从小的方块到大的方块）。</p>
<p>但是这道题又不同于平常的DAG动态规划：若将边长视为状态的话，则要开一个巨大的数组，这是不可以接受的。因此，我们要换一种思维方式：只记录方块的序号和摆放的方式（如现将边长从小到大进行排序，然后用一个标志k表示当前是以第k小的边长作为高）。<br> 至此，思路已经清晰了。用dp(i, k)表示<strong>“第i个方块以第k条边为高进行摆放”</strong>，以下给出状态转移方程：</p>
<blockquote>
<p>dp(i, k) = max{dp(i, k), dp(j, k2)} j，k2遍历所有顶面矩形比dp(i, k)小的状态。</p>
</blockquote>
<p>代码实现首次尝试了Pascal中的object类型，使其更加工整，但不可避免地损耗了一些性能。</p>
<p>Code：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type&#10;    Cube = object&#10;        a: array [1..3] of longint;&#10;        procedure init(x,y,z: longint);&#10;        function height(k: integer): longint;&#10;        function low(k: integer): longint;&#10;        function high(k: integer): longint;&#10;    end;&#10;&#10;function max(x,y: longint): longint;&#10;begin&#10;    if x&#38;gt;y then max := x else max := y;&#10;end;&#10;&#10;procedure swap(var x,y: longint);&#10;var&#10;    t: longint;&#10;begin&#10;    t := x;&#10;    x := y;&#10;    y := t;&#10;end;&#10;&#10;function Cube.height(k: integer): longint;&#10;begin&#10;    height := self.a[k];&#10;end;&#10;&#10;function Cube.high(k: integer): longint;&#10;begin&#10;    case k of&#10;        1: high := a[3];&#10;        2: high := a[3];&#10;        3: high := a[2];&#10;    end;&#10;end;&#10;&#10;function Cube.low(k: integer): longint;&#10;begin&#10;    case k of&#10;        1: low := a[2];&#10;        2,3: low := a[1];&#10;    end;&#10;end;&#10;&#10;procedure Cube.init(x, y, z: longint);&#10;begin&#10;   if x&#38;gt;y then swap(x,y);&#10;   if y&#38;gt;z then swap(y,z);&#10;   if x&#38;gt;y then swap(x,y);&#10;   a[1] := x;&#10;   a[2] := y;&#10;   a[3] := z;&#10;end;&#10;&#10;var&#10;    f: array [1..30, 1..3] of longint;&#10;    i,j,m,n,x,y,z: longint;&#10;    cnt: longint;&#10;    cubes: array [1..30] of Cube;&#10;&#10;function dp(id, k: integer): longint;&#10;var&#10;    l, h, hi: longint;&#10;    i, j: integer;&#10;begin&#10;    if f[id, k] &#38;gt; 0 then&#10;        exit(f[id, k]);&#10;    l := cubes[id].low(k);&#10;    hi := cubes[id].height(k);&#10;    h := cubes[id].high(k);&#10;&#10;    f[id, k] := hi;&#10;&#10;    for i := 1 to n do&#10;    begin&#10;        //if i = id then continue;  //&#27492;&#22788;&#22312;&#19968;&#24320;&#22987;&#26102;&#24536;&#35760;&#32771;&#34385;&#20102;&#31435;&#26041;&#20307;&#26377;&#26080;&#31351;&#22810;&#20010;&#36825;&#19968;&#26465;&#20214;&#12290;&#10;        for j := 1 to 3 do&#10;        begin&#10;            if not ((cubes[i].low(j) &#38;lt; l) and (cubes[i].high(j) &#38;lt; h)) then&#10;                continue;&#10;            f[id, k] := max(f[id, k], dp(i, j)+hi);&#10;        end;&#10;    end;&#10;&#10;    dp := f[id, k];&#10;end;&#10;&#10;begin&#10;    assign(input, &#39;main.in&#39;);reset(input);&#10;    assign(output, &#39;main.out&#39;);rewrite(output);&#10;    read(n);&#10;    cnt := 0;&#10;    while n &#38;gt; 0 do&#10;    begin&#10;        inc(cnt);&#10;        for i := 1 to n do&#10;        begin&#10;            read(x,y,z);&#10;            cubes[i].init(x,y,z);&#10;        end;&#10;        fillchar(f, sizeof(f), 0);&#10;&#10;        m := 0;&#10;        for i := 1 to n do&#10;            for j := 1 to 3 do&#10;                m := max(m, dp(i, j));&#10;&#10;        writeln(&#39;Case &#39;, cnt, &#39;: maximum height = &#39;, m);&#10;&#10;        read(n);&#10;    end;&#10;    close(input);close(output);&#10;end.</span><br></pre></td></tr></table></figure></div></div><div class="post"><h2 class="post-title"><a href="/noip2011-expression/">NOIP2011 表达式计算</a></h2><div class="post-meta">2014-09-22</div><span data-thread-key="/noip2011-expression/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>记得11年的时候，觉得这道题爆难，根本无从下手。三年后再次回顾，终于AC了，就当是对表达式求值和动态规划的复习吧。</p>
</blockquote>
<h1 id="题目：Link">题目：<a href="http://codevs.cn/problem/1133/" target="_blank" rel="external">Link</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accepted.</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Mod <span class="number">10007</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v0;  <span class="comment">//当前值为0的个数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v1;  <span class="comment">//当前值为1的个数</span></span><br><span class="line">    <span class="keyword">char</span> ch;  <span class="comment">//当前字符</span></span><br><span class="line">&#125; vertex;</span><br><span class="line"></span><br><span class="line">vertex f[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sum</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w0 = f[p-<span class="number">1</span>].v0 * f[p].v0;</span><br><span class="line">    <span class="keyword">int</span> w1 = f[p-<span class="number">1</span>].v0*f[p].v1+f[p-<span class="number">1</span>].v1*f[p].v0+f[p-<span class="number">1</span>].v1*f[p].v1;</span><br><span class="line">    f[p-<span class="number">1</span>].v0 = w0 % Mod;</span><br><span class="line">    f[p-<span class="number">1</span>].v1 = w1 % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge_product</span><span class="params">(<span class="keyword">int</span> p)</span>  <span class="comment">//处理当前的值和前一个值取'*'的操作</span></span><br><span class="line"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> w0=f[p-<span class="number">1</span>].v0*f[p].v0+f[p-<span class="number">1</span>].v0*f[p].v1+f[p-<span class="number">1</span>].v1*f[p].v0;</span><br><span class="line">       <span class="keyword">int</span> w1=f[p-<span class="number">1</span>].v1*f[p].v1;</span><br><span class="line">       f[p-<span class="number">1</span>].v0=w0%Mod;</span><br><span class="line">       f[p-<span class="number">1</span>].v1=w1%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    f[<span class="number">0</span>].v0=f[<span class="number">0</span>].v1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">          now++;   <span class="comment">//新建一个空位读入新符号</span></span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;f[now].ch;</span><br><span class="line">          f[now].v0=f[now].v1=<span class="number">1</span>;  <span class="comment">//初始化当前符号的前面的值(虽然')'除外,但也不影响)</span></span><br><span class="line">          <span class="keyword">if</span> (f[now].ch==<span class="string">'+'</span>)</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">if</span> (f[now-<span class="number">1</span>].ch==<span class="string">'*'</span>) <span class="comment">//处理'*'</span></span><br><span class="line">             &#123;</span><br><span class="line">                now--;</span><br><span class="line">                merge_product(now);</span><br><span class="line">                f[now]=f[now+<span class="number">1</span>];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (f[now-<span class="number">1</span>].ch==<span class="string">'+'</span>) <span class="comment">//处理'+'</span></span><br><span class="line">             &#123;</span><br><span class="line">                now--;</span><br><span class="line">                merge_sum(now);</span><br><span class="line">                f[now]=f[now+<span class="number">1</span>];</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (f[now].ch==<span class="string">'*'</span>)</span><br><span class="line">           <span class="keyword">if</span> (f[now-<span class="number">1</span>].ch==<span class="string">'*'</span>) <span class="comment">//处理'*'</span></span><br><span class="line">           &#123;</span><br><span class="line">              now--;</span><br><span class="line">              merge_product(now);</span><br><span class="line">              f[now]=f[now+<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">          <span class="keyword">if</span> (f[now].ch==<span class="string">')'</span>) <span class="comment">//处理')'(比较麻烦)</span></span><br><span class="line">          &#123;</span><br><span class="line">             now--;</span><br><span class="line">             <span class="keyword">if</span> (f[now].ch==<span class="string">'*'</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                merge_product(now);</span><br><span class="line">                now--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (f[now].ch==<span class="string">'+'</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                merge_sum(now);</span><br><span class="line">                now--;</span><br><span class="line">             &#125;</span><br><span class="line">             now--;</span><br><span class="line">             f[now].v0=f[now+<span class="number">1</span>].v0;</span><br><span class="line">             f[now].v1=f[now+<span class="number">1</span>].v1;</span><br><span class="line">             <span class="keyword">if</span> (f[now].ch==<span class="string">'*'</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                merge_product(now);</span><br><span class="line">                now--;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[now].ch==<span class="string">'*'</span>)  <span class="comment">//处理完了以后,可能还有残留的'*'和'+'</span></span><br><span class="line">    &#123;</span><br><span class="line">       merge_product(now);</span><br><span class="line">       now--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[now].ch==<span class="string">'+'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       merge_sum(now);</span><br><span class="line">       now--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">0</span>].v0;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div><div class="post"><h2 class="post-title"><a href="/strange-extended-and-double-problem/">Extended和Double的奇怪问题</a></h2><div class="post-meta">2014-08-20</div><span data-thread-key="/strange-extended-and-double-problem/" class="ds-thread-count"></span><div class="post-content"><p>最近在做一个项目，其中有一段判断一个Extended浮点数是否为整数的代码。我用如下方式实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function IsInt(F: Extended): Boolean;&#10;begin&#10;  result := Trunc(F)-F = 0; //&#25972;&#25968;&#37096;&#20998;&#31561;&#20110;&#33258;&#36523;&#10;end;</span><br></pre></td></tr></table></figure>
<p>测试了许多样例都过了，唯独这个没过：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IsInt(4.000000002*1000000000); //False</span><br></pre></td></tr></table></figure>
<p>调试时发现： Trunc(F)居然等于4000000001！开始以为是精度的问题，找了许多资料也没能解决。后来将Extended换成了Double，就通过了。百思不得其解中。</p>
</div></div><div class="post"><h2 class="post-title"><a href="/impression-for-delphi-OOP/">学习Delphi面向对象编程的一点心得</a></h2><div class="post-meta">2012-09-29</div><span data-thread-key="/impression-for-delphi-OOP/" class="ds-thread-count"></span><div class="post-content"><p>以前我是完全不理解类的概念的，我只是把它当成一个Record来看，只不过它里面可以包含函数和过程罢了。但深入VCL学习后我才发现，原来面向对象的世界是这么精彩。</p>
<p>大家都应该见过闹钟吧？随便给一个人一个闹钟，他都会用，不管是电子钟还是机械钟。但如果给一个人一堆零件，有谁能够将他们组装成一个闹钟呢？如果没有专业的知识，恐怕没有人会。为什么呢？为什么人人都会用但很少人懂得其内部结构呢？因为闹钟这一类事物提供一个标准的操作接口，如发条、钟表盘等。不管是液晶屏还是钟表盘，虽然他们形式不同，但他们都是用来显示时间的；同时，闹钟有隐藏了其内部实现的细节，用一层外壳将他们“封装”起来，使外界无法接触其内部，保持了内部的稳定性以及保证了机械运作的安全。这，便是类在生活中的一个真实缩影。</p>
<p>类有三个特性：封装，继承，多态。</p>
<ol>
<li><p>“封装”就是隐藏内部实现细节。就像一个人，有为人知的一面，像外表，性格，衣着等；也有不为人知的一面，如其的心理状态以及复杂的内心世界及想法。在面向对象中，为人知的一面称为“接口”，即public段和published段的成员；不为人知的一面称为“私有成员”，即private和protected段（其实protected段也不完全是）。人们可以通过接口获得一些数据或完成一些操作，但不会影响类自己的数据的安全性、合法性和稳定性（当然，要保证类封装的合法性和合理性，像一辆只剩下骨架的汽车，连发动机都露出来了，有人敢去开吗？能保证发动机运行的稳定吗？）。</p>
</li>
<li><p>“继承”就是“子承父业”。一个类可以继承另一个类的所有成员（不包括private段），并在其基础上增加属于自己的成员。这样做的好处是提高代码的可重用性。就像金属和铝的关系一样，铝是一种金属并且拥有金属的一切性质。</p>
</li>
<li><p>“多态”就是“多种状态”，即一个method，可以在本类中实现（static），也可以实现一部分，另一部分让子类去实现（dynamic或virtual），还可以不实现，让子类自己去发挥（abstract）。这极大地提升了类的灵活性，同时也真实地反应了现实生活：一个人不是万能的，他不能干所有的事，但或许他的后代可以，即“青出于蓝而胜于蓝”。</p>
</li>
</ol>
<p>类似乎是生活中的一个真实写照，世界上任何一个物体都满足这三个特性，无论是抽象的（如水果）还是具体的（如苹果）。这不仅仅是一种编程思想，还是对生活的一种总结，对生命的一种感悟，对世界的一种新认识。</p>
<p>程序基于数，而数皆万物也。</p>
</div></div><div class="post"><h2 class="post-title"><a href="/sharing-a-keyboard-hook-in-delphi/">一个键盘钩子的写法，很实用</a></h2><div class="post-meta">2012-09-29</div><span data-thread-key="/sharing-a-keyboard-hook-in-delphi/" class="ds-thread-count"></span><div class="post-content"><h2 id="0x00_前言">0x00 前言</h2><p>早就想写一个键盘监听器了，学校的电子阅览室设了Administrator屏障，想装软件什么的很麻烦，因此想截获管理员密码。。    </p>
<p>花了大概一个星期编写了一个，效果还不错，因此来分享一下。。</p>
<h2 id="0x01_基本概念">0x01 基本概念</h2><p> 首先解释一下什么是键盘钩子：</p>
<blockquote>
<p>钩子（Hook）是Windows消息处理机制中的一个监视点，应用程序可以在这里安装一个子程序（钩子函数）以监视指定窗口某种类型的消息，所监视的窗口可以是其他进程创建的。当消息到达后，在目标窗口处理函数处理之前，钩子机制允许应用程序截获它进行处理。     </p>
</blockquote>
<p>SetWindowsHookEx函数可以把应用程序定义的钩子函数安装到系统中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HHOOK SetWindowsHookEx(&#10;    Int idHook ;       // &#25351;&#23450;&#38057;&#23376;&#30340;&#31867;&#22411;&#10;    HOOKPROC lpfn;   //&#38057;&#23376;&#20989;&#25968;&#30340;&#22320;&#22336;&#12290;&#22914;&#26524;&#20351;&#29992;&#30340;&#26159;&#36828;&#31243;&#38057;&#23376;&#65292;&#38057;&#23376;&#20989;&#25968;&#24517;&#39035;&#25918;&#22312;&#19968;&#20010;DLL&#20013;&#12290;&#10;    HINSTANCE hMod; //&#38057;&#23376;&#20989;&#25968;&#25152;&#22312;DLL&#30340;&#23454;&#20363;&#21477;&#26564;&#12290;&#22914;&#26524;&#26159;&#19968;&#20010;&#23616;&#37096;&#30340;&#38057;&#23376;&#65292;&#35813;&#21442;&#25968;&#20026;NULL&#12290;&#10;    DWORD    dwThreadID; //&#25351;&#23450;&#35201;&#20026;&#21738;&#20010;&#32447;&#31243;&#23433;&#35013;&#38057;&#23376;&#12290;&#33509;&#35813;&#20540;&#20026;0&#34987;&#35299;&#37322;&#25104;&#31995;&#32479;&#33539;&#22260;&#20869;&#30340;&#12290;&#10;)</span><br></pre></td></tr></table></figure>
<p>IdHook参数指定了要安装的钩子的类型，可以是下列取值之一：</p>
<ul>
<li>WH_CALLWNDPROC      当目标线程调用SendMessage函数发送消息时，钩子函数被调用。</li>
<li>WH_CALLWNDPROCRET                  当SendMessage发送的消息返回时，钩子函数被调用。</li>
<li>WH_GETMESSAGE          当目标线程调用GetMessage或者PeekMessage时。</li>
<li>WH_KEYBOARD              当从消息队列中查询WM_KEYUP或WM_KEYDOWN消息时</li>
<li>WH_MOUSE                      当调用从消息队列中查询鼠标事件消息</li>
<li>WH_MSGFILTER              当对话框，菜单或滚动条要处理一个消息时，钩子函数被调用。该钩子是局部的，它是为哪些有自己消息处理过程的控件对象设计的。</li>
<li>WH_SYSMSGFILTER       和WH_MSGFILTER一样，只不过是系统范围的。</li>
<li>WH_JOURNALRECORD 当Windows从硬件队列中获取消息时。</li>
<li>WH_JOURNALPLAYBACK      当一个事件从系统的硬件输入队列中别请求时</li>
<li>WH_SHELL                        当关于Windows外壳事件发生时，比如任务条需要重画它的按钮</li>
<li>WH_CBT                            当基于计算机的训练（CBT）事件发生时。</li>
<li>WH_FOREGROUNDIDLE Windows自己使用，一般应用程序很少使用。</li>
<li>WH_DEBUG                      用来给钩子函数除错。</li>
</ul>
<p>Lpfn参数是钩子函数的地址。钩子安装后如果有消息发生，Windows将调用此参数所指向的函数。</p>
<p>如果dwThreadId参数是0，或者指定一个由其他进程创建的线程ID，lpfn参数指向的钩子函数必须位于一个DLL中。这是因为进程的地址空间是相互隔离的，发生事件的进程不能调用其他进程地址空间的钩子函数。如果钩子函数的实现代码在DLL中，在相关事件发生时，系统会把这个DLL插入到发生事件的进程的地址空间，使它能够调用钩子函数。这种需要将钩子函数写入DLL以便挂钩其他进程事件的钩子称为<strong>远程钩子</strong>。</p>
<p>如果dwThreadId参数指定一个由自身进程创建的线程ID，lpfn参数指向的钩子函数只要在当前进程中即可，不必非要写入DLL。这种挂钩属于自身进程事件的钩子称为局部钩子。</p>
<p>hMod参数是钩子函数所在DLL的实例句柄，如果钩子函数不再DLL中，应将hMod设置为NULL。</p>
<p>dwThreadId参数指定要与钩子函数相关联的线程ID号。如果设为0，那么钩子就是系统范围内的，即钩子函数将关联到系统内所有线程。</p>
<p>要卸载钩子，可以调用UnhookWindowsHookEx函数。<br> BOOL UnhookWindowsHookEx(HHOOK hhk); // hhk 为要卸载的钩子的句柄</p>
<p>注意：安装钩子的代码可以在DLL模块中，也可以在主模块中，但是一般在DLL里实现它，主要是为了使程序更加模块化。</p>
<p>既然我们要截获的是全局的按键消息，那么就应该将钩子放在DLL中。</p>
<p>Windows钩子都有一个回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">HookProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">         <span class="comment">// 处理该消息的代码 …..</span></span><br><span class="line"> </span><br><span class="line">    Return ::CallNextHookEx(hHook,nCode,wParam,lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HookProc是应用程序的名称。nCode参数是Hook代码，钩子函数使用这个参数来确定任务，它的值依赖于Hook的类型。wParam和lParam参数的值依赖于Hook代码，但是它们典型的值是一些关于发送或者接收消息的信息。</p>
<p>因为系统中可能会有多个钩子的存在，所以要调用那个CallNextHookEx函数把消息传到链中下一个钩子函数。hHook参数是安装钩子时得到的钩子句柄（SetWindowsHookEx的返回值）。</p>
<h2 id="0x02_实现">0x02 实现</h2><p>有了这些知识，我们就可以开始编写：</p>
<p>首先，先创建一个DLL Wizard，为了在主程序中创建钩子，我们需要键入以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure InstallHook(hwnd:THandle);stdcall;export;&#10;begin&#10;    hook:=SetWindowsHookEx(WH_JOURNALRECORD,HookProc,hInstance,0);//&#20854;&#20013;hook&#26159;&#19968;&#20010;HHOOK&#31867;&#22411;&#30340;&#20840;&#23616;&#21464;&#37327;&#65292;&#29992;&#26469;&#20445;&#23384;&#38057;&#23376;&#21477;&#26564;&#10;    hWindow:=hwnd;//hWindow&#20063;&#26159;&#19968;&#20010;HWND&#31867;&#22411;&#30340;&#20840;&#23616;&#21464;&#37327;&#65292;&#29992;&#26469;&#20445;&#23384;&#20027;&#31243;&#24207;&#30340;&#31383;&#21475;&#21477;&#26564;&#65292;&#22312;&#21518;&#38754;&#35201;&#29992;&#21040;&#10;end;</span><br></pre></td></tr></table></figure>
<p>由于DLL与主程序是独立的，所以DLL截获的消息需要发送到主窗口，这里采用的是发送消息，因此要保留主窗体句柄</p>
<p>下面是卸载钩子代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure UnInstallHook;stdcall;export;&#10;begin&#10;  UnhookWindowshookEx(hook);&#10;end;</span><br></pre></td></tr></table></figure>
<p>还有回调函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function HookProc(iCode:longint;&#10;         wParam:WPARAM;lParam:LPARAM):LRESULT;stdcall;&#10;var&#10;  msg:TEventMsg;&#10;  keyState:TKeyState;&#10;begin&#10;  if iCode=HC_ACTION then&#10;  begin&#10;    msg:=PEventMsg(lParam)^;&#10;    if (msg.message=WM_KEYDOWN) or (msg.message=WM_SYSKEYDOWN) then&#10;    begin&#10;      keystate.vKey:=LoByte(msg.paramL);//&#24471;&#21040;&#38190;&#30340;&#34394;&#25311;&#38190;&#30721;&#10;      keystate.bCapsLock:=GetKeyState(VK_CAPITAL)=1;//&#24471;&#21040;CapsLock&#38190;&#29366;&#24577;&#10;      keyState.bNumLock:=GetKeyState(VK_NUMLOCK)&#60;&#62;1;//&#24471;&#21040;Num Lock&#30340;&#29366;&#24577;&#10;      keyState.bCtrl:=GetKeyState(VK_CONTROL) and $80000000=$80000000;//&#24471;&#21040;Ctrl&#38190;&#30340;&#29366;&#24577;&#10;      keyState.bAlt:=GetKeyState(VK_MENU) and $80000000=$80000000;//&#24471;&#21040;Alt&#38190;&#30340;&#29366;&#24577;&#10;      keyState.bShift:=GetKeyState(VK_SHIFT) and $80000000=$80000000;//&#24471;&#21040;Shift&#38190;&#30340;&#29366;&#24577;&#10;      keystate.Sender:=GetActiveWindow;//&#24471;&#21040;&#24403;&#21069;&#27963;&#21160;&#30340;&#31383;&#21475;&#21477;&#26564;&#10;      keystate.Time:=Now;//&#24471;&#21040;&#24403;&#21069;&#26102;&#38388;&#10;      SendMessage(hWindow,WM_MYMSG,Integer(@KeyState),0);//&#21457;&#32473;&#20027;&#31383;&#21475;&#65292;WM_MYMSG&#20026;&#19968;&#20010;&#33258;&#23450;&#20041;&#28040;&#24687;&#65292;&#29992;&#20110;&#21306;&#21035;&#20110;&#20854;&#20182;&#28040;&#24687;&#10;    end;&#10;    result:=0;&#10;  end;&#10;  if iCode&#60;0 then&#10;  begin&#10;    Result:=CallNextHookEx(hook,iCode,wParam,lParam);//&#25346;&#19978;&#19979;&#19968;&#20010;&#38057;&#23376;&#10;  end;&#10;end;</span><br></pre></td></tr></table></figure>
<p>其中TKeyState定义为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type&#10;  TKeyState=record&#10;               vKey:longint;&#10;               bCapsLock,bNumLock,bShift,bCtrl,bAlt:bool;&#10;               Sender:HWND;&#10;               Time:TDateTime;&#10;             end;</span><br></pre></td></tr></table></figure>
<p>用于记录按键消息。</p>
<p>最后将他们输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports&#10;  InstallHook,UnInstallHook,HookProc;</span><br></pre></td></tr></table></figure>
<p>在主窗体Main.pas中写入：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure InstallHook(hwnd:THandle);stdcall;external &#39;Hookdll&#39;;&#10;procedure UnInstallHook;stdcall;external &#39;hookdll&#39;;//&#38745;&#24577;&#38142;&#25509;&#20989;&#25968;</span><br></pre></td></tr></table></figure>
<p>然后调用时用<code>InstallHook(self.Handle);</code>就可以安装钩子了。</p>
<p>至此一个键盘监听器就写好了（详细参考CSDN资源：4428899）</p>
<h2 id="0x03_后记">0x03 后记</h2><p>但是，这个程序还有一点缺陷，就是不能跨用户监听，即如果一台电脑中有多个用户，则用户A的监听器监听不到用户B的按键消息。</p>
<p>我研究过，用户的实质是多个Desktop（即窗口工作站）同时运行（这也是虚拟桌面的工作原理）。我曾试图用CreateProcess()这个API将一个进程跨用户注入到另一个用户的空间中，虽说成功了，但一旦用户切换用户，所有的钩子都将停止，这也令我很苦恼，如果有兴趣的也可以研究一下。</p>
</div></div><div class="page-navigator"><a href="/categories/编程/page/3/" class="pre">上一页</a></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div id="search"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://hsfzxjy.github.io"></form></div></div><div class="widget"><div class="widget-title">导航<ul><li><a href="/archives/"> <i class="icon-archives"> 归档</i></a></li><li><a href="/works/"> <i class="icon-works"> 个人作品</i></a></li><li><a href="/atom.xml"> <i class="icon-rss"> 订阅</i></a></li></ul></div></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂感/">杂感</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载文章/">转载文章</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随手记/">随手记</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/化学/" style="font-size: 15px;">化学</a> <a href="/tags/Delphi/" style="font-size: 15px;">Delphi</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Meta-Classes/" style="font-size: 15px;">Meta Classes</a> <a href="/tags/黑魔法/" style="font-size: 15px;">黑魔法</a> <a href="/tags/元编程/" style="font-size: 15px;">元编程</a> <a href="/tags/杂感/" style="font-size: 15px;">杂感</a> <a href="/tags/诗/" style="font-size: 15px;">诗</a> <a href="/tags/作文/" style="font-size: 15px;">作文</a> <a href="/tags/家书/" style="font-size: 15px;">家书</a> <a href="/tags/成人礼/" style="font-size: 15px;">成人礼</a> <a href="/tags/产品/" style="font-size: 15px;">产品</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/web设计/" style="font-size: 15px;">web设计</a> <a href="/tags/wisecity/" style="font-size: 15px;">wisecity</a> <a href="/tags/前端自动化测试，总结/" style="font-size: 15px;">前端自动化测试，总结</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/单元测试/" style="font-size: 15px;">单元测试</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/不经意间的感动/" style="font-size: 15px;">不经意间的感动</a> <a href="/tags/HFMUN重构系列/" style="font-size: 15px;">HFMUN重构系列</a> <a href="/tags/OOP/" style="font-size: 15px;">OOP</a> <a href="/tags/ubuntu/" style="font-size: 15px;">ubuntu</a> <a href="/tags/apt-get/" style="font-size: 15px;">apt-get</a> <a href="/tags/物理/" style="font-size: 15px;">物理</a> <a href="/tags/创新作文大赛/" style="font-size: 15px;">创新作文大赛</a> <a href="/tags/Sublime/" style="font-size: 15px;">Sublime</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/字体/" style="font-size: 15px;">字体</a> <a href="/tags/百题大过关/" style="font-size: 15px;">百题大过关</a> <a href="/tags/逆袭/" style="font-size: 15px;">逆袭</a> <a href="/tags/MySql/" style="font-size: 15px;">MySql</a> <a href="/tags/NOIP2014/" style="font-size: 15px;">NOIP2014</a> <a href="/tags/信息学竞赛/" style="font-size: 15px;">信息学竞赛</a> <a href="/tags/北大金秋营/" style="font-size: 15px;">北大金秋营</a> <a href="/tags/树状数组/" style="font-size: 15px;">树状数组</a> <a href="/tags/LCA/" style="font-size: 15px;">LCA</a> <a href="/tags/归并排序/" style="font-size: 15px;">归并排序</a> <a href="/tags/逆序对/" style="font-size: 15px;">逆序对</a> <a href="/tags/最小生成树/" style="font-size: 15px;">最小生成树</a> <a href="/tags/数论/" style="font-size: 15px;">数论</a> <a href="/tags/数学/" style="font-size: 15px;">数学</a> <a href="/tags/数列/" style="font-size: 15px;">数列</a> <a href="/tags/高精度/" style="font-size: 15px;">高精度</a> <a href="/tags/UVa/" style="font-size: 15px;">UVa</a> <a href="/tags/Pascal/" style="font-size: 15px;">Pascal</a> <a href="/tags/搜索/" style="font-size: 15px;">搜索</a> <a href="/tags/剪枝/" style="font-size: 15px;">剪枝</a> <a href="/tags/浮点数/" style="font-size: 15px;">浮点数</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/游记/" style="font-size: 15px;">游记</a> <a href="/tags/win32/" style="font-size: 15px;">win32</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/meta-class-in-python/">Python “黑魔法” 之 Meta Classes</a></li><li class="post-list-item"><a class="post-list-link" href="/poems/">诗集</a></li><li class="post-list-item"><a class="post-list-link" href="/life-needs-discovery/">生活，需要被“发现”</a></li><li class="post-list-item"><a class="post-list-link" href="/letter-to-parents/">家书·十八岁成人礼</a></li><li class="post-list-item"><a class="post-list-link" href="/hobby-or-needs/">炫技？还是需求？</a></li><li class="post-list-item"><a class="post-list-link" href="/the-state-of-responsive-images-in-2015/">【译】响应式图片的现状</a></li><li class="post-list-item"><a class="post-list-link" href="/why-are-so-many-programming-languages/">【译】“为什么有这么多的编程语言？”</a></li><li class="post-list-item"><a class="post-list-link" href="/wisecity-conclusion/">Wisecity 商赛总结——也谈前端自动化测试</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-fuck-a-bilk-site/">记一次 DoS 诈骗网站的经历</a></li><li class="post-list-item"><a class="post-list-link" href="/secret/">不能说的秘密</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">thoughts of hsfzxjy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></body><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>$(document).ready(function() {
    $('img').each(function() {
        if ($(this).parent().hasClass('fancybox')) return;
        if ($(this).hasClass('nofancybox')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="caption">' + alt + '</span>');
        $(this).wrap('<a href="' + ($(this).attr('data-src') == null ? this.src : $(this).attr('data-src')) + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article');
    });
});</script><script>$(document).ready(function() {
    $("a[href$='.jpg'],a[href$='.png'],a[href$='.gif']").attr('rel', 'gallery').fancybox({
     helpers : {
     title: { type: 'inside'}
     }
 });
});
</script><script>var duoshuoQuery = {short_name:'hsfzxjy'};
(function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]},
    jax: ["input/TeX","output/HTML-CSS"]
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></html>