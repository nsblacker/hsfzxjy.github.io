
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>主页</title>
    
    <script src="/assets/themes/bootstrap-3/bootstrap/js/jquery.min.js"></script>
    <meta name="author" content="Jinyi Xie">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <!-- Bootstrap styles -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Optional theme -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- Sticky Footer -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bs-sticky-footer.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/assets/themes/bootstrap-3/pygments.css">
    
    <!-- Custom styles -->
    <link href="/assets/themes/bootstrap-3/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <!-- Update these with your own images
      <link rel="shortcut icon" href="images/favicon.ico">
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
    -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div id="wrap">
      <nav class="navbar navbar-default navbar-inverse" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#jb-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">hsfzxjy</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="jb-navbar-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
      	
      	<li><a href="/archieve.html">归档</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">分类</a></li>
      	
      
    
  
    
  
    
      
      	
      	<li><a href="/pages.html">页面</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">标签</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/about/">联系我</a></li>
      	
      
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  



          </ul>
        </div><!-- /.navbar-collapse -->
      </nav>

      <div class="container" id="main-container">
        
<div class="page-header">
  <h1 class="post-title">
         
         <small>Free as wind.</small>
  </h1>
</div>

<div class="row">
  <div class="col-xs-12 post-content">
    
<div class="posts">
  
    <article class="post-content">
        <header class="text-center">
            <h1 class="post-title">
                <a href="/uva12219-common-subexpression-elimination/">UVa12219 Common Subexpression Elimination</a>
            </h1>
            <p class="time">06 Oct 2014</p>
        </header>
        <section class="content">
            <blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3371">Link</a> 状态：<strong>Runtime Error</strong></p>
</blockquote>
<h2>前言</h2>
<p>这题做的可真够久的，整整三个小时。但即便如此，还是只过了一部分的点，另一部分报运行时错误——估计是哈希表设计的不太好。但这确实是一道好题，因此，在睡觉前决定记录一下。</p>
<h2>分析</h2>
<p>很容易便想到：用一个三元组$(x,y,z)$表示节点，表示内容为x的节点下跟着标号为y和z的左右子树。这样一来，一类相同的子树便可以唯一确定了，而不必每构造一棵子树就把整棵树遍历一遍。<br />
对于三元组的储存，刚开始图方便，用了数组。查找也是用了$O(n)$的线性查找。磕磕碰碰写了两个多小时然后兴冲冲地提交，结果TLE了…………没办法，只好又花了半个小时写了一个哈希表，然后就是上文说过的情况了：<strong>Runtime Error204</strong>。可能是哈希数组过大的原因，日后再微调一下，今天实在是没有脑子了。</p>
<h2>Code</h2>
<pre><code>const
  maxn = 20000;
type
  NodeRec = record
    Value: string;
    l, r, index: longint;
  end;
  Node = record
     left, right: longint;   //Index of left and right child in the `tree` array, -1 for none.
     Rec: NodeRec;
     index: longint;
  end;
  //以下为哈希表的定义
  _PNode = ^_Node;
  _Node = record
    n: Node;
    next: _PNode;
  end;

  HashTable = object
    arr: array [0..maxn] of _PNode;
    function hash(n: NodeRec): longint;
    procedure add(n: Node);
    procedure clear;
    function find(n: NodeRec): longint;
  end;

procedure HashTable.clear;
var
  i: longint;
  p, q: _PNode;
begin
  for i := 0 to maxn do
  begin
    p := arr[i];
    while p&lt;&gt;nil do
    begin
      q := p^.next;
      dispose(p);
      p := q;
    end;
  end;
  fillchar(arr, sizeof(arr),0);
end;

function cmp(r1, r2: NodeRec): Boolean;
begin
  cmp := (r1.l = r2.l) and (r1.r = r2.r) and (r1.Value = r2.Value);
end;

function HashTable.hash(n: NodeRec): longint;
var
  i: longint;
begin
  hash := 0;
  for i := 1 to length(n.Value) do
    hash := (hash*5 + ord(n.Value[i]) - ord('a')) mod maxn;
  hash := (hash + n.l * 10 + n.r * 5) mod maxn;
end;

procedure HashTable.add(n: Node);
var
  h: longint;
  p, q: _PNode;
begin
  h := hash(n.rec);
  new(q);
  fillchar(q^, sizeof(_Node), 0);
  q^.next := arr[h];
  q^.n := n;
  arr[h] := q;
end;

function HashTable.find(n: NodeRec): longint;
var
  p: _PNode;
begin
  find := -1;
  p := arr[hash(n)];
  while (p&lt;&gt;nil) and not cmp(n, p^.n.rec) do p := p^.next;
  if p &lt;&gt; nil then
    find := p^.n.index;
end;
//哈系表定义结束
var
  inputs: Ansistring;
  _: longint;
  tree: array [1..50001] of Node;
  cur: longint;              //The current pointer of the input string.
  num: longint;              //The current number of the `tree` array.
  ls: longint;
  t: longint;
  tot: longint;
  ht: HashTable;

function build: longint; //建树
label lb;
var
  rec: NodeRec;
  i,j,l,r: longint;
begin
  l := 0;
  r := 0;
  fillchar(rec, sizeof(rec), 0);
  inc(tot);
  rec.index := tot;
  while (cur&lt;=ls) and (inputs[cur] in ['a'..'z']) do
  begin
    rec.Value := rec.Value+inputs[cur];
    inc(cur);
  end;
  if cur&gt;ls then goto lb;    //。。。这里被迫跳转控制流，由于实在不想多谢，就用了臭名昭著的label
  if inputs[cur] = '(' then
  begin
    inc(cur);
    l := build();
    rec.l := tree[l].rec.index;
    inc(cur);
    r := build();
    rec.r := tree[r].rec.index;
    inc(cur);
  end;
  j := ht.find(rec);
  if j&gt;0 then
  begin
    dec(tot);
    exit(j);
  end
  else
  begin
lb:
    inc(num);
    tree[num].left := l;
    tree[num].right := r;
    tree[num].rec := rec;
    tree[num].index := num;
    ht.add(tree[num]);
    exit(num);
  end;
end;

procedure print(n: longint);
begin
  if tree[n].rec.index &gt; t then
  begin
    write(tree[n].rec.Value);
    t := tree[n].rec.index;
  end
  else
  begin
    write(tree[n].rec.index);
    exit;
  end;
  if tree[n].right = 0 then
    exit;
  write('(');
  print(tree[n].left);
  write(',');
  print(tree[n].right);
  write(')');
end;
begin
  assign(input, 'main.in'); reset(input);
  assign(output, 'main.out'); rewrite(output);
  readln(_);
  fillchar(ht.arr, sizeof(ht.arr),0);
  while _&gt;0 do
  begin
    dec(_);
    readln(inputs);
    fillchar(tree, sizeof(tree), 0);
    ht.clear;
    ls := length(inputs);
    cur := 1;  num := 0; tot := 0;
    build;
    t := 0;
    print(num);
    writeln;
  end;
  close(input); close(output);
end.
</code></pre>

        </section>
        
          <ul class="tag_box inline">
            <li><i class="glyphicon glyphicon-open"></i></li>
            
            


  
     
    	<li><a href="/categories.html#uva-ref">
    		uva <span>12</span>
    	</a></li>
     
    	<li><a href="/categories.html#信息学竞赛-ref">
    		信息学竞赛 <span>24</span>
    	</a></li>
     
    	<li><a href="/categories.html#编程-ref">
    		编程 <span>32</span>
    	</a></li>
    
  


          </ul>
          

         
    </article>
  
    <article class="post-content">
        <header class="text-center">
            <h1 class="post-title">
                <a href="/uva536-recovery/">UVa536 Recovery</a>
            </h1>
            <p class="time">06 Oct 2014</p>
        </header>
        <section class="content">
            <blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=7&amp;page=show_problem&amp;problem=477">Link</a> 耗时: 0.012s</p>
</blockquote>
<h2>前言</h2>
<p>真是疯玩了几天，脑袋都残了，一道弱智题做了近一个小时。</p>
<h2>Code</h2>
<pre><code>var
    pre, mid, s: string;
    tree: array [1..50] of record
        l, r: integer;
        ch: char;
    end;
    cur: integer;
function init: integer;
var
    m: integer;
begin
    readln(s);
    m := length(s) &gt;&gt; 1 + 1;
    pre := Copy(s, 1, m-1);
    mid := Copy(s, m+1, length(s));
    init := m-1;
end;
function build(l1, l2, r2: integer): integer;
var
    m,len: integer;
    t: integer;
begin
    if l2 &gt; r2 then exit(0); //该子树不存在。**这个地方坑了我很久**
    inc(cur);
    t := cur;      // 这里也坑了我，当下面构造完左右子树后，cur已经变了，所以要缓存起来
    build := t;  
    tree[t].ch := pre[l1]; 
    if r2-l2 = 0 then //叶节点
        exit;
    m := pos(pre[l1], mid); //在中序遍历中找根节点
    len := m - l2;
    tree[t].l := build(l1+1, l2, m-1); //构造左子树
    tree[t].r := build(l1+len+1, m+1, r2); //构造右子树
end;
procedure print(x: integer);
begin
    if x = 0 then exit;
    print(tree[x].l);
    print(tree[x].r);
    write(tree[x].ch);
end;
begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);
    while not eof do
    begin
        fillchar(tree, sizeof(tree), 0);
        cur := 0;
        build(1, 1, init);
        print(1);
        writeln;
    end;
    close(input);
    close(output);
end.
</code></pre>

        </section>
        
          <ul class="tag_box inline">
            <li><i class="glyphicon glyphicon-open"></i></li>
            
            


  
     
    	<li><a href="/categories.html#uva-ref">
    		uva <span>12</span>
    	</a></li>
     
    	<li><a href="/categories.html#信息学竞赛-ref">
    		信息学竞赛 <span>24</span>
    	</a></li>
     
    	<li><a href="/categories.html#编程-ref">
    		编程 <span>32</span>
    	</a></li>
    
  


          </ul>
          

         
    </article>
  
    <article class="post-content">
        <header class="text-center">
            <h1 class="post-title">
                <a href="/uva11582-colossal-fibonacci-numbers/">UVa11582 Colossal Fibonacci Numbers! && 大数操作</a>
            </h1>
            <p class="time">01 Oct 2014</p>
        </header>
        <section class="content">
            <blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=27&amp;problem=2629&amp;mosmsg=Submission%20received%20with%20ID%2014290914">Link</a> 耗时：0.139s</p>
</blockquote>
<h2>前言</h2>
<p>这道题的主要思路就是打表，看看Fibonacci数列模n几个一循环。但由于这题给的数太大了，从而在细节上耗了很久。在此记录一下：</p>
<pre><code>var
    x: qword;
    y: longint;
begin
    x := 1&lt;&lt;64-1;
    y := 100;
    x := x mod y; //报错201
    x := x mod qword(y); //正确
end.
</code></pre>
<h2>Code</h2>
<pre><code>var
    a,b: qword;
    _, n, i, k, cnt: longint;
    f: array [1..1000000] of longint;

function superMod(a, b: qword; m: longint): longint;
var
    x: qword;
begin
    if b = 0 then
        exit(1);
    x := superMod(a, b shr 1, m);
    superMod := x * x mod m;
    if odd(b) then
        superMod := superMod * a mod m;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);
    readln(_);
    while _ &gt; 0 do
    begin
        dec(_);
        readln(a, b, n);
        if a = 0 then
        begin
            writeln(0);
            continue;
        end;
        if n = 1 then
        begin
            writeln(0);
            continue;
        end;
        f[1] := 1;
        f[2] := 1;
        cnt := 2;
        while not ((f[cnt-1] = 1) and (f[cnt] = 0)) do
        begin
            inc(cnt);
            f[cnt] := (f[cnt-1] + f[cnt-2]) mod n;
        end;
        //while x &gt; int64(1 &lt;&lt;60) do
        //    x := x - int64((cnt &lt;&lt; 59));
        a := a mod qword(cnt);
        k := superMod(a, b, cnt);
        writeln(f[k]);
    end;
    close(output); close(input);
end.
</code></pre>

        </section>
        
          <ul class="tag_box inline">
            <li><i class="glyphicon glyphicon-open"></i></li>
            
            


  
     
    	<li><a href="/categories.html#uva-ref">
    		uva <span>12</span>
    	</a></li>
     
    	<li><a href="/categories.html#信息学竞赛-ref">
    		信息学竞赛 <span>24</span>
    	</a></li>
     
    	<li><a href="/categories.html#编程-ref">
    		编程 <span>32</span>
    	</a></li>
    
  


          </ul>
          

         
    </article>
  
    <article class="post-content">
        <header class="text-center">
            <h1 class="post-title">
                <a href="/extended-gcd-algorithm/">扩展欧几里得算法</a>
            </h1>
            <p class="time">01 Oct 2014</p>
        </header>
        <section class="content">
            <blockquote>
<p>今天开始学习数论方面的算法。这部分在NOIP中并不常出现，即使出现了也不会像高联这么难（。。。）。</p>
</blockquote>
<h2><strong>什么是扩展欧几里得算法</strong></h2>
<p>所谓欧几里得算法，实际上就是辗转相除法——求两个数最大公约数的一种高效算法。而扩展欧几里得算法则是来源于于一类方程的解决：<br />
$$ax+by=gcd(a,b)$$<br />
这有点像是<strong>裴蜀定理</strong>的一般形式。和裴蜀定理类似，这类方程也有无数多个整数解。如何高效率地求得它的一组特解呢？</p>
<h2><strong>代码</strong></h2>
<pre><code>procedure gcd_ex(a, b: longint; var d: longint; var x, y: longint);
begin
    if b = 0 then
    begin
        d := a;
        x := 1;
        y := 0;
        exit;
    end;
    gcd_ex(b, a mod b, d, y, x); //重要
    y := y-(a div b) * x;
end;
</code></pre>
<h2><strong>详解</strong></h2>
<p>乍一看，算法似乎和一般欧几里得算法很是相似：都是递归实现，参数传递过程中都体现了“辗转相除”的思想。那为什么这个算法是正确的呢？</p>
<p>这里先解释一下参数：</p>
<ul>
<li>a：方程中的参数a</li>
<li>b：方程中的参数b</li>
<li>d：即<code>gcd(a,b)</code>。由于和辗转相除法的相似性，在这里最大公约数也可以“顺便”算出。当然，去掉也无大碍</li>
<li>x&amp;y：方程的一组特解(x, y)</li>
</ul>
<p>下面解释标注了<strong>重要</strong>的那行代码。</p>
<p>假设方程 $ax+by=gcd(a,b)$ 有一组特解$(x_0,y_0)$。则有$ax_0+by_0=gcd(a,b)$。<br />
由最大公约数原理可知：$gcd(a,b)=gcd(b, a\ mod\ b)$。从而有$ax_0+by_0=gcd(b,a\ mod\ b)$。<br />
又方程：$bx+(a\ mod\ b)y=gcd(b,a\ mod\ b)$一定有整数解，设其为$(x_1,y_1)$。则有<br />
$$ax_0+by_0=gcd(b,a\ mod\ b)=bx_1+(a\ mod\ b)y_1$$即$$ax_0+by_0=bx_1+(a-(a\ div\ b)*b)y_1$$即$$a(x_0-y_1)=b(x_1-(a\ div\ b)y_1-y_0)$$由恒等原理可知：$$x_0=y_1$$$$y_0=x_1-(a\ div\ b)y_1$$。<br />
因此，当$a,b\neq0$时，$x,y$的值可以递归求得。递归边界为：$b=0$时$x=1,y=0$。<br />
注意到上面的算法用到了一个技巧：在递归传参数的时候将y,x调换了。这样做的好处是节省了一个中间变量用来储存$y_1$，否则在计算$y_0$时$y_1$也被覆盖了。从而使算法更加的精简。</p>
<h2><strong>应用</strong></h2>
<ul>
<li>计算几何中求整点的问题</li>
<li>求一元一次同余方程$a\equiv b\pmod{m}$的一组特解。（即方程$ax+my=b$的一组特解）</li>
</ul>

        </section>
        
          <ul class="tag_box inline">
            <li><i class="glyphicon glyphicon-open"></i></li>
            
            


  
     
    	<li><a href="/categories.html#信息学竞赛-ref">
    		信息学竞赛 <span>24</span>
    	</a></li>
     
    	<li><a href="/categories.html#编程-ref">
    		编程 <span>32</span>
    	</a></li>
    
  


          </ul>
          

         
    </article>
  
    <article class="post-content">
        <header class="text-center">
            <h1 class="post-title">
                <a href="/uva10285-cake-slicing/">UVa10285 Cake Slicing</a>
            </h1>
            <p class="time">01 Oct 2014</p>
        </header>
        <section class="content">
            <blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=825&amp;page=show_problem&amp;problem=4504">Link</a>  耗时：1.825s</p>
</blockquote>
<p>这道题做的可真够久的：前前后后加起来将近有两个小时，因此当AC的那一刻，自己心中还是挺自豪的。<br />
事实上，这是一道复杂一点的区间型动态规划，之所以说“复杂”，是因为它的状态转移是<strong>二维</strong>的：切蛋糕既可以横切，也可以纵切。由此我想到了分治算法：</p>
<blockquote>
<p>假设一个矩形它所需要切的刀数是f，则f可以由组成该矩形的小矩形的f值决定。</p>
</blockquote>
<p>因此，这个问题具有最优子结构。由于每个状态为一个矩形，因此需要4个维度来记录状态（及左上、右下两个顶点）。下面是横切时的状态转移方程，纵切时同理可得：</p>
<blockquote>
<p>f(up, down, left, right) = min{f(up, i, left, right) + f(i, down, left, right) + right - left} (i = up + 1 .. down -1)</p>
</blockquote>
<p>Code:</p>
<pre><code>{$R-}
const INF = maxint div 5; //正无穷
var
    f: array [0..20, 0..20, 0..20, 0..20] of integer;
    cherries: array [1..500, 1..2] of integer;
    map: array [0..20, 0..20] of boolean;
    n, m, i, k: integer;

function min(x, y: integer): integer; inline;
begin
    if x&lt;y then exit(x) else exit(y);
end;

function cherryin(u, d, l, r: integer): integer; inline; //判断矩形内有没有樱桃
var
    i, j: integer;
begin
    cherryin := 0;
    for i := u+1 to d do
        for j := l+1 to r do
            if map[i, j] then
            begin
                inc(cherryin);
                if cherryin = 2 then exit;
            end;
end;

function dp(u, d, l, r: integer): integer;
var
    b: integer;
    i: integer;
begin
    if f[u, d, l, r] &lt;&gt; -1 then
        exit(f[u,d , l, r]);
    b := cherryin(u, d, l, r);
    if b = 1 then
    begin
        f[u, d, l, r] := 0;
        exit(0);
    end;
    if b = 0 then
    begin
        f[u, d, l, r] := INF;
        exit(INF);
    end;
    dp := INF;
    for i := u+1 to d-1 do
        dp := min(dp, dp(u, i, l, r)+dp(i, d, l, r)+r-l);
    for i := l+1 to r-1 do
        dp := min(dp, dp(u, d, l, i)+dp(u, d, i, r)+d-u);
    f[u, d, l, r] := dp;
end;

var
    _: integer;

begin
    assign(input, 'main.in');reset(input);
    assign(output, 'main.out');rewrite(output);
    _ := 0;
    readln(n, m, k);
    while n&gt;0 do
    begin
        inc(_);
        fillchar(map, sizeof(map), 0);
        fillchar(f, sizeof(f), -1);
        for i := 1 to k do
        begin
            readln(cherries[i, 1], cherries[i, 2]);
            map[cherries[i, 1], cherries[i, 2]] := true;
        end;
        writeln('Case ',_,': ', dp(0,n,0,m));
        readln(n, m, k);
    end;
    close(input);close(output);
end.
</code></pre>

        </section>
        
          <ul class="tag_box inline">
            <li><i class="glyphicon glyphicon-open"></i></li>
            
            


  
     
    	<li><a href="/categories.html#uva-ref">
    		uva <span>12</span>
    	</a></li>
     
    	<li><a href="/categories.html#信息学竞赛-ref">
    		信息学竞赛 <span>24</span>
    	</a></li>
     
    	<li><a href="/categories.html#编程-ref">
    		编程 <span>32</span>
    	</a></li>
    
  


          </ul>
          

         
    </article>
  
</div>

<ul class="pager">
  
    <li class="previous">
      <a class="prev" href="/page9/">&larr; Previous</a>
    </li>
  
  
  <li class="next">
    <a class="next" href="/page7/">Next &rarr;</a>
  </li>
  
</ul>

  </div>
</div>


      </div>

    </div>

    <div id="footer">
      <div class="container">
        <p class="text-center">
          Powered by Jekyll. Hosted at Github. <br>
          Copyright &copy; hsfzxjy.
        </p>
      </div>
    </div>

    <script type="text/javascript">
    var duoshuoQuery = {short_name:"hsfzxjy"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
    </script>
    


    <!-- Latest compiled and minified JavaScript, requires jQuery 1.x (2.x not supported in IE8) -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/assets/themes/bootstrap-3/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default" defer async="true"></script>
  </body>
</html>

