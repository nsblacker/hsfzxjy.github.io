<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>hsfzxjy</title>
        <description>hsfzxjy - Jinyi Xie</description>
        <link>http://hsfzxjy.github.io</link>
        <link>http://hsfzxjy.github.io</link>
        <lastBuildDate>2015-04-22T19:42:22+08:00</lastBuildDate>
        <pubDate>2015-04-22T19:42:22+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>HTML5 多媒体测试</title>
                <description>&lt;h3&gt;音频测试&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;video&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://www.w3school.com.cn/i/movie.ogg&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;controls=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;controls&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
您的浏览器不支持 video 标签。
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/video&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;audio&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://www.w3school.com.cn/i/horse.ogg&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;controls=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;controls&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
Your browser does not support the audio element.
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/audio&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;center&gt;
    &lt;video src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; controls=&quot;controls&quot;&gt;
    您的浏览器不支持 video 标签。
    &lt;/video&gt;
    &lt;audio src=&quot;http://www.w3school.com.cn/i/horse.ogg&quot; controls=&quot;controls&quot;&gt;
        Your browser does not support the audio element.
    &lt;/audio&gt;
&lt;/center&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/html5-media-test/</link>
                <guid>http://hsfzxjy.github.io/html5-media-test</guid>
                <pubDate>2015-04-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>如何备份apt-get已安装的软件列表？</title>
                <description>&lt;p&gt;&lt;code&gt;apt-get&lt;/code&gt;是 ubuntu 下管理软件包的一个工具，实用简单，功能强大。平时若要安装或卸载软件包，只需轻敲一条指令即可。每一台ubuntu上，都安装着数以千百计的软件包——或是内核模块，或是工作、娱乐所需的软件，在它们的支持下，工作着这个开放的操作系统。&lt;/p&gt;

&lt;p&gt;但，如果有一天，系统需要被重装——或是无可救药了，抑或是购置了新的设备，问题来了：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何将现有电脑上的软件包迁移至新的系统呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很简单。&lt;/p&gt;

&lt;p&gt;首先，将原有的软件列表导出：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo dpkg --get-selections  &amp;gt; app-backup-list.lst
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最好是设置一个定时任务，每隔一段时间就保存一次列表，并且要保存到一个独立的分区。以免某天系统真的坏了。&lt;/p&gt;

&lt;p&gt;接下来便是导入了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo dpkg --set-selections &amp;lt; app-backup-list.lst
sudo apt-get -y update
sudo apt-get dselect-upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于软件源的备份，只需将&lt;code&gt;/etc/apt/sources.list&lt;/code&gt;文件复制过去即可。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/backup-apt-get/</link>
                <guid>http://hsfzxjy.github.io/backup-apt-get</guid>
                <pubDate>2015-04-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>博客迁移至Github.io</title>
                <description>&lt;h3&gt;为什么迁出？&lt;/h3&gt;

&lt;p&gt;话说&lt;strong&gt;SinaAppEngine&lt;/strong&gt;真是越来越不像话了：在没有征得我们开发者的同意的情况下擅自把应用总数限制调整为5个（整整少了一半！），还口口声声说是作过调查——&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“大约90%开发者只用5个应用就足够了。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时，增加配额的钱还那么贵，实在担负不起的我只好精简应用数目，以防未来某天应用数不够用。&lt;/p&gt;

&lt;h3&gt;为什么选择Github Pages？&lt;/h3&gt;

&lt;p&gt;本人爱好程序，习惯以代码的方式来做事——写文章时也不例外。因此，我需要找到一个支持Markdown的博客平台进行迁移。为此，我经历了很长时间的思想斗争——&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;新浪、网易 等国内博客平台？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;果断否决。这些平台都是面向大众的，只提供富文本编辑器，效率捉急。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;博客园？“程序员的网上家园”，总会好一些吧？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽说最近博客园推出了Markdown编辑器，一切似乎很美好。但是——它——没有即时预览的功能！！这么重要的东西都不加上，写作时就像浑水中摸鱼一样，别提多不爽了。再说了，在博客园上聚集的多是些常工作于Windows平台下的程序员，在“信仰”方面有些合不来（别打我～～）。思考再三，还是否决了。&lt;/p&gt;

&lt;p&gt;而事实上，比起公共博客平台，我还是比较喜欢个人博客。一来逼格比较高，可以为将来的交友、面试等活动加分；二来可以随心所欲地自定义样式，使网站完全符合我的Style。&lt;/p&gt;

&lt;p&gt;这么一来，似乎就只剩下Github Pages了。&lt;/p&gt;

&lt;h3&gt;那么，如何在Github Pages上进行写作？&lt;/h3&gt;

&lt;p&gt;首先要介绍一下 Github Pages 的架构。先看看 &lt;a href=&quot;https://help.github.com/articles/using-jekyll-with-pages/#using-jekyll&quot;&gt;Github的介绍&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;h4&gt;Using Jekyll&lt;/h4&gt;

&lt;p&gt;Every GitHub Page is run through Jekyll when you push content to a specially named branch within your repository. For User Pages, use the master branch in your username.github.io repository. For Project Pages, use the gh-pages branch in your project&amp;#39;s repository. Because a normal HTML site is also a valid Jekyll site, you don&amp;#39;t have to do anything special to keep your standard HTML files unchanged. Jekyll has thorough documentation that covers its features and usage. Simply start committing Jekyll formatted files and you&amp;#39;ll be using Jekyll in no time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看得出来，Github Pages使用Jekyll作为后端引擎——这是一个用Ruby写的博客框架。但用户不需要写一行Ruby的代码，只需在名为&lt;strong&gt;&lt;username&gt;.github.io&lt;/strong&gt;的项目下面以一定的目录结构放置markdown文件，Jekyll便会自动生成整个站点。&lt;/p&gt;

&lt;p&gt;这里需要注意的是，Jekyll生成的站点是&lt;strong&gt;静态的&lt;/strong&gt;，也就是说站点的文件是Jekyll编译好之后存放在服务器端的，而不是接到请求之后才去编译站点，因此站点的访问速度是相当快的——这也是它的优点。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;我被这种机制深深地震惊了：这是一种我从来没见过的写作方式，无论是从方式上，抑或是从形式上。Jekyll 能让你真正专注于写作，而不是其他一些无谓的东西。     &lt;/p&gt;

&lt;p&gt;它把一切无关的东西都摒弃了，这才是真正的极简主义。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;最初的Jekyll站点是没有样式的。为了不重复发明轮子，我决定使用现成的主题。在网上略一搜索便有了收获：&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;Jekyll Bootstrap&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Bootstrap是我最常用，也是最欣赏的一个前端框架。因此尽管这个主题仍在开发当中，我还是毫不犹豫地选中了它。    &lt;/p&gt;

&lt;p&gt;从 &lt;a href=&quot;https://github.com/plusjade/jekyll-bootstrap.git&quot;&gt;Github&lt;/a&gt; 上将这个项目 clone 下来，覆盖到hsfzxjy.github.io项目下，理论上，站点就可以运行了。接下来，进行一些样式上的微调就可以了。   &lt;/p&gt;

&lt;p&gt;至于评论系统，由于 Github Pages 是静态站点，因此只能使用第三方评论服务。Jekyll 默认的评论服务是Disqus ——一个国外的评论服务站点，但考虑到我在国内，许多人无法使用Facebook，Twitter等社交平台登录评论，我将它替换为了&lt;strong&gt;多说&lt;/strong&gt;。具体操作，可以参考 &lt;a href=&quot;http://havee.me/internet/2013-07/add-duoshuo-commemt-system-into-jekyll.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Github Pages上的文章只能在本地编辑，因而需要一个趁手的 Markdown 编辑器。在 Ubuntu 环境下我使用的是 &lt;strong&gt;ReText&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt-get install retext 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://hsfzxjy.github.io/migrate-to-github/</link>
                <guid>http://hsfzxjy.github.io/migrate-to-github.io</guid>
                <pubDate>2015-04-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu 网络每20秒断开重连一次的解决方案</title>
                <description>&lt;p&gt;从昨天到现在一直都有这个问题，刚刚突然就解决了，至今不明白原理，在此记录一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在网络设置中取消&lt;strong&gt;需要IPv6完成这个链接&lt;/strong&gt;的选项&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <link>http://hsfzxjy.github.io/solution-of-network-broken-down-per-20s-under-ubuntu/</link>
                <guid>http://hsfzxjy.github.io/ubuntu-%e7%bd%91%e7%bb%9c%e6%af%8f20%e7%a7%92%e6%96%ad%e5%bc%80%e9%87%8d%e8%bf%9e%e4%b8%80%e6%ac%a1%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88</guid>
                <pubDate>2015-03-31T19:18:38+08:00</pubDate>
        </item>

        <item>
                <title>关于正弦交流电有效值计算公式的证明</title>
                <description>&lt;h3&gt;公式&lt;/h3&gt;
&lt;p&gt;$I = {I_m \over \sqrt{2}}$&lt;/p&gt;
&lt;h3&gt;证明&lt;/h3&gt;
&lt;p&gt;设 $I = Asin\omega t$，则$I^2 = A^2sin^2\omega t$。&lt;/p&gt;
&lt;p&gt;取半个周期进行计算：$${Q \over R} $$&lt;br /&gt;
$$= \int_0^{T \over 2} I^2tdt$$&lt;br /&gt;
$$={A^2 \over 2}(t - {sin2\omega t \over 2\omega})|_{0}^{T \over 2}$$&lt;br /&gt;
$$={A^2T \over 4}$$&lt;br /&gt;
$$={I^2T \over 2}$$&lt;/p&gt;
&lt;p&gt;进而： $I = {A \over \sqrt{2}}$&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/provement-of-Sinusoidal-AC-RMS-calculation-formula/</link>
                <guid>http://hsfzxjy.github.io/%e5%85%b3%e4%ba%8e%e6%ad%a3%e5%bc%a6%e4%ba%a4%e6%b5%81%e7%94%b5%e6%9c%89%e6%95%88%e5%80%bc%e8%ae%a1%e7%ae%97%e5%85%ac%e5%bc%8f%e7%9a%84%e8%af%81%e6%98%8e</guid>
                <pubDate>2015-03-04T19:32:50+08:00</pubDate>
        </item>

        <item>
                <title>【HFMUN重构系列】3. 消息系统</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;一个真正优秀的系统，值得你无数次地去重构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;消息系统算是网站比较重要的一部分，它承担着将&lt;strong&gt;已发生的事件通知给相关用户&lt;/strong&gt;的责任。看似简单，但若想做到DRY，实现起来却很复杂——因为，通知的类型太多了。&lt;/p&gt;
&lt;p&gt;这个系统，在三个项目中我实现了三次。三次都使用不同的方法，但三次都不怎么满意。这最后一次，算是比较成功的一次了。&lt;/p&gt;
&lt;p&gt;在第一版模联网站中，我采用了一个堪称最糟糕的方案（如图所示）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/wboard_notifications.jpg&quot; alt=&quot;UML&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这个方案最大的缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;耦合度太高&lt;/strong&gt;。如果有一天，又多了一种消息类型，那么就要多加一张表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询的难度大&lt;/strong&gt;。通常来说我们需要显示所有的消息，从而需要使用JOIN语句进行多表联查——这效率是很低的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL本身就不是面向对象的&lt;/strong&gt;。虽说&lt;code&gt;CommentNotification&lt;/code&gt;是&lt;code&gt;Notification&lt;/code&gt;的子类，可查询时却并不能使用类似&lt;code&gt;Notification.objects.all()&lt;/code&gt;一类的语句。在一定程度上可以说：SQL本身就不是面向对象的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而在第二版模联网站中，我采用了&lt;a href=&quot;https://docs.djangoproject.com/en/1.7/ref/contrib/contenttypes/&quot;&gt;泛型&lt;/a&gt;（Generic Model Relations）这一技术来实现——这是Django另一大特色：&lt;strong&gt;通过记录对象的类型信息以及唯一标识符，实现了一种可以指向任何表的外键（GenericRelation）&lt;/strong&gt;。这种技术存在的目的就是为了&lt;strong&gt;解耦合&lt;/strong&gt;，使系统扩展更具灵活性——尽管要损失一些效率，但与架构的“健康”比起来那是微不足道的，无可厚非。&lt;/p&gt;
&lt;p&gt;UML图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/hfmun_notices.jpg&quot; alt=&quot;UML&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这其中，&lt;code&gt;notice_type&lt;/code&gt;的取值决定了&lt;strong&gt;&lt;code&gt;url&lt;/code&gt;域的作用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;link&lt;/code&gt;&lt;/strong&gt;。该消息的&lt;code&gt;url&lt;/code&gt;域表示一个指向&lt;code&gt;related_object&lt;/code&gt;的地址，应该展示给用户看。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/strong&gt;。该消息需要在用户确认后执行一个动作。其&lt;code&gt;url&lt;/code&gt;域表示需要执行的动作的地址——这里有些TaskQueue的意味。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，发消息时又应该怎么做呢？如果在所有的地方都来一句：&lt;code&gt;Notice.create(......)&lt;/code&gt;，那也太不DRY了吧？&lt;/p&gt;
&lt;p&gt;有人说：“懒惰是程序员的天性。”&lt;/p&gt;
&lt;p&gt;我赞同，但我还想补充一句：“懒惰更是程序员精简代码的动力。”&lt;/p&gt;
&lt;p&gt;于是，我创立了一个类&lt;code&gt;NoticeDispatcher&lt;/code&gt;，用于分发消息——其实这一类工具代码在之前的系统中也存在过，只不过这一版本的令我更为满意。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class NoticeDispatcher(object):

    def __init__(self, model, default = {}):
        if not issubclass(model, SendNoticeModelMixin):
            raise TypeError('The `model` must be a subclass of  `SendNoticeModelMixin`.')
        self.__model = model
        self.__default = {}
        self.__default.update(default)

    def send(self, *args, **kwargs):
        klass = Notice

        title = self.__model.generate_title(*args, **kwargs) 
        content = self.__model.generate_content(*args, **kwargs) 
        url = self.__model.generate_url(*args, **kwargs)
        user = self.__model.generate_user(*args, **kwargs)

        valid_keys_set = set(kwargs.iterkeys()) &amp;amp; \
            set(field.name for field in klass._meta.fields)

        params = deepcopy(self.__default)
        params.update({key: kwargs[key] for key in valid_keys_set})
        params.update({
            'title': title,
            'content': content,
            'url': url,
        })

        results = []
        try:
            iter(user)
        except:
            user = (user,)

        for _user in user:
            params['user'] = _user
            notice = klass(*args, **params)
            notice.save()
            results.append(notice)

        return results
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以传入一个模型类作为参数从而获得一个&lt;code&gt;NoticeDispatcher&lt;/code&gt;对象。这个模型类被要求继承于&lt;code&gt;notices.mixins.SendNoticeModelMixin&lt;/code&gt;，以完成一些默认的配置——这是一个抽象基类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SendNoticeModelMixin(object):

    @classmethod
    def generate_title(klass, *args, **kwargs):
        return ''

    @classmethod
    def generate_content(klass, *args, **kwargs):
        return ''

    @classmethod
    def generate_url(klass, *args, **kwargs):
        return ''

    @classmethod
    def generate_user(klass, *args, **kwargs):
        return []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;做完这一切之后，每当调用&lt;code&gt;notice_dispatcher.send()&lt;/code&gt;方法时，&lt;code&gt;NoticeDispatcher&lt;/code&gt;会自动调用模型类中的&lt;code&gt;generate_*&lt;/code&gt;方法以获取构建消息对象的默认参数。像一些基本不变的内容——如&lt;code&gt;url&lt;/code&gt;、&lt;code&gt;title&lt;/code&gt;就可以用代码自动生成，进而提高代码复用率。&lt;/p&gt;
&lt;p&gt;当然，这个系统仍有一些不够完善的地方，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;notice_type&lt;/code&gt;为&lt;code&gt;invoke&lt;/code&gt;时的逻辑至今尚未实现。&lt;/li&gt;
&lt;li&gt;当消息的构建不需要&lt;code&gt;related_object&lt;/code&gt;参数时，仍需调用原生的&lt;code&gt;create&lt;/code&gt;方法，非常麻烦。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;related_object&lt;/code&gt;参数仍需手动传入，有些不干净——最好就是能在&lt;code&gt;SendNoticeModelMixin&lt;/code&gt;上实现&lt;code&gt;send&lt;/code&gt;方法，很多啰嗦的代码便又可以省略掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上问题，或是由于没有需求，或是由于懒惰（- -!），没有来得及去实现。但愿能在下一次改进时解决。&lt;/p&gt;
&lt;p&gt;总而言之呢，事情正在似乎在朝着好的方面发展。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/HFMUN-reconstruction-3/</link>
                <guid>http://hsfzxjy.github.io/%e3%80%90hfmun%e9%87%8d%e6%9e%84%e7%b3%bb%e5%88%97%e3%80%913-%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f</guid>
                <pubDate>2015-03-03T21:53:20+08:00</pubDate>
        </item>

        <item>
                <title>十年</title>
                <description>&lt;p&gt;再一次站在这里，我却发现早已没有了熟悉的感觉。一切都是那样陌生：长年累月的雨水冲刷，使原本灰色的墙面变得愈加晦暗，有几处墙皮脱落了，酷似一张布满皱纹的老脸；门前，野草肆意地疯长着，没过了缩在墙角的那根水管——记忆中它一直在渗水，却不知何时被修好了，只留下了一圈丑陋的青苔，像是对这十年光阴的一个标注。&lt;/p&gt;
&lt;p&gt;这里的一切，就像是被人遗弃了。四周站着的那一圈高楼，无时无刻不在表达着对这角隅的不屑——就像长辈们对待无知的孩童一样。&lt;br /&gt;
而事实上，这里比周围的一切都要年长。&lt;/p&gt;
&lt;p&gt;时光上溯十年，那时，我居住于此。那时，还没有周围这一切。&lt;/p&gt;
&lt;p&gt;曾记得，在不远处的那块菜地，我和小伙伴趟过泥水，猫着腰在捕捉小鱼小虾。柔软的泥土记录这我们的足迹，竹架上的蔬果聆听着我们的欢笑，就连那不知名的虫儿，也哼起歌为我们助兴。&lt;/p&gt;
&lt;p&gt;曾记得，在屋后的那片小树林，上演过一次又一次的“探险之旅”。不畏阴暗，不惧神秘，只求抵达尽头时那种大汗淋漓的快意。&lt;/p&gt;
&lt;p&gt;曾记得，在楼顶的天台，我第一次仰望星空。夏夜的风吹起架子上的藤蔓，吹拂着我的脸庞。和着如水的月光，四周的一切就像仙境般梦幻。&lt;/p&gt;
&lt;p&gt;这里，有着我童年的所有回忆。&lt;/p&gt;
&lt;p&gt;可如今，这一切都像是未曾发生过。这里，也未曾记得。&lt;/p&gt;
&lt;p&gt;十年，很长，长得足以让一个人，去遗忘一个地方。&lt;/p&gt;
&lt;p&gt;再一次遇见他，没有太多的喜悦，只是相视一笑，随即，便陷入了沉默。&lt;/p&gt;
&lt;p&gt;比起上一次相遇，他又有了一些变化，整个人显得更加成熟了。但与此同时，一种未知的像雾一样的却在我们中间弥散开来，凝固着空气，窒息着心灵。&lt;/p&gt;
&lt;p&gt;我竭力搜寻着话题，想要打破这恼人的尴尬，但却徒劳无功——真的没有共同语言了，毕竟在新的环境里，我们都有了新的爱好。&lt;/p&gt;
&lt;p&gt;真是一个让人迷惑的时代——在这里，共有着美好的回忆，却也无法维系十年的友情。&lt;/p&gt;
&lt;p&gt;在那人生的上古时期，他，是我最好的朋友，一起逃过课，在小学边上的山坡尽情地疯玩；一起偷过钱，忐忑地在小商店购买垂涎已久的零食。那些年和他，一玩能玩一天，一聊能聊一宿。我们有过争吵，而更多时候，我们亲如弟兄。&lt;/p&gt;
&lt;p&gt;记忆中的那些画面，每一张笑脸，每一滴眼泪，都是那样真诚。&lt;/p&gt;
&lt;p&gt;只是，曾经的旧知己，最终还是变不到老友。&lt;/p&gt;
&lt;p&gt;十年，很长，长得足以让一个人，去疏远另一个人。&lt;/p&gt;
&lt;p&gt;十年，真的很长。承载着过去的回忆，有欢笑，有泪水——就像是人那短暂一生的缩影。&lt;/p&gt;
&lt;p&gt;人生又能有几个十年？无从得知。&lt;/p&gt;
&lt;p&gt;因此，每一个十年都弥足珍贵；每一个十年，都要用心去珍惜。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/ten-years/</link>
                <guid>http://hsfzxjy.github.io/%e5%8d%81%e5%b9%b4</guid>
                <pubDate>2015-03-03T20:19:18+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu杀死进程</title>
                <description>&lt;pre&gt;&lt;code&gt;ps -e #查看进程列表
sudo kill &amp;lt;pid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/kill-processes-under-ubuntu/</link>
                <guid>http://hsfzxjy.github.io/ubuntu%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8b</guid>
                <pubDate>2015-03-02T19:17:55+08:00</pubDate>
        </item>

        <item>
                <title>【HFMUN重构系列】2. 用户系统</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;现在，我比任何时候都要有主见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是这次重构过程中我最想说的一句话了。&lt;/p&gt;
&lt;p&gt;毋庸置疑，Django是一个十分优秀的Web框架：高效的开发模式，完备的应用集成，以及最重要的一点——具有完全自由的扩展能力——这是Django的灵魂所在。但是无知，通常会束缚了一个人的探索欲望与创新能力，让其变得胆怯、变得懒惰。一年前我的遭遇就很好地印证了这一点。&lt;/p&gt;
&lt;p&gt;对于一个网站而言，用户永远是最重要的元素。没有了用户，网站做得再好也只能被放在角落腐烂，与死尸无异。这样看来，打造一个完美的用户系统就显得十分必要了。&lt;/p&gt;
&lt;p&gt;Django为我们提供了一个优秀的用户系统，它位于&lt;code&gt;django.contrib.auth&lt;/code&gt;——想必Djangoers都对它很熟悉了。&lt;code&gt;auth&lt;/code&gt;应用是专门为用户管理打造的一个应用，它提供了以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个用户模型（User）。这是&lt;code&gt;auth&lt;/code&gt;框架的核心所在，用于存储用户信息，包括 用户名、密码、邮箱等内容。该模型可被替换也可被拓展，具有良好的可塑性。&lt;/li&gt;
&lt;li&gt;一个权限系统（Permission）。这部分为实现访问控制提供了可能。一个&lt;code&gt;Permission&lt;/code&gt;对应一个关于&lt;code&gt;Model&lt;/code&gt;的操作，默认有&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;change&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;三种。值得一提的是，在版本&lt;code&gt;1.7&lt;/code&gt;之前，Django并不提供更改默认权限的能力，即每个&lt;code&gt;Model&lt;/code&gt;都会固定拥有以上三种权限。我个人觉得这种做法不太好，并不是所有的模型都需要这种功能划分。更何况权限限制被应用在Django的每一个角落，如果想让一个模型完全开放，就要多敲许多不必要的代码。如今Django1.7改进了这一点，这使得模型更加简洁了。&lt;/li&gt;
&lt;li&gt;用户分组的功能（Groups）。一个&lt;code&gt;Group&lt;/code&gt;可以拥有多个&lt;code&gt;Permission&lt;/code&gt;，一个用户可以选择加入一个&lt;code&gt;Group&lt;/code&gt;，并会自动拥有还&lt;code&gt;Group&lt;/code&gt;的权限。这一设计简化了用户管理的操作，同时也让用户系统的更有层次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，我想说的是关于扩展&lt;code&gt;User&lt;/code&gt;模型的一些技巧。&lt;/p&gt;
&lt;p&gt;一年之前，由于对Django的不了解，我不敢对它的内部实现大动干戈。而事实上，没有什么东西是绝对完美的，即便是集众智于一身的开源框架也是如此。诚然，&lt;code&gt;auth&lt;/code&gt;框架是不错，但在某些特定的应用场景，它便显得心有余而力不足了。因此，我希望能在&lt;code&gt;User&lt;/code&gt;模型上附带一些额外的信息。&lt;/p&gt;
&lt;p&gt;百度一下，我找到了一个被广为流传的方法：&lt;code&gt;Profile&lt;/code&gt;模式。也就是说，额外定义一个&lt;code&gt;Profile&lt;/code&gt;模型和&lt;code&gt;User&lt;/code&gt;模型建立一一对应的关系，用于储存额外信息。我清楚地记得，几乎是每一篇博客都在介绍这种方法，于是乎我毫不犹豫地就采纳了。现在想一想，这其实是一个十分糟糕的方案。它有如下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作麻烦。&lt;/strong&gt;每次访问额外信息，都要先询问是否存在&lt;code&gt;Profile&lt;/code&gt;对象，如果不存在得先创建。然后再调用&lt;code&gt;user_object.profile&lt;/code&gt;来访问信息。同时，这种方案对表单不友好，因为用户信息是被分开储存在两个表中的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率低下。&lt;/strong&gt;每次访问额外信息，先是用&lt;code&gt;IF EXISTS&lt;/code&gt;判断是否存在，再用&lt;code&gt;INNER JOIN&lt;/code&gt;将主信息和次信息从数据库中取出，一共需要两条SQL语句。更何况，&lt;code&gt;INNER JOIN&lt;/code&gt;指令是公认的效率低下的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在这次重构中我采用了一种截然不同的做法：直接重写&lt;code&gt;User&lt;/code&gt;模型。这里的灵感来自&lt;a href=&quot;https://docs.djangoproject.com/en/1.7/topics/auth/customizing/#auth-custom-user&quot;&gt;Django官方文档&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Some kinds of projects may have authentication requirements for which Django’s built-in User model is not always appropriate. For instance, on some sites it makes more sense to use an email address as your identification token instead of a username.&lt;/p&gt;
&lt;p&gt;Django allows you to override the default User model by providing a value for the AUTH_USER_MODEL setting that references a custom model:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; AUTH_USER_MODEL = 'myapp.MyUser'
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;听起来不错，既方便实现起来又简单。于是我重写了我的&lt;code&gt;accounts&lt;/code&gt;应用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#encoding=utf8
&quot;&quot;&quot;
    事实上这里许多实现都模仿自`django.contrib.auth.models.User`，毕竟我只是要存储一些额外信息而已。
&quot;&quot;&quot;
from django.core import validators
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from django.utils.translation import ugettext_lazy as _
from django.utils import timezone
from django.db import models

class UserManager(BaseUserManager):

    def _create_user(self, username, password,
                     is_staff, is_superuser, **extra_fields):
        &quot;&quot;&quot;
        Creates and saves a User with the given username, email and password.
        &quot;&quot;&quot;
        now = timezone.now()
        if not username:
            raise ValueError('The given username must be set')
        user = self.model(username=username,
                          is_staff=is_staff, is_active=True,
                          is_superuser=is_superuser, last_login=now,
                          date_joined=now, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, username, password=None, **extra_fields):
        return self._create_user(username, password, False, False,
                                 **extra_fields)

    def create_superuser(self, username, password, **extra_fields):
        return self._create_user(username, password, True, True,
                                 **extra_fields)

# 这里的`AbstractBaseUser`是用户模型的基类，由于原生的`User`模型中有一些字段并不是我想要的，因此我需要从上一个抽象类继承。
class User(AbstractBaseUser, PermissionsMixin):

    username = models.CharField(_('username'), max_length=30, unique=True,
        help_text=_('Required. 30 characters or fewer. Letters, digits and '
                    '@/./+/-/_ only.'),
        validators=[
            validators.RegexValidator(r'^[\w.@+-]+$', _('Enter a valid username.'), 'invalid')
        ])

    # 用户描述
    description = models.TextField()

    # 昵称
    nickname = models.CharField(_('nickname'),
        max_length=30, unique=True,
        help_text=_('Required. 30 characters or fewer.'),
        )

    # 好友关系
    friends = models.ManyToManyField(
        'self',
        verbose_name=_('friends'),
        blank=True,
        related_name='+'
        )

    #================以下是原有的字段==================
    is_staff = models.BooleanField(_('staff status'), default=False,
        help_text=_('Designates whether the user can log into this admin '
                    'site.'))
    is_active = models.BooleanField(_('active'), default=True,
        help_text=_('Designates whether this user should be treated as '
                    'active. Unselect this instead of deleteing accounts.'))
    date_joined = models.DateTimeField(_('date joined'), auto_now_add=True)

    USERNAME_FIELD = 'username'
    objects = UserManager()

    class Meta:
        verbose_name = _('user')
        verbose_name_plural = _('users')

    def get_full_name(self):
        return self.nickname

    def get_short_name(self):
        return self.nickname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及&lt;code&gt;settings.py&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#...
AUTH_USER_MODEL = 'accounts.User'
#...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了让admin框架同步支持我们的新&lt;code&gt;User&lt;/code&gt;模型，还需要对&lt;code&gt;admin.py&lt;/code&gt;以及&lt;code&gt;forms.py&lt;/code&gt;进行相应的修改，实际上就是把新加入的字段写进相应的类即可，在这里我就不贴代码了。&lt;/p&gt;
&lt;p&gt;做完这一切，一个念头忽然从我脑海中闪过：对于一些第三方应用，如果它们直接引用了&lt;code&gt;django.contrib.auth.models.User&lt;/code&gt;，那该怎么办呢？我的&lt;code&gt;User&lt;/code&gt;模型会生效吗？&lt;/p&gt;
&lt;p&gt;这让我感到不安，因为重构的一大原则便是：不得改变外部接口的调用情况。如果这一改动使得整个网站都崩溃了，那就得不偿失了。可庆幸的是，这样的事情并没有发生。&lt;/p&gt;
&lt;p&gt;这不禁让我感到好奇：django是怎么做到这一点的？&lt;/p&gt;
&lt;p&gt;翻看&lt;code&gt;django.contrib.auth.models&lt;/code&gt;，我发现了如下一句代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User(AbstractUser):
    &quot;&quot;&quot;
    Users within the Django authentication system are represented by this
    model.

    Username, password and email are required. Other fields are optional.
    &quot;&quot;&quot;
    class Meta(AbstractUser.Meta):
        swappable = 'AUTH_USER_MODEL'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查找&lt;a href=&quot;https://docs.djangoproject.com/en/1.8/ref/models/fields/#django.db.models.ForeignKey.swappable&quot;&gt;Django文档&lt;/a&gt;，原来这是Django1.7的一个新特性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ForeignKey.swappable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Controls the migration framework’s reaction if this ForeignKey is pointing at a swappable model. If it is True - the default - then if the ForeignKey is pointing at a model which matches the current value of settings.AUTH_USER_MODEL (or another swappable model setting) the relationship will be stored in the migration using a reference to the setting, not to the model directly.&lt;/p&gt;
&lt;p&gt;You only want to override this to be False if you are sure your model should always point towards the swapped-in model - for example, if it is a profile model designed specifically for your custom user model.&lt;/p&gt;
&lt;p&gt;Setting it to False does not mean you can reference a swappable model even if it is swapped out - False just means that the migrations made with this ForeignKey will always reference the exact model you specify (so it will fail hard if the user tries to run with a User model you don’t support, for example).&lt;/p&gt;
&lt;p&gt;If in doubt, leave it to its default of True.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个特性可以使指向这个模型的ForeignKey自动被替换成&lt;code&gt;Meta.swappable&lt;/code&gt;的内容，实现模型的可替换能力。这是一个巧妙的设计。&lt;/p&gt;
&lt;p&gt;重构后的&lt;code&gt;accounts&lt;/code&gt;应用，逻辑变得更加清晰，也使我不再纠结于冗长的恼人的&lt;code&gt;Profile&lt;/code&gt;调用。&lt;/p&gt;
&lt;p&gt;这，是一个美妙的起点。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/HFMUN-reconstruction-2/</link>
                <guid>http://hsfzxjy.github.io/%e3%80%90hfmun%e9%87%8d%e6%9e%84%e7%b3%bb%e5%88%97%e3%80%912-%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f</guid>
                <pubDate>2015-01-28T20:41:10+08:00</pubDate>
        </item>

        <item>
                <title>【HFMUN重构系列】1. Django1.7</title>
                <description>&lt;p&gt;有人说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“软件更新的速度永远也比不上客户使用的速度。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;的确，网络世界真是一个日新月异的地方，甚至作为开发者的我也能真切地感受到这一点。记得2013年初，Django最高的版本号才是1.5.5。一年之后，已经变成1.7了（事实上，应该是1.7.3，两个月的时间让我又落后了0.3个版本）。比起1.5.x，Django1.7多了如下的新特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Migrations，即实时同步数据库。在此之前，如果要对Model的表结构进行改动，要么自己用MySQL的&lt;code&gt;ALTER TABLE&lt;/code&gt;语句，要么就删除整个数据库再&lt;code&gt;syncdb&lt;/code&gt;（大家可能很惊讶，由于本人较懒，因此常常会做出这样“鲁莽”的操作，反正是在调试- -）。这给开发带来了不少的麻烦。尽管不少博客都说——在解读需求时期就要定好表结构。可对于我，这点实在是比较难办到，总会有一些考虑不周的地方。&lt;/li&gt;
&lt;li&gt;Custom lookups，即自定义查找规则。我们常常会用到QuerySet的查找语句&lt;code&gt;User.objects.filter(id__lt=2)&lt;/code&gt;等等。但如果要某一天我要实现自定义规则，如MySQL的全文搜索，又该怎么做呢？在1.7之前，Django并没有提供相应的接口，只能通过嵌入Raw SQL来实现。如今，1.7的这个特性让大家眼前一亮，同时也使数据库查找变得更加灵活。 &lt;/li&gt;
&lt;li&gt;App Configurations，即关于应用的自定义配置。就我个人看来，这里主要时方便了Admin的应用名显示。在1.7版本之前，我们无法设定应用在Admin中显示的名字，只能让那些格格不入的英文名显示在管理界面中——这也是我不让Admin投入实际应用的一个原因。如今，通过配置&lt;code&gt;AppConfig&lt;/code&gt;，我们可以轻易地实现这一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在HFMUN2.0中我用到的新特性大概就是这些，它们给应用开发带来了愉悦的体验。但可恶的是：&lt;strong&gt;SAE并不同步更新Django。&lt;/strong&gt;如今，那里的Django仍然停留在版本1.5。&lt;/p&gt;
&lt;p&gt;于是，我只能将新鲜出炉的Django1.7放在网站的目录下，一同传上SAE。&lt;/p&gt;
&lt;p&gt;起初，我是将Django打包成Zip文件发在&lt;code&gt;site_packages/&lt;/code&gt;目录下，因为我隐约记得Python是支持直接导入Zip文件的。但尝试了许多次，都说“找不到Django”。迫不得已，只好将Django解压出来再上传——这花费了我不少的时间（哦！中国的上传速度！）。&lt;/p&gt;
&lt;p&gt;接下来便是Django的配置了。先将&lt;code&gt;config.yaml&lt;/code&gt;修改成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: hfmun
version: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然我们已经不用SAE自带的Django了，就应该把依赖关系删除，以免导入其默认的Django。&lt;/p&gt;
&lt;p&gt;接着修改&lt;code&gt;index.wsgi&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#...
import sys
from site_packages import django 
sys.modules['django'] = django
#...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;index.wsgi&lt;/code&gt;是第一个被执行的文件，在此处把Django先导入可以保证之后每次使用的Django都是自己上传的那个版本。&lt;br /&gt;
至此，新版本Django就可以使用了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ps：据测试，这样配置的网站大约会比普通的网站慢几十毫秒，大概是自己的Django需要启动时间。不过比起新功能，这点损耗是微不足道的。&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/HFMUN-reconstruction-1/</link>
                <guid>http://hsfzxjy.github.io/%e3%80%90hfmun%e9%87%8d%e6%9e%84%e7%b3%bb%e5%88%97%e3%80%911-django1-7</guid>
                <pubDate>2015-01-27T20:49:06+08:00</pubDate>
        </item>

        <item>
                <title>【HFMUN重构系列】0. 前言</title>
                <description>&lt;p&gt;这是2014年初我接到的一个项目：给模拟联合国建立一个网站，实现文章发布以及在线聊天的功能，供在3月初的华附模联大会使用。&lt;/p&gt;
&lt;p&gt;这是我人生中做的第一个网站，也是在这时，我组建了第一支自己的开发团队——尽管，只有两个人；尽管，我们都才高一。至于他们是怎么找到我的，那一刻，我记得十分清楚——那是2013年12月的某天，一个晚自习的课间，阿三突然走进来大喊了一声：“我们班有谁会做网站的？”那时候的我，刚刚接触web编程。我记得，我毫不犹豫地就答应了。这一句回答，改变了我之后一年多的生活。其中，有收获，同时也失去了一些东西——但我不后悔。这一年多的生活，在别人看来我似乎是在固执地溯流行船，逆着大家公认的“好的方向”前进，可我觉得这一切都是值得的。一年来，我收获的不只是技术，还有团队协作能力、与客户交涉的能力、许多解决未知问题的方法，以及最重要的一点——快乐。现在回想起来：如果当初我没有选择这一条路，也许我会通过一些“传统”的努力获得一些“传统”的荣誉，甚至没有了高考的负担，这固然不错，但同时我也会失去上一句话中提到的那些东西——一些在书本中学不到的珍宝，这些都是要通过实践来感知。更何况——每个人都应该拥有属于自己的生活。&lt;/p&gt;
&lt;p&gt;我又想起了黄老师那句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“希望你不要随波逐流。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;言归正传。我先简单概括一下这个系统的情况。这是搭建在SinaAppEngine上的一个网站，使用Python+Django1.7+MySQL+Bootstrap3进行开发。去年的版本做的实在是有些匆忙，在投入使用前一天才草草收尾，没有经过QA测试就投入使用了——或者说我们请客户当了QA(T_T)。幸好客户比较温柔，不像传说中段子里提到的&lt;strong&gt;可怕的甲方&lt;/strong&gt;，或许是因为这是第一版，又或许是碍于同学情面。&lt;/p&gt;
&lt;p&gt;那次的前端做得实在是太挫了：每一个界面元素都是照搬Bootstrap的组件，Bootstrap没有的便用其中一种或几种组合（Panel搭建的超大评论框就这么诞生了...），我们自己只写了少得可怜的几行css——事实上就凭着当年那菜鸟级别的css水平，我们也不敢乱改。另外一个令我们头疼的是IE兼容性问题（EVIL！）——这还是一个用户发现的：bootstrap在IE8-下全乱了。我只得陪着笑乞求他们换用Chrome，别提有多尴尬了。&lt;/p&gt;
&lt;p&gt;问题还不止这些。2013年初，正是新浪云的Channel服务进行公测的时候。Channel服务是新浪云自主开发的一个提供客户端实时推送的服务，可应用于网络聊天室等实时性要求较高的网站中。有了这一技术，我才有能力搭建会议聊天系统。但这毕竟是Alpha版本，难免有些Bug。在调试时，光是和新浪客服交涉就花了我不少的时间。可在实际应用时它还是出了一些毛病，甚至在会议最后半天时它干脆直接无法使用了（π.π）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;凡事都是要走出第一步的，无论是成功或是失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时光荏苒，转眼间一年又过去了。从14年12月开始我又重新启动了这一项目。比起上一次，尽管上次的网站做基础，尽管我有了更多的时间，可用户的需求也更加苛刻了。截至目前，1月27日，重构已经几乎完成了。在这里，我将记下这两个月的重构工程中发生的点点滴滴。&lt;/p&gt;
&lt;p&gt;附：&lt;a href=&quot;http://hfmun.sinaapp.com/&quot;&gt;华附模拟联合国官网&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/HFMUN-reconstruction-0/</link>
                <guid>http://hsfzxjy.github.io/%e3%80%90hfmun%e9%87%8d%e6%9e%84%e7%b3%bb%e5%88%97%e3%80%910-%e5%89%8d%e8%a8%80</guid>
                <pubDate>2015-01-27T20:02:41+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu安装Sublime 2</title>
                <description>&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:webupd8team/sublime-text-2

sudo apt-get update

sudo apt-get install sublime-text-2
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/sublime-text-2-installation-under-ubuntu/</link>
                <guid>http://hsfzxjy.github.io/ubuntu%e5%ae%89%e8%a3%85sublime-2</guid>
                <pubDate>2014-12-29T19:31:02+08:00</pubDate>
        </item>

        <item>
                <title>拉格朗日乘数法</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;今天在听&lt;strong&gt;张心捷同学&lt;/strong&gt;讲题的时候，得知了一个很厉害的&lt;strong&gt;在限制条件下求多远函数极值的办法&lt;/strong&gt;——&lt;strong&gt;拉格朗日乘数法&lt;/strong&gt;。在这里记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;引题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;已知：$a,b,c&gt;0$，$a+b+c=1$。证明：$\sum_{cyc}(1-a^2)^2\geq 2$。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;拉格朗日乘数法的表述&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于多值函数$y=f(x_1,x_2,\ldots ,x_n)$以及约束条件$\phi(x_1,x_2,\ldots,x_n)=0$，若待定一个系数$\lambda$，则由方程组：&lt;br /&gt;
$$\frac{\partial f}{\partial x_1}+\lambda\cdot{\partial \phi \over \partial x_1}=0,$$&lt;br /&gt;
$$\frac{\partial f}{\partial x_2}+\lambda\cdot{\partial \phi \over \partial x_2}=0,$$&lt;br /&gt;
$$\ldots$$&lt;br /&gt;
$$\frac{\partial f}{\partial x_n}+\lambda\cdot{\partial \phi \over \partial x_n}=0,$$&lt;br /&gt;
$$\phi(x_1,x_2,\ldots,x_n)=0$$&lt;br /&gt;
可得一系列的解。这些解即为$y=f(x_1,x_2,\ldots ,x_n)$在约束条件$\phi(x_1,x_2,\ldots,x_n)=0$下可能的极值点。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;由拉格朗日乘数法，我们可解得：$(a,b,c)=(1,0,0),(0,1,0),(0,0,1)$。这是一些可能的极值点，在这些点上$f$都等于2。&lt;br /&gt;
当然，我们还要考虑边界情况：即$a,b,c$有一个为1或0。在这些情况下我们使用拉格朗日乘数法依旧可得上面的结论。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/lagrange-multiplier-method/</link>
                <guid>http://hsfzxjy.github.io/%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e4%b9%98%e6%95%b0%e6%b3%95</guid>
                <pubDate>2014-12-27T16:55:52+08:00</pubDate>
        </item>

        <item>
                <title>【转】十问国人</title>
                <description>&lt;p&gt;&lt;a href=&quot;http://i.ifeng.com/news/zhuanti/mainland/njdtsgj/zx/news?aid=93362281&amp;amp;stt=cpz_newsnext&amp;amp;mid=5UBkCb&amp;amp;all=1&amp;amp;p=1&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/reprinted-shiwenguoren/</link>
                <guid>http://hsfzxjy.github.io/%e3%80%90%e8%bd%ac%e3%80%91%e5%8d%81%e9%97%ae%e5%9b%bd%e4%ba%ba</guid>
                <pubDate>2014-12-14T18:38:49+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu加入自己的字体</title>
                <description>&lt;p&gt;假设字体文件夹为：&lt;code&gt;～/Fonts&lt;/code&gt;。执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mkdir -p /usr/share/fonts/myFonts
sudo cp ~/Fonts/*.ttf /usr/share/fonts/myFonts/
sudo chmod 644 /usr/share/fonts/myFonts/*.ttf
cd /usr/share/fonts/winFonts/
sudo mkfontscale （创建雅黑字体的fonts.scale文件，它用来控制字体旋转缩放）
sudo mkfontdir （创建雅黑字体的fonts.dir文件，它用来控制字体粗斜体产生）
sudo fc-cache -fv （建立字体缓存信息，也就是让系统认识雅黑）
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/add-custom-fonts-under-ubuntu/</link>
                <guid>http://hsfzxjy.github.io/ubuntu%e5%8a%a0%e5%85%a5%e8%87%aa%e5%b7%b1%e7%9a%84%e5%ad%97%e4%bd%93</guid>
                <pubDate>2014-12-13T15:50:34+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu下删除不完整的包</title>
                <description>&lt;p&gt;答案来自&lt;a href=&quot;http://stackoverflow.com/questions/27455626/how-to-remove-an-incomplete-package-by-using-apt-get&quot;&gt;StackOverflow&lt;/a&gt;: &lt;code&gt;sudo dpkg --remove --force-remove-reinstreq &amp;lt;your package name&amp;gt;&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/remove-broken-packages-under-ubuntu/</link>
                <guid>http://hsfzxjy.github.io/ubuntu%e4%b8%8b%e5%88%a0%e9%99%a4%e4%b8%8d%e5%ae%8c%e6%95%b4%e7%9a%84%e5%8c%85</guid>
                <pubDate>2014-12-13T13:41:10+08:00</pubDate>
        </item>

        <item>
                <title>化学 【第二章-第一节】归纳</title>
                <description>&lt;h3&gt;&lt;strong&gt;电解质&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;strong&gt;电解质是溶于水溶液中或在熔融状态下就能够导电（自身电离成阳离子与阴离子）的化合物&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;分类：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;强电解质：&lt;strong&gt;在水溶液中或熔融状态中几乎完全发生电离的电解质&lt;/strong&gt;。一般有：强酸强碱，活泼金属氧化物，大多数的盐。&lt;/li&gt;
&lt;li&gt;弱电解质：&lt;strong&gt;在水溶液中或熔融状态下不完全发生电离的电解质&lt;/strong&gt;。一般有：弱酸弱碱，少数的盐，水。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;同系物&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;strong&gt;结构相似、分子组成相差若干个“CH2”原子团的有机化合物互相称为同系物。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一般来说，同系物的名字都有相同的结尾，如：烷、醇等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;分散系&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;strong&gt;一种或几种物质分散在另一种（或多种）物质中所形成的体系称为分散体系。&lt;/strong&gt;分散系的分类由&lt;strong&gt;分散质的直径大小&lt;/strong&gt;决定。&lt;/li&gt;
&lt;li&gt;具体分类：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;溶液，无丁达尔效应。&lt;/li&gt;
&lt;li&gt;胶体，由丁达尔效应，通常也是透明的。&lt;/li&gt;
&lt;li&gt;浊液，又分为悬浊液（固体小颗粒）和乳浊液（小液滴，不可用过滤分离）。透光的可以有丁达尔效应。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;酸性氧化物&amp;amp;碱性氧化物&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;酸性氧化物：&lt;strong&gt;能与水作用生成相应价态的酸，或与碱作用生成盐和水（且生成物只能有一种盐和水，不可以有任何其它物质生成），或与碱性氧化物反应生成盐的氧化物&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;碱性氧化物：&lt;strong&gt;能跟酸起反应，生成一种盐和水的氧化物叫碱性氧化物(且生成物只能有盐和水,不可以有任何其它物质生成)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;酸性氧化物不一定是非金属氧化物（如$Mn_2O_7$），而碱性氧化物一定为金属氧化物。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;离子化合物&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;由阳离子（通常为金属离子和铵根离子）和阴离子构成的化合物。&lt;/strong&gt;注意 &lt;em&gt;HCl不是，它是共价化合物&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://hsfzxjy.github.io/chemistry-chapter2-section1/</link>
                <guid>http://hsfzxjy.github.io/%e5%8c%96%e5%ad%a6-%e3%80%90%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e7%ac%ac%e4%b8%80%e8%8a%82%e3%80%91%e5%bd%92%e7%ba%b3</guid>
                <pubDate>2014-12-01T20:58:40+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu下解决apt-get “Hash校验和不符的方案”</title>
                <description>&lt;p&gt;各种坑爹，我也不知道为什么：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo gedit etc/apt/apt.conf.d/00aptitude
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后加一行：&lt;code&gt;Acquire::CompressionTypes::Order &quot;gz&quot;;&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/solution-of-apt-get-error-hash-checksum-incorrect/</link>
                <guid>http://hsfzxjy.github.io/ubuntu%e4%b8%8b%e8%a7%a3%e5%86%b3apt-get-hash%e6%a0%a1%e9%aa%8c%e5%92%8c%e4%b8%8d%e7%ac%a6%e7%9a%84%e6%96%b9%e6%a1%88</guid>
                <pubDate>2014-11-29T18:26:18+08:00</pubDate>
        </item>

        <item>
                <title>在Ubuntu下更改MYSQL的字符集</title>
                <description>&lt;p&gt;修改&lt;code&gt;/etc/mysql/my.cnf&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[client]
default-character-set=utf8

[mysqld]
character_set_server=utf8

[mysql]
default-character-set=utf8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后：&lt;code&gt;sudo service mysql restart&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/alter-mysql-character-set-under-ubuntu/</link>
                <guid>http://hsfzxjy.github.io/%e5%9c%a8ubuntu%e4%b8%8b%e6%9b%b4%e6%94%b9mysql%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86</guid>
                <pubDate>2014-11-28T21:49:30+08:00</pubDate>
        </item>

        <item>
                <title>【转载】北大金秋营题目</title>
                <description>&lt;p&gt;&lt;img src=&quot;/assets/b32914dfa9ec8a13aa6514b5f403918fa0ecc06a.jpg&quot; alt=&quot;enter image description here&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/b663d5160924ab18e8f4a16236fae6cd7a890b8e.jpg&quot; alt=&quot;enter image description here&quot; /&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/2014-PKU-JinQiu/</link>
                <guid>http://hsfzxjy.github.io/%e3%80%90%e8%bd%ac%e8%bd%bd%e3%80%91%e5%8c%97%e5%a4%a7%e9%87%91%e7%a7%8b%e8%90%a5%e9%a2%98%e7%9b%ae</guid>
                <pubDate>2014-11-17T21:47:39+08:00</pubDate>
        </item>

        <item>
                <title>NOIP2014总结</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;现在算起来，至少有&lt;strong&gt;220分&lt;/strong&gt;是不应该丢的——已经接近我的得分了，都是由各种脑残的错误引起的。总之，经历了这一切，我都早已习惯了。过去的事只能让它过去了，重要的是：经历了这一切，我总要明白一些什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;生活大爆炸版剪刀石头布&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=1328&quot;&gt;Link&lt;/a&gt;  得分：&lt;strong&gt;100&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题是真正的大水题，当然也是我唯一一道满分的题（欲哭无泪）。不说了，模拟就是了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;联合权值&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=1351&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;40&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题不难，关键是要将无根树转化成为有根树，做一次DFS。事实上，两个距离为2的节点，要么一个是另一个的祖父节点，要么两个节点是兄弟关系。一方面，我们在DFS时先求当前节点与祖父节点产生的联合权值（如果有的话）；另一方面，遍历当前节点的子节点。对于一个子节点：只需将其的权值乘以已遍历过的节点中权值最大者即得最大权值，而只需将当前权值乘以已遍历的节点权值之和即可得到总联合权值。因此，该算法的时间复杂度为$O(n)$。&lt;br /&gt;
但关键之处往往就在细节的地方：我自作多情地以为求出的最大联合权值也要模10007，而事实上只需将综合取模即可。在这里丢了&lt;strong&gt;60分&lt;/strong&gt;，真是不应该。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;飞扬的小鸟&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=1941&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;0&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题我能够想到的办法就是爆搜，但因为做一个优化的时候开了10000*10000的longint数组导致MLE。现在算来，如果去掉那个该死的0，我可以拿到60分。同时，求正解。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;无线电网络发射选址&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=2038&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;70&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题按理说应该是最不应该错的一道题了，但也只拿了70分。为此我还花了接近半个小时进行查错。结果发现，还是语文水平不过关——我自作主张地将题目脑补成&lt;strong&gt;“WIFI覆盖范围不得超出街道范围”&lt;/strong&gt;。这导致了有一些边缘区域成了死角。在这里我丢了&lt;strong&gt;30分&lt;/strong&gt;。下次一定要认真看题。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;道路寻找&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=2296&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;30&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题从一开始思路就是错误的：我先做了一遍DFS判断哪些点是可以经过的。而事实上：由于图中有环的存在，很多判断将具有后效性，从而导致错误。这一点我在距离考试结束还有半个小时的时候就发现了，但一直没有想到怎么更改，只能祈祷这样的数据点不要太多。&lt;br /&gt;
这是从别人那里听得的一个解法，花了10分钟来实现并且AC了，挺巧妙的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;先将所有读进来的边反向存储，并删掉所有的自环。这样起点和中点就互换了位置。这是这个算法的核心。&lt;/li&gt;
&lt;li&gt;做一次DFS，将已走过的点做标记，在遍历子节点的时候，对于每个搜到的子节点都将其cnt加一。这样一来我们可以知道起点是否能走到终点；二来如果某个节点的cnt值等于其入度，则这个节点就可以通过。&lt;/li&gt;
&lt;li&gt;做一次SPFA，这就很简单了，只对可以经过的节点做松弛。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一种逆向思维。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;解方程&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=2312&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;30&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题我能想到的方法只是直接做高精度，外加数论定理优化。听说可以用求导的办法求得单调区间，然后进行二分查找。个人感觉较为复杂，日后再研究一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;细节决定成败。如果做题时细心一点，而不是过于匆忙，或许，结果就不会这样了。&lt;br /&gt;
  而事实上在这次考试中，心态也很重要。高联的失利使我渐渐变得急功近利起来。没有了高一的淡然，没有了年少时的沉稳，一切都浮躁了起来。&lt;br /&gt;
  这一切，终于结束了。但，未来，未来究竟要怎么样呢？   —— 后记&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <link>http://hsfzxjy.github.io/conclusion-of-noip2014/</link>
                <guid>http://hsfzxjy.github.io/noip2014%e6%80%bb%e7%bb%93</guid>
                <pubDate>2014-11-17T20:22:38+08:00</pubDate>
        </item>

        <item>
                <title>LCA之离线Tarjan算法</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;真是巧妙的算法！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比起树上倍增，Tarjan算法实现起来更为简单，一个DFS加并查集即可。缺点便是：&lt;strong&gt;需要先把所有的查询都读进来，并且要储存结果&lt;/strong&gt;。复杂度为O(n+q)。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    sets: array [1..100] of longint;
    visited: array [1..100] of Boolean;
    a: array [1..100, 1..100] of Boolean;
    questions: array [1..1000] of record
        x, y: longint;
        ans: longint;
    end;
    qn, n, i, m, x, y, root: longint;

function find(x: longint): longint;
begin
    if x = sets[x] then exit(x);
    sets[x] := find(sets[x]);
    exit(sets[x]);
end;

procedure dfs(x: longint);
var
    i: longint;
begin
    visited[x] := true;
    //对于两个节点都已访问到的询问，其结果已经出来了
    for i := 1 to qn do
    begin
        if visited[questions[i].x] and visited[questions[i].y] then
            if questions[i].x = x then
                questions[i].ans := find(questions[i].y)
            else if questions[i].y = x then
                questions[i].ans := find(questions[i].x);
    end;
    for i := 1 to n do
    begin
        if not a[i, x] or visited[i] then continue;
        dfs(i);
        sets[find(i)] := x;
    end;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    read(n, m);
    for i := 1 to n do
        sets[i] := i;
    for i := 1 to m do
    begin
        read(x, y);
        a[x, y] := true;
        a[y, x] := True;
    end;
    read(root);
    qn := 0;
    while not eof do
    begin
        inc(qn);
        read(questions[qn].x, questions[qn].y);
    end;
    dfs(root);
    for i := 1 to qn do
        writeln(questions[i].ans);

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/lca-Tarjan/</link>
                <guid>http://hsfzxjy.github.io/lca%e4%b9%8b%e7%a6%bb%e7%ba%bftarjan%e7%ae%97%e6%b3%95</guid>
                <pubDate>2014-11-02T17:05:45+08:00</pubDate>
        </item>

        <item>
                <title>LCA树上倍增</title>
                <description>&lt;pre&gt;&lt;code&gt;var
    a: array [1..100, 1..100] of boolean;
    depth: array [1..100] of longint;
    father: array [1..100, 0..16] of longint;
    n, m, i, x, y: longint;
    root: longint;

procedure dfs(x: longint);
var
    i: longint;
    j: longint;
begin
    depth[x] := depth[father[x][0]]+1;
    j := 1;
    while 1&amp;lt;&amp;lt;j&amp;lt;=depth[x]-1 do
    begin
        father[x][j] := father[father[x][j-1]][j-1];
        inc(j);
    end;
    for i := 1 to n do
    begin
        if not a[x][i] or (father[x][0] = i) then continue;
        father[i][0] := x;
        dfs(i);
    end;
end;

procedure swap(var x, y: longint);
var
    t: longint;
begin
    t := x;
    x := y;
    y := t;
end;

function lca(x, y: longint): longint;
var
    t, j: longint;
begin
    if depth[x] &amp;lt; depth[y] then
        swap(x, y);

    t := depth[x] - depth[y];
    for j := 0 to 15 do
        if t and (1&amp;lt;&amp;lt;j) &amp;lt;&amp;gt; 0 then
            x := father[x][j];
    if x = y then
        exit(x);
    for j := 15 downto 0 do
        if father[x][j] &amp;lt;&amp;gt; father[y][j] then
        begin
            x := father[x][j];
            y := father[y][j];
        end;
    lca := father[x][0];
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    read(n, m);
    for i := 1 to m do
    begin
        read(x, y);
        a[x, y] := true;
        a[y, x] := true;
    end;
    read(root);
    father[root][0] := root;
    dfs(root);
    while not eof do
    begin
        read(x, y);
        writeln(lca(x, y));
    end;


    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/lca-tree-multiplier/</link>
                <guid>http://hsfzxjy.github.io/lca%e6%a0%91%e4%b8%8a%e5%80%8d%e5%a2%9e</guid>
                <pubDate>2014-11-02T16:23:13+08:00</pubDate>
        </item>

        <item>
                <title>RMQ（二进制方法）</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;问题描述：已知数组a以及若干个查询(x, y)，求a[x~y]之间的最小值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;不难发现：若取t使得$2^t\leq y-x+1$且$2^{t+1}&gt;y-x+1$，则有：&lt;br /&gt;
$$[x, x+t]\bigcup[y-t+1,y]=[x,y]$$&lt;br /&gt;
运用二进制的思想，我们只需预处理出$i~i+2^k-1$之间的最小值，即可快速完成查询。设dp[i][j]为$i~i+2^j-1$之间的最小值，则有：&lt;br /&gt;
$$dp[i][j]=min(dp[i][j-1],dp[i+2^{j-1}][j-1])$$。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    a: array [1..100000] of longint;
    dp: array [1..100000, 0..20] of longint;
    n, i: longint;

function min(x, y: longint): longint;
begin
    if x &amp;lt; y then exit(x) else exit(y);
end;

procedure init;
var
    i, j: longint;
begin
    for i := 1 to n do dp[i, 0] := a[i];
    j := 1;
    while 1&amp;lt;&amp;lt;j-1&amp;lt;=n do
    begin
        for i := 1 to n-1&amp;lt;&amp;lt;(j-1) do
            dp[i, j] := min(dp[i, j-1], dp[i+1&amp;lt;&amp;lt;(j-1), j-1]);
        inc(j);
    end;
end;

function query(x, y: longint): longint;
var
    t: longint;
begin
    t := 0;
    while (1&amp;lt;&amp;lt;(t+1)&amp;lt;=y-x+1) do inc(t);
    query := min(dp[x][t], dp[y-(1&amp;lt;&amp;lt;t)+1][t]);
end;

var
    x, y: longint;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(n);
    for i := 1 to n do read(a[i]);
    init;
    while not eof do
    begin
        read(x, y);
        writeln(query(X, y));
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/RMQ-binary/</link>
                <guid>http://hsfzxjy.github.io/rmq%ef%bc%88%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%b9%e6%b3%95%ef%bc%89</guid>
                <pubDate>2014-11-02T15:07:05+08:00</pubDate>
        </item>

        <item>
                <title>树状数组</title>
                <description>&lt;h2&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;所谓树状数组，就是将线性的数组预处理成树状的结构以降低时间复杂度。先来看一幅经典的图： &lt;img src=&quot;/assets/TArry1.jpg&quot; alt=&quot;enter image description here&quot; /&gt;&lt;br /&gt;
其中的a数组为原生数组，c数组为辅助数组，计算方式为： $$c_1=a_1——{(1)}&amp;#95;{10}={(1)}&amp;#95;2$$ $$c_2=a_2+c_1——{(2)}&amp;#95;{10}={(10)}&amp;#95;2$$ $$\ldots$$              不难发现，c[k]存储的实际上是从k开始向前数k的二进制表示中右边第一个1所代表的数字个元素的和。这样写的好处便是可以利用位运算轻松计算sum。上代码。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    n, i: longint;
    a, c: array [1..10000] of longint;

//计算x最右边的1所代表的数字。
//如：lowbit(0b1100)=0b100
function lowbit(x: longint): longint; 
begin
    lowbit := x and (-x);
end;

//给a[index]加上x
procedure add(index, x: longint);
begin
    inc(a[index], x);
    while index&amp;lt;=n do 
    begin
        inc(c[index], x);
        inc(index, lowbit(index));
    end;
end;

//求a[1~index]的和
function sum(index: longint): longint;
begin
    sum := 0;
    while index&amp;gt;0 do
    begin
        inc(sum, c[index]);
        dec(index, lowbit(index));
    end;
end;

var
    s: longint;
    op: longint;
    x,y: longint;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(n);
    for i := 1 to n do
    begin
        read(a[i]);
        add(i, a[i]);
    end;

    while not eof do
    begin
        read(op);
        if op = 1 then //添加操作
        begin
           read(x, y);
           Add(x, y); 
        end
        else           //求和操作
        begin
            read(s);
            writeln(sum(s));
        end;
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/tree-array/</link>
                <guid>http://hsfzxjy.github.io/%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84</guid>
                <pubDate>2014-11-02T00:31:54+08:00</pubDate>
        </item>

        <item>
                <title>二进制的启示</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;在学习数论时我们都知道：只用2的幂次可以组合出所有的正整数。这便是二进制的魅力——状态简单而又变化万千。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;实际算法中，常常有一些线性的但数据量特别大的问题，如区间求和、求最小值等。很多时候，为了把时间复杂度从$O(n^2)$甚至更高的地方降下来，我们需要对数据进行一些预处理，以提高计算的速度。在这其中，有很大一部分是来自二进制运算特点的启发。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/archives/307&quot;&gt;树状数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/archives/318&quot;&gt;RMQ&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/archives/324&quot;&gt;LCA&amp;amp;树上倍增&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://hsfzxjy.github.io/revelation-of-binary/</link>
                <guid>http://hsfzxjy.github.io/%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%9a%84%e5%90%af%e7%a4%ba</guid>
                <pubDate>2014-11-01T23:43:19+08:00</pubDate>
        </item>

        <item>
                <title>最小生成树（Kruscal & Prim）</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;测试位置：&lt;a href=&quot;http://codevs.cn/problem/1078/&quot;&gt;WikiOI1078&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;type
    TEdge = record
        start, terminal: longint;
        weight: int64;
    end;
    TEdgeArr = array of TEdge;

operator &amp;lt;(e1, e2: TEdge)res: boolean;
begin
    res := e1.weight &amp;lt; e2.weight;
end;

operator &amp;gt;(e1, e2: TEdge)res: Boolean;
begin
    res := e1.weight &amp;gt; e2.weight;
end;

procedure SortEdge(A: TEdgeArr; l, r: longint);
var
    i, j: longint;
    t, m: TEdge;
begin
    i := l; j := r; m := A[(i+j) &amp;gt;&amp;gt; 1];
    repeat
        while A[i]&amp;lt;m do inc(i);
        while A[j]&amp;gt;m do dec(j);
        if i&amp;lt;=j then
        begin
            t := A[i];
            A[i] := A[j];
            A[j] := t;
            inc(i); dec(j);
        end;
    until i&amp;gt;j;
    if i&amp;lt;r then SortEdge(A, i, r);
    if l&amp;lt;j then SortEdge(A, l, j);
end;

const
    INF: int64 = 1&amp;lt;&amp;lt;60 div 3;
var
    map: array [1..100, 1..100] of int64;
    n, i, j: longint;

{
    @param x: 起始搜索节点
    算法思想：用一个数组维护从各个未加入顶点到
    树的最短边长度，操作n次，每次将距离最短的
    边加入到树中，并更新与之相邻的点的距离值。
}

function prim(x: longint): int64;
{
    lowest: 储存各个节点到树的最短距离
    visited: 标记是否已加入树中
}
var
    lowest: array [1..100] of int64;
    visited: array [1..100] of boolean;
    min: int64;
    i, j, minindex: longint;
begin
    fillchar(visited, sizeof(visited), 0);
    visited[x] := true;

    //先将初始节点加入树中，更新lowest
    for i := 1 to n do
        lowest[i] := map[i, x];

    prim := 0;
    for i := 2 to n do
    begin
        min := INF;

        //找出树到外部节点最短的一条边
        //并将该边加入树中
        for j := 1 to n do
            if (not visited[j]) and (min &amp;gt; lowest[j]) then
            begin
                min := lowest[j];
                minindex := j;
            end;
        visited[minindex] := true;
        prim := prim + min;

        //对新加入的那个节点，
        //更新与其相邻的未加入树的节点的lowest值
        for j := 1 to n do
        begin
            if visited[j] then continue;
            if map[j, minindex] &amp;lt; lowest[j] then
                lowest[j] := map[j, minindex];
        end;
    end;
end;

{
    算法思想：
    1. 先将边按照长度排序。
    2. 遍历所有的边，若该边的两个顶点都在树中则跳过；
    否则将其加入树中。
}

function Kruscal: int64;
var
    Edges: TEdgeArr; 
    //并查集，储存自己的父亲，若自己为根结点则为自己
    //这是一种常用的写法：否则如果存成0的话，想把两棵
    //树并在一起需要多一步判断。
    UnionSet: array [0..100] of longint; 
    i: longint;

    procedure InitEdges; //将邻接矩阵转化为边数组。
    var
        i, j: longint;
        E: TEdge;
    begin
        for i := 1 to n do
            for j := 1 to i-1 do
            begin
                E.start := i;
                E.terminal := j;
                E.weight := map[i, j];
                SetLength(Edges, Length(Edges)+1);
                Edges[High(Edges)] := E;
            end;
        SortEdge(Edges, Low(Edges), High(Edges));
    end;

    //寻找自己的根节点，并把自己直接连到根结点上。
    function Find(x: longint): longint;
    var
        root: longint;
    begin
        root := x;
        while root &amp;lt;&amp;gt; UnionSet[root] do 
            root := UnionSet[root];
        UnionSet[x] := root;
        exit(root);
    end;

    //尝试将边的两个顶点并在一个并查集中，如果两个
    //顶点都在同一个集合中则返回False，否则执行合
    //并操作。
    function Union(x, y: longint): boolean;
    var
        px, py: longint;
    begin
        px := Find(x);
        py := Find(y);
        if px = py then
            exit(False);
        UnionSet[px] := py;
        exit(True);
    end;

begin
    Kruscal := 0;
    fillchar(UnionSet, sizeof(UnionSet), 0);
    InitEdges;
    for i := 1 to n do
        UnionSet[i] := i;
    for i := Low(Edges) to High(Edges) do
        if Union(Edges[i].start, Edges[i].terminal) then
        begin
            Kruscal := Kruscal + Edges[i].weight;
        end;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(n);
    for i := 1 to n do
        for j := 1 to n do
            read(map[i, j]);
    writeln(Kruscal);

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/kruscal-and-prim/</link>
                <guid>http://hsfzxjy.github.io/%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91%ef%bc%88kruscal-prim%ef%bc%89</guid>
                <pubDate>2014-10-26T16:47:51+08:00</pubDate>
        </item>

        <item>
                <title>NOIP2013 Day1 火柴排队：快速求逆序对</title>
                <description>&lt;h2&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;涵涵有两盒火柴，每盒装有 n 根火柴，每根火柴都有一个高度。现在将每盒中的火柴各自排成一列，同一列火柴的高度互不相同，两列火柴之间的距离定义为：$\sum_{i=1}^{n}{(a_i-b_i)^2}$&lt;br /&gt;
  ，其中 ai表示第一列火柴中第 i 个火柴的高度，bi表示第二列火柴中第 i 个火柴的高度。&lt;br /&gt;
  每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 99,999,997 取模的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;这真是一道好题——断断续续想了几天才完全AC。&lt;br /&gt;
事实上，由排序不等式可知：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;当$a_i, b_i$从小到大排序时，距离最小。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个重要的信息。因此，我们只需把$a_i,b_i$进行排序，并把对应项“捆绑”成一项，再按$a_i$原有的顺序进行复原，此时，可以得到由%b_i$原先的下标组成的一个序列。也就是说，我们要求$1,2,\ldots,n$至少经过多少步才能变为该序列。这可以用逆序对来解决。&lt;br /&gt;
只可惜，传统的逆序对算法时间复杂度为$O(n^2)$，这里n可达20,0000，一定会超时（&lt;strong&gt;事实上，只过了70%的点&lt;/strong&gt;）。因此我们需寻求更好的算法。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;用归并排序求逆序对&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在归并排序的过程中，有一个步骤称为合并。在这个步骤中，需要轮流判断左右区间的第一个数的大小关系。注意到：&lt;strong&gt;左右区间已经有序，从而若左区间的第一个数大于右区间的第一个数，则左区间之后的所有数都大于右区间的第一个数&lt;/strong&gt;，从而我们可以在合并时做一些修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;procedure nx(l, r: longint);
var
    mid, i, j, k: longint;
begin
    if l = r then
    begin
        tmp[l] := a[l];
        exit;
    end;
    mid := (l + r) shr 1;
    nx(l, mid);
    nx(mid+1, r);
    i := l;
    j := mid+1;
    k := l;
    while k &amp;lt;= r do 
    begin
        if (j&amp;gt;r) or (i&amp;lt;=mid) and (a[i]&amp;lt;=a[j]) then //注意这里为等号
        begin
            tmp[k] := a[i];
            inc(i);
        end
        else
        begin
            cnt := cnt + mid - i + 1; //加上逆序数
            tmp[k] := a[j];
            inc(j);
        end;
        inc(k);
    end;
    for i := l to r do 
        a[i] := tmp[i];
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个算法复杂度为$O(nlogn)$，是一种比较理想的算法，实现起来也简单。但他有个缺点：&lt;strong&gt;会打乱原数组顺序&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;原题代码&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//AC
const
    MODN = 99999997;
type
    rec = record value, index: longint; end;
    TArr = array [1..100000] of rec;
var
    n: longint;
    a, b, c, tmp: TArr;
    ok: Boolean;
    l, r, i, j: longint;
    cnt: int64;

procedure sort(var arr: TArr; l, r: longint);
var
    i, j: longint;
    m, t: rec;
begin
    i := l;
    j := r;
    m := arr[(i+j) shr 1];
    repeat
        while arr[i].value &amp;lt; m.value do inc(i);
        while arr[j].value &amp;gt; m.value do dec(j);
        if i &amp;lt;= j then
        begin
            t := arr[i];
            arr[i] := arr[j];
            arr[j] := t;
            inc(i);
            dec(j);
        end;
    until i &amp;gt;j;
    if i &amp;lt; r then sort(arr, i, r);
    if l &amp;lt; j then sort(arr, l, j);
end;

procedure nx(l, r: longint);
var
    mid, i, j, k: longint;
begin
    if l = r then
    begin
        tmp[l] := c[l];
        exit;
    end;
    mid := (l + r) shr 1;
    nx(l, mid);
    nx(mid+1, r);
    i := l;
    j := mid+1;
    k := l;
    while k &amp;lt;= r do 
    begin
        if (j&amp;gt;r) or (i&amp;lt;=mid) and (c[i].index&amp;lt;=c[j].index) then
        begin
            tmp[k] := c[i];
            inc(i);
        end
        else
        begin
            cnt := cnt + mid - i + 1;
            cnt := cnt mod MODN;
            tmp[k] := c[j];
            inc(j);
        end;
        inc(k);
    end;
    for i := l to r do 
        c[i] := tmp[i];
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(n);
    for i := 1 to n do
    begin
        read(a[i].value);
        a[i].index := i;
    end;
    for i := 1 to n do
    begin
        read(b[i].value);
        b[i].index := i;
    end;
    sort(a, 1, n);
    sort(b, 1, n);

    for i := 1 to n do
        c[a[i].index] := b[i];

    cnt := 0;
    nx(1, n);
    writeln(cnt);

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/noip2013-day1-matches/</link>
                <guid>http://hsfzxjy.github.io/noip2013-day1-%e7%81%ab%e6%9f%b4%e6%8e%92%e9%98%9f%ef%bc%9a%e5%bf%ab%e9%80%9f%e6%b1%82%e9%80%86%e5%ba%8f%e5%af%b9</guid>
                <pubDate>2014-10-26T11:42:23+08:00</pubDate>
        </item>

        <item>
                <title>NOIP2011 Day2 计算系数：快速求组合数</title>
                <description>&lt;h2&gt;&lt;strong&gt;题目大意&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入a, b, k, n, m，计算$a^n\times b^m\times C_k^n$模10007的余数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于幂数的计算并不难，关键在于对组合数$C_n^k$的计算。&lt;br /&gt;
通常来说，组合数的计算一般是这样的：$$C_n^k=\frac{n}{k}\times\frac{n-1}{k-1}\times\ldots\times\frac{n-k+1}{1}$$ 这对于单精度的计算来说是十分快捷的，但如果要对结果取模的话就不起作用了——&lt;strong&gt;取模运算对于除法不成立&lt;/strong&gt;。因此只能另辟蹊径了。&lt;br /&gt;
注意到&lt;strong&gt;加减乘法对于取模都是成立的&lt;/strong&gt;，从而想到：能否将组合数转化成加法？&lt;br /&gt;
自然而然，想到了组合恒等式：$$C_n^k=C_{n-1}^{k}+C_{n-1}^{k-1}$$ 思路到此完成。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const
    modn = 10007;
var
    a, b, k, m, n: longint;
    map: array[0..1000,0..1000] of int64; //缓存
//快速幂
function power(a, x: longint): int64;
var
    t: longint;
begin
    if x = 1 then
        exit(a);
    if x = 0 then
        exit(1);
    t := power(a, x shr 1);
    power := t * t mod modn;
    if odd(x) then
        power := power * a mod modn;
end;
//快速组合数
function C(n, k: longint): int64;
begin
    if map[n, k] &amp;gt; 0 then
        exit(map[n, k]);
    if (n &amp;lt;= k) or (k = 0) then
        C := 1
    else if k = 1 then
        C := n
    else
        C := (C(n-1, k)+C(n-1, k-1)) mod modn;
    map[n, k] := C;
end;

var
    t: longint;
    ans: int64;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(a, b, k, n, m);
    a := a mod modn;
    b := b mod modn;
    ans := power(a, n);
    ans := ans * power(b, m) mod modn;
    //C(k,n)与C(k,m)是等效的，计算较小者即可
    if n &amp;gt; m then n := m; 
    ans := ans * C(k, n) mod modn;
    writeln(ans);

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/noip2011-day2-coefficient-calculate/</link>
                <guid>http://hsfzxjy.github.io/noip2011-day1-%e8%ae%a1%e7%ae%97%e7%b3%bb%e6%95%b0%ef%bc%9a%e5%bf%ab%e9%80%9f%e6%b1%82%e7%bb%84%e5%90%88%e6%95%b0</guid>
                <pubDate>2014-10-25T23:27:13+08:00</pubDate>
        </item>

        <item>
                <title>UVa1647 Computer Transformation</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=825&amp;amp;page=show_problem&amp;amp;problem=4522&quot;&gt;Link&lt;/a&gt; 耗时：0.679s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本质上，这是一道求数列通项的题目。我们列出前几个字符串：&lt;br /&gt;
$$01,$$&lt;br /&gt;
$$1001,$$&lt;br /&gt;
$$01101001,$$&lt;br /&gt;
$$1001011001101001,$$&lt;br /&gt;
$$\ldots$$&lt;br /&gt;
如果用$S_i$表示第i个字符串中“00”的个数，则有：&lt;br /&gt;
$$S_1=0,\ S_2=1,\ S_3=1,\ S_4=3,\ S_5=5,\ S_6=11,\ldots$$&lt;br /&gt;
经过观察可以发现有如下规律：&lt;br /&gt;
$$S_n=2\times S_{n-1}+{(-1)}^n$$&lt;br /&gt;
求通项就简单了，换个元即可：&lt;br /&gt;
$$S_n=\frac{1}{3}[{(-1)}^n+2^{n-1}]$$&lt;br /&gt;
程序采用高精度实现。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const
    JINDU = 100000;
var
    n: Integer;
//在数字前补0
procedure PrintANumber(x: longint);
var
    t: longint;
begin
    if x = 0 then
        write('00000')
    else
    begin
        t := JINDU;
        while t &amp;gt; x * 10 do 
        begin
            write(0);
            t := t div 10;
        end;
        write(x);
    end;
end;

var
    ans: array [1..300] of longint;
    len, i: integer;
//计算2^(n-1)
procedure calc2;
var
    i, x, t, mul: longint;
begin
    len := 1;
    ans[1] := 1;
    t := n-1;
    while t &amp;gt; 0 do
    begin
        if t &amp;lt; 6 then 
            mul := 1 &amp;lt;&amp;lt; t
        else 
            mul := 64;
        x := 0;
        for i := 1 to len do
        begin
            ans[i] := ans[i] * mul + x;
            x := ans[i] div JINDU;
            ans[i] := ans[i] mod JINDU;
        end;
        if x &amp;gt; 0 then
        begin
            inc(len);
            ans[len] := x;
        end;
        dec(t, 6);
    end; 
end;
//除以3
procedure div3;
var
    i, x, t: longint;
begin
    i := len;
    x := 0;
    while i &amp;gt; 0 do
    begin
        t := (x * JINDU + ans[i]);
        ans[i] := t div 3;
        x := t mod 3;
        dec(i);
    end;
    while ans[len] = 0 do dec(len);
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    while not eof do
    begin
        readln(n);
        if n=1 then   //特殊情况处理
        begin
            writeln(0);
            continue;
        end;
        fillchar(ans, sizeof(ans), 0);
        calc2;
        if odd(n) then
            dec(ans[1])
        else
            inc(ans[1]);
        div3;
        write(ans[len]);
        for i := len-1 downto 1 do 
            PrintANumber(ans[i]);
        writeln;
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva1647-computer-transformation/</link>
                <guid>http://hsfzxjy.github.io/uva1647-computer-transformation</guid>
                <pubDate>2014-10-24T18:50:30+08:00</pubDate>
        </item>

        <item>
                <title>Sublime configuration for Pascal</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;鉴于U盘中Sublime的配置常常莫名其妙地消失，在此将其记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;cmd&quot;: [&quot;fpc&quot;, &quot;-S2&quot;, &quot;${file}&quot;, &quot;-o${file_path}/${file_base_name}.exe&quot;],
    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,
    &quot;working_dir&quot;: &quot;${file_path}&quot;,
    &quot;selector&quot;: &quot;source.pascal&quot;,

    &quot;variants&quot;: [
        {
            &quot;name&quot;: &quot;Run&quot;,
            &quot;cmd&quot;: [&quot;cmd&quot;, &quot;/c&quot;, &quot;fpc&quot;, &quot;-S2&quot;, &quot;${file}&quot;, &quot;-o${file_path}/${file_base_name}.exe&quot;, 
 &quot;&amp;amp;&amp;amp;&quot;, &quot;${file_path}/${file_base_name}.exe&quot;]
        }
    ],

    &quot;osx&quot;:
    {
        &quot;path&quot;: &quot;/usr/local/bin:/usr/bin:/bin:${path}&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/sublime-configuration-for-pascal/</link>
                <guid>http://hsfzxjy.github.io/sublime-configuration-for-pascal</guid>
                <pubDate>2014-10-23T21:22:54+08:00</pubDate>
        </item>

        <item>
                <title>UVa11526 H(n)</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=27&amp;amp;problem=2521&amp;amp;mosmsg=Submission%20received%20with%20ID%2014374168&quot;&gt;Link&lt;/a&gt; 耗时：2.232s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;粗看题目，不过就是要求这样一个式子：$\sum_{i=1}^n{[\frac{n}{i}]}$的值。但&lt;strong&gt;注意到&lt;/strong&gt;：题目给的数据范围极大，有$2^{31}-1$之多，若遍历计算，则时间复杂度为$O(n)$，将严重超时，不可取。&lt;br /&gt;
而事实上，通过尝试我们可以发现：$\sum_{i=1}^{n}{[\frac{n}{i}]}=2*\sum_{i=1}^{\sqrt n}{[\frac{n}{i}]}-{[\sqrt n]}^2$，这是一个重要的结论。因为这条式子一旦成立，时间复杂度即可从$O(n)$降为$O(\sqrt n)$，这是一个极为可观的改善。下面我们来证明一下这个结论：&lt;br /&gt;
事实上，$$\sum_{i=[{\sqrt n}]+1}^{n}{[\frac{n}{i}]}$$ $$=1\times(n-[\frac{n}{2}])+2\times([\frac{n}{2}]-[\frac{n}{3}])+\ldots+[\sqrt{n}]\times([\frac{n}{\sqrt{n}}]-{[\frac{n}{\sqrt n}+1]})$$ $$=n+[\frac{n}{2}]+[\frac{n}{3}]+\ldots+[\frac{n}{\sqrt n}]-[\sqrt n]\times[\frac{n}{[\sqrt n]+1}]$$ $$=\sum_{i=1}^{[\sqrt n]}{[\frac{n}{i}]}-{[\sqrt n]}^2$$ 从而，命题得证。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    n, _, i: longint;

function h: int64; inline;
var
    k, t: longint;
begin
    h := 0;
    t := trunc(sqrt(n));
    k := 1;
    while k &amp;lt;=t do
    begin
        h := h + n div k;
        inc(k);
    end;
    h := h * 2 - t * t;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(_);
    while _ &amp;gt; 0 do
    begin
        dec(_);
        readln(n);
        if n &amp;lt;= 0 then
            writeln(0)
        else
            writeln(h);
    end;

    close(input);
    close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva11526-hn/</link>
                <guid>http://hsfzxjy.github.io/uva11526-hn</guid>
                <pubDate>2014-10-19T00:03:37+08:00</pubDate>
        </item>

        <item>
                <title>UVa817 According to Bartjens</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=10&amp;amp;problem=758&amp;amp;mosmsg=Submission%20received%20with%20ID%2014367065&quot;&gt;Link&lt;/a&gt; 状态：&lt;strong&gt;WA&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;做了两个小时，很可惜最终还是WA了。非常奇怪——和网上的C++代码运行结果完全一样，但却WA了。不过，在这里我还是记录一下解题的过程。&lt;br /&gt;
这道题数据量很小，直接爆搜每个空位，用*, +, -, #0来代表符号或不填。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const
    operators: array [1..4] of char = ('*', '+', '-', #0); //符号
var
    s: string;
    _, n: integer;
    op: array [0..10] of char;
    yes: Boolean;

function toValue(ch: char): integer;
begin
    exit(ord(ch) - ord('0'));
end;

procedure calcAndPrint; 
var
    numtop, opstop: Integer;  //数字栈，符号栈
    num: array [1..10] of longint;
    ops: array [1..10] of char;
    i: integer;
begin
    i := 1;
    numtop := 1;
    num[numtop] := toValue(s[1]);
    opstop := 0;
    while i &amp;lt;= n do
    begin
        while (i &amp;lt; n) and (op[i] = #0) do
        begin
            inc(i);
            num[numtop] := num[numtop] * 10 + toValue(s[i]);
        end;
        if (op[i] in ['+', '-']) or (i &amp;gt;= n) then
        begin
            while (opstop &amp;gt; 0) and (ops[opstop] = '*') do
            begin
                dec(opstop);
                num[numtop - 1] := num[numtop] * num[numtop -1];
                dec(numtop);
            end;
        end;
        if i &amp;gt;= n then break;
        inc(opstop);
        ops[opstop] := op[i];
        inc(i);
        inc(numtop);
        num[numtop] := toValue(s[i]);
    end;
    i := 1;
    while i &amp;lt; numtop do
    begin
        if ops[i] = '+' then
            num[i+1] := num[i] + num[i+1]
        else
            num[i+1] := num[i] - num[i+1];
        inc(i);
    end;
    if (num[numtop] = 2000) and (opstop &amp;gt; 0) then
    begin
        yes := True;
        write('  ');
        for i := 1 to n do
        begin
            write(s[i]);
            if op[i] &amp;lt;&amp;gt; #0  then
                write(op[i]);
        end;
        writeln('=');
    end;
end;

procedure dfs(t: integer); //搜索第t个位置
var
    i: Integer;
    ch: char;
begin
    if t = n then
    begin
        calcAndPrint;
        exit;
    end;
    for i := 1 to 4 do
    begin
        ch := operators[i];
        if (ch = #0) and (s[t] = '0') and ((t = 1) or (t &amp;gt; 1) and (op[t-1] &amp;lt;&amp;gt; #0)) then continue;
        op[t] := ch;
        dfs(t+1);
    end;
end;

var
    i: Integer;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(s);
    _ := 0;
    while not eof and (s[1] &amp;lt;&amp;gt; '=') do
    begin
        i := 1;
        while not (s[i] in ['0'..'9', '=']) do
        begin
            inc(i);
        end;
        delete(s, 1, i-1);
        n := pos('=', s) - 1;
        inc(_);
        writeln('Problem ', _);
        yes := False;
        fillchar(op, sizeof(op), 0);
        dfs(1);
        if not yes then
            writeln('  IMPOSSIBLE');
        readln(s);
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva817-according-to-bartjens/</link>
                <guid>http://hsfzxjy.github.io/uva817-according-to-bartjens</guid>
                <pubDate>2014-10-17T20:05:06+08:00</pubDate>
        </item>

        <item>
                <title>UVa225 Golygons</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=4&amp;amp;problem=161&amp;amp;mosmsg=Submission%20received%20with%20ID%2014355705&quot;&gt;Link&lt;/a&gt; 耗时：0.699s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dfs(t, x, y, d, s)&lt;/code&gt;表示当前走了t步，在(x,y)，上一个方向为d，s为一个求和用的辅助变量。&lt;br /&gt;
当前位置无法走完剩下的路时直接回溯。可节省接近2s的时间。&lt;br /&gt;
&lt;strong&gt;ps: 这道题虽然没有明说每个城市只走一次，但它的确那样判了，这一点坑了我好久。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//Accepted.
const
    dx: array [1..4] of integer = (1, 0, 0, -1);
    dy: array [1..4] of integer = (0, 1, -1, 0);
    dir: array [1..4] of char = ('e', 'n', 's', 'w');

var
    a: array [1..50, 1..2] of integer; //障碍物
    k, i, n, _, x, y: integer;
    ans: array [1..20] of char;
    tot: longint;
    vis: array [-220..220, -220..220] of boolean;

function judge(x1, y1, x2, y2: longint): Boolean; //判断刚刚走过的路上是否有障碍物
var
    i: Integer;
begin
    judge := False;
    if x1 = x2 then
    begin
        for i := 1 to k do 
            if (a[i, 1] = x1) and ((a[i, 2] - y1)*(a[i, 2] - y2) &amp;lt;= 0) then exit;
    end
    else
        for i := 1 to k do
            if (a[i, 2] = y2) and ((a[i, 1] - x1)*(a[i, 1] - x2) &amp;lt;= 0) then exit; 
    judge := True;
end;

procedure print;
var
    i: Integer;
begin
    for i := 1 to n do write(ans[i]);
    writeln;
    inc(tot);
end;

procedure dfs(t, x, y, d, s: integer);
var
    i, sum: Integer;
    tx, ty: longint;
begin
    if t = n then 
    begin
        if (x = 0) and (y = 0) then print;
        exit;
    end;

    sum := s - t - 1;
    inc(t);

    for i := 1 to 4 do
    begin
        if (i = d) or (i + d = 5) then continue;   //方向相同或相反
        tx := x + dx[i] * t;
        ty := y + dy[i] * t;
        if vis[tx, ty] then continue;              //走过 
        if abs(tx) + abs(ty) &amp;gt; sum then continue;  //回不去，剪枝
        if not judge(x, y, tx, ty) then continue;  //有障碍物
        ans[t] := dir[i];
        vis[tx, ty] := True;
        dfs(t, tx, ty, i, sum);
        vis[tx, ty] := False;
    end;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(_);
    while _ &amp;gt; 0 do 
    begin
        dec(_);
        read(n, k);
        fillchar(vis, sizeof(vis), 0);
        for i := 1 to k do 
            read(a[i, 1], a[i, 2]);
        fillchar(ans, sizeof(ans), 0);
        tot := 0;
        dfs(0, 0, 0, -1, n * (n+1) div 2);
        writeln('Found ', tot, ' golygon(s).');
        writeln;
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva225-golygons/</link>
                <guid>http://hsfzxjy.github.io/uva225-golygons</guid>
                <pubDate>2014-10-15T22:04:51+08:00</pubDate>
        </item>

        <item>
                <title>NOIP初赛基础知识</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;从今天起至10月11日，持续连载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;关于计算机&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;ENIAC&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;出现于&lt;strong&gt;1946年&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;是&lt;strong&gt;最早&lt;/strong&gt;的计算机。&lt;/li&gt;
&lt;li&gt;是&lt;strong&gt;电子管&lt;/strong&gt;计算机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;阶码&lt;/strong&gt;，即浮点数的指数部分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IPv6是128位的。&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;求补码：二进制下：&lt;strong&gt;各位取反再加1&lt;/strong&gt; 或 &lt;strong&gt;把原码减1再取反&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;关于算法&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;各种排序的时间复杂度&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;快速排序：$O(nlogn)$，最坏为$O(n^2)$。&lt;/li&gt;
&lt;li&gt;冒泡排序：$O(n^2)$。&lt;/li&gt;
&lt;li&gt;归并排序：$O(nlogn)$。&lt;/li&gt;
&lt;li&gt;计数排序：$O(n)$。&lt;/li&gt;
&lt;li&gt;插入排序：$O(n^2)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;关于树&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完全二叉树 vs 满二叉树：&lt;strong&gt;完全二叉树最后一层不一定满&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;前序遍历：&lt;strong&gt;中左右&lt;/strong&gt;；中序遍历：&lt;strong&gt;左中右&lt;/strong&gt;；后序遍历：&lt;strong&gt;左右中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;节点数为n的二叉树上，有两个节点的至多有$[(n+1)/2]$个。&lt;/li&gt;
&lt;li&gt;节点数为n的完全二叉树有$log(n)$层，节点序号大于$n\ div\ 2$的为叶节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;计算机史&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;熵在&lt;strong&gt;1948年由克劳德·香农引入信息通信领域。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;杂项&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;3G网络&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;三种标准：&lt;strong&gt;CDMA2000、WCDMA、TD-SCDMA&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;4G网络&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类别：&lt;strong&gt;TD-LTE和FDD-LTE&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;N/NP问题&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;P：复杂度类P包含所有那些可以由一个确定型图灵机&lt;strong&gt;在多项式表达的时间&lt;/strong&gt;内解决的问题。&lt;/li&gt;
&lt;li&gt;NP：是指可以在多项式时间内被非确定机(他可以猜,他总是能猜到最能满足你需要的那种选择,如果你让他解决n皇后问题,他只要猜n次就能完成----每次都是那么幸运)解决的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;NOIP申诉条件（操蛋去年居然考了！）&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;非公示期限内提出的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;与个人名次、他人成绩和他人名次有关的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;未通过NOI科学委员会提交的、来自非正规渠道的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;因操作系统、语言环境的具体差异引起成绩变动的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;对使用随机数和随机算法的程序的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;发布成绩与选手使用非规范环境和数据、参数评测出的成绩不同，并因此提出的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;在与标准测试环境相同的机器上，自测用时超过题目时限的5%，并由此提出的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;以修改过的程序或答案为依据的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;因选手错误而导致答案文件名错误，或者源文件存放目录结构不规范，且所提出的申诉与此有关的，不予受理。 &lt;/li&gt;
&lt;li&gt;未描述清楚自测状况，如“与老师评测有出入”，“感觉评测结果有错”等，不予受理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;NOIP官网：&lt;strong&gt;http://www.noi.cn/&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;中国互联网信息中心的缩写：&lt;strong&gt;CNNIC&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://hsfzxjy.github.io/noip-senior-knowlegdes/</link>
                <guid>http://hsfzxjy.github.io/noip%e5%88%9d%e8%b5%9b%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86</guid>
                <pubDate>2014-10-08T22:03:30+08:00</pubDate>
        </item>

        <item>
                <title>UVa12219 Common Subexpression Elimination</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=3371&quot;&gt;Link&lt;/a&gt; 状态：&lt;strong&gt;Runtime Error&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这题做的可真够久的，整整三个小时。但即便如此，还是只过了一部分的点，另一部分报运行时错误——估计是哈希表设计的不太好。但这确实是一道好题，因此，在睡觉前决定记录一下。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;很容易便想到：用一个三元组$(x,y,z)$表示节点，表示内容为x的节点下跟着标号为y和z的左右子树。这样一来，一类相同的子树便可以唯一确定了，而不必每构造一棵子树就把整棵树遍历一遍。&lt;br /&gt;
对于三元组的储存，刚开始图方便，用了数组。查找也是用了$O(n)$的线性查找。磕磕碰碰写了两个多小时然后兴冲冲地提交，结果TLE了…………没办法，只好又花了半个小时写了一个哈希表，然后就是上文说过的情况了：&lt;strong&gt;Runtime Error204&lt;/strong&gt;。可能是哈希数组过大的原因，日后再微调一下，今天实在是没有脑子了。&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const
  maxn = 20000;
type
  NodeRec = record
    Value: string;
    l, r, index: longint;
  end;
  Node = record
     left, right: longint;   //Index of left and right child in the `tree` array, -1 for none.
     Rec: NodeRec;
     index: longint;
  end;
  //以下为哈希表的定义
  _PNode = ^_Node;
  _Node = record
    n: Node;
    next: _PNode;
  end;

  HashTable = object
    arr: array [0..maxn] of _PNode;
    function hash(n: NodeRec): longint;
    procedure add(n: Node);
    procedure clear;
    function find(n: NodeRec): longint;
  end;

procedure HashTable.clear;
var
  i: longint;
  p, q: _PNode;
begin
  for i := 0 to maxn do
  begin
    p := arr[i];
    while p&amp;lt;&amp;gt;nil do
    begin
      q := p^.next;
      dispose(p);
      p := q;
    end;
  end;
  fillchar(arr, sizeof(arr),0);
end;

function cmp(r1, r2: NodeRec): Boolean;
begin
  cmp := (r1.l = r2.l) and (r1.r = r2.r) and (r1.Value = r2.Value);
end;

function HashTable.hash(n: NodeRec): longint;
var
  i: longint;
begin
  hash := 0;
  for i := 1 to length(n.Value) do
    hash := (hash*5 + ord(n.Value[i]) - ord('a')) mod maxn;
  hash := (hash + n.l * 10 + n.r * 5) mod maxn;
end;

procedure HashTable.add(n: Node);
var
  h: longint;
  p, q: _PNode;
begin
  h := hash(n.rec);
  new(q);
  fillchar(q^, sizeof(_Node), 0);
  q^.next := arr[h];
  q^.n := n;
  arr[h] := q;
end;

function HashTable.find(n: NodeRec): longint;
var
  p: _PNode;
begin
  find := -1;
  p := arr[hash(n)];
  while (p&amp;lt;&amp;gt;nil) and not cmp(n, p^.n.rec) do p := p^.next;
  if p &amp;lt;&amp;gt; nil then
    find := p^.n.index;
end;
//哈系表定义结束
var
  inputs: Ansistring;
  _: longint;
  tree: array [1..50001] of Node;
  cur: longint;              //The current pointer of the input string.
  num: longint;              //The current number of the `tree` array.
  ls: longint;
  t: longint;
  tot: longint;
  ht: HashTable;

function build: longint; //建树
label lb;
var
  rec: NodeRec;
  i,j,l,r: longint;
begin
  l := 0;
  r := 0;
  fillchar(rec, sizeof(rec), 0);
  inc(tot);
  rec.index := tot;
  while (cur&amp;lt;=ls) and (inputs[cur] in ['a'..'z']) do
  begin
    rec.Value := rec.Value+inputs[cur];
    inc(cur);
  end;
  if cur&amp;gt;ls then goto lb;    //。。。这里被迫跳转控制流，由于实在不想多谢，就用了臭名昭著的label
  if inputs[cur] = '(' then
  begin
    inc(cur);
    l := build();
    rec.l := tree[l].rec.index;
    inc(cur);
    r := build();
    rec.r := tree[r].rec.index;
    inc(cur);
  end;
  j := ht.find(rec);
  if j&amp;gt;0 then
  begin
    dec(tot);
    exit(j);
  end
  else
  begin
lb:
    inc(num);
    tree[num].left := l;
    tree[num].right := r;
    tree[num].rec := rec;
    tree[num].index := num;
    ht.add(tree[num]);
    exit(num);
  end;
end;

procedure print(n: longint);
begin
  if tree[n].rec.index &amp;gt; t then
  begin
    write(tree[n].rec.Value);
    t := tree[n].rec.index;
  end
  else
  begin
    write(tree[n].rec.index);
    exit;
  end;
  if tree[n].right = 0 then
    exit;
  write('(');
  print(tree[n].left);
  write(',');
  print(tree[n].right);
  write(')');
end;
begin
  assign(input, 'main.in'); reset(input);
  assign(output, 'main.out'); rewrite(output);
  readln(_);
  fillchar(ht.arr, sizeof(ht.arr),0);
  while _&amp;gt;0 do
  begin
    dec(_);
    readln(inputs);
    fillchar(tree, sizeof(tree), 0);
    ht.clear;
    ls := length(inputs);
    cur := 1;  num := 0; tot := 0;
    build;
    t := 0;
    print(num);
    writeln;
  end;
  close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva12219-common-subexpression-elimination/</link>
                <guid>http://hsfzxjy.github.io/uva12219-common-subexpression-elimination</guid>
                <pubDate>2014-10-06T00:20:18+08:00</pubDate>
        </item>

        <item>
                <title>UVa536 Recovery</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=7&amp;amp;page=show_problem&amp;amp;problem=477&quot;&gt;Link&lt;/a&gt; 耗时: 0.012s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;真是疯玩了几天，脑袋都残了，一道弱智题做了近一个小时。&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    pre, mid, s: string;
    tree: array [1..50] of record
        l, r: integer;
        ch: char;
    end;
    cur: integer;
function init: integer;
var
    m: integer;
begin
    readln(s);
    m := length(s) &amp;gt;&amp;gt; 1 + 1;
    pre := Copy(s, 1, m-1);
    mid := Copy(s, m+1, length(s));
    init := m-1;
end;
function build(l1, l2, r2: integer): integer;
var
    m,len: integer;
    t: integer;
begin
    if l2 &amp;gt; r2 then exit(0); //该子树不存在。**这个地方坑了我很久**
    inc(cur);
    t := cur;      // 这里也坑了我，当下面构造完左右子树后，cur已经变了，所以要缓存起来
    build := t;  
    tree[t].ch := pre[l1]; 
    if r2-l2 = 0 then //叶节点
        exit;
    m := pos(pre[l1], mid); //在中序遍历中找根节点
    len := m - l2;
    tree[t].l := build(l1+1, l2, m-1); //构造左子树
    tree[t].r := build(l1+len+1, m+1, r2); //构造右子树
end;
procedure print(x: integer);
begin
    if x = 0 then exit;
    print(tree[x].l);
    print(tree[x].r);
    write(tree[x].ch);
end;
begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);
    while not eof do
    begin
        fillchar(tree, sizeof(tree), 0);
        cur := 0;
        build(1, 1, init);
        print(1);
        writeln;
    end;
    close(input);
    close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva536-recovery/</link>
                <guid>http://hsfzxjy.github.io/uva536-recovery</guid>
                <pubDate>2014-10-06T00:03:04+08:00</pubDate>
        </item>

        <item>
                <title>UVa11582 Colossal Fibonacci Numbers! && 大数操作</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=27&amp;amp;problem=2629&amp;amp;mosmsg=Submission%20received%20with%20ID%2014290914&quot;&gt;Link&lt;/a&gt; 耗时：0.139s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这道题的主要思路就是打表，看看Fibonacci数列模n几个一循环。但由于这题给的数太大了，从而在细节上耗了很久。在此记录一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var
    x: qword;
    y: longint;
begin
    x := 1&amp;lt;&amp;lt;64-1;
    y := 100;
    x := x mod y; //报错201
    x := x mod qword(y); //正确
end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    a,b: qword;
    _, n, i, k, cnt: longint;
    f: array [1..1000000] of longint;

function superMod(a, b: qword; m: longint): longint;
var
    x: qword;
begin
    if b = 0 then
        exit(1);
    x := superMod(a, b shr 1, m);
    superMod := x * x mod m;
    if odd(b) then
        superMod := superMod * a mod m;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);
    readln(_);
    while _ &amp;gt; 0 do
    begin
        dec(_);
        readln(a, b, n);
        if a = 0 then
        begin
            writeln(0);
            continue;
        end;
        if n = 1 then
        begin
            writeln(0);
            continue;
        end;
        f[1] := 1;
        f[2] := 1;
        cnt := 2;
        while not ((f[cnt-1] = 1) and (f[cnt] = 0)) do
        begin
            inc(cnt);
            f[cnt] := (f[cnt-1] + f[cnt-2]) mod n;
        end;
        //while x &amp;gt; int64(1 &amp;lt;&amp;lt;60) do
        //    x := x - int64((cnt &amp;lt;&amp;lt; 59));
        a := a mod qword(cnt);
        k := superMod(a, b, cnt);
        writeln(f[k]);
    end;
    close(output); close(input);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva11582-colossal-fibonacci-numbers/</link>
                <guid>http://hsfzxjy.github.io/uva11582-colossal-fibonacci-numbers-%e5%a4%a7%e6%95%b0%e6%93%8d%e4%bd%9c</guid>
                <pubDate>2014-10-01T19:12:27+08:00</pubDate>
        </item>

        <item>
                <title>扩展欧几里得算法</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;今天开始学习数论方面的算法。这部分在NOIP中并不常出现，即使出现了也不会像高联这么难（。。。）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;什么是扩展欧几里得算法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;所谓欧几里得算法，实际上就是辗转相除法——求两个数最大公约数的一种高效算法。而扩展欧几里得算法则是来源于于一类方程的解决：&lt;br /&gt;
$$ax+by=gcd(a,b)$$&lt;br /&gt;
这有点像是&lt;strong&gt;裴蜀定理&lt;/strong&gt;的一般形式。和裴蜀定理类似，这类方程也有无数多个整数解。如何高效率地求得它的一组特解呢？&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;procedure gcd_ex(a, b: longint; var d: longint; var x, y: longint);
begin
    if b = 0 then
    begin
        d := a;
        x := 1;
        y := 0;
        exit;
    end;
    gcd_ex(b, a mod b, d, y, x); //重要
    y := y-(a div b) * x;
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;详解&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;乍一看，算法似乎和一般欧几里得算法很是相似：都是递归实现，参数传递过程中都体现了“辗转相除”的思想。那为什么这个算法是正确的呢？&lt;/p&gt;
&lt;p&gt;这里先解释一下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a：方程中的参数a&lt;/li&gt;
&lt;li&gt;b：方程中的参数b&lt;/li&gt;
&lt;li&gt;d：即&lt;code&gt;gcd(a,b)&lt;/code&gt;。由于和辗转相除法的相似性，在这里最大公约数也可以“顺便”算出。当然，去掉也无大碍&lt;/li&gt;
&lt;li&gt;x&amp;amp;y：方程的一组特解(x, y)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面解释标注了&lt;strong&gt;重要&lt;/strong&gt;的那行代码。&lt;/p&gt;
&lt;p&gt;假设方程 $ax+by=gcd(a,b)$ 有一组特解$(x_0,y_0)$。则有$ax_0+by_0=gcd(a,b)$。&lt;br /&gt;
由最大公约数原理可知：$gcd(a,b)=gcd(b, a\ mod\ b)$。从而有$ax_0+by_0=gcd(b,a\ mod\ b)$。&lt;br /&gt;
又方程：$bx+(a\ mod\ b)y=gcd(b,a\ mod\ b)$一定有整数解，设其为$(x_1,y_1)$。则有&lt;br /&gt;
$$ax_0+by_0=gcd(b,a\ mod\ b)=bx_1+(a\ mod\ b)y_1$$即$$ax_0+by_0=bx_1+(a-(a\ div\ b)*b)y_1$$即$$a(x_0-y_1)=b(x_1-(a\ div\ b)y_1-y_0)$$由恒等原理可知：$$x_0=y_1$$$$y_0=x_1-(a\ div\ b)y_1$$。&lt;br /&gt;
因此，当$a,b\neq0$时，$x,y$的值可以递归求得。递归边界为：$b=0$时$x=1,y=0$。&lt;br /&gt;
注意到上面的算法用到了一个技巧：在递归传参数的时候将y,x调换了。这样做的好处是节省了一个中间变量用来储存$y_1$，否则在计算$y_0$时$y_1$也被覆盖了。从而使算法更加的精简。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;应用&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算几何中求整点的问题&lt;/li&gt;
&lt;li&gt;求一元一次同余方程$a\equiv b\pmod{m}$的一组特解。（即方程$ax+my=b$的一组特解）&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://hsfzxjy.github.io/extended-gcd-algorithm/</link>
                <guid>http://hsfzxjy.github.io/%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95</guid>
                <pubDate>2014-10-01T16:55:50+08:00</pubDate>
        </item>

        <item>
                <title>UVa10285 Cake Slicing</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=825&amp;amp;page=show_problem&amp;amp;problem=4504&quot;&gt;Link&lt;/a&gt;  耗时：1.825s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题做的可真够久的：前前后后加起来将近有两个小时，因此当AC的那一刻，自己心中还是挺自豪的。&lt;br /&gt;
事实上，这是一道复杂一点的区间型动态规划，之所以说“复杂”，是因为它的状态转移是&lt;strong&gt;二维&lt;/strong&gt;的：切蛋糕既可以横切，也可以纵切。由此我想到了分治算法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设一个矩形它所需要切的刀数是f，则f可以由组成该矩形的小矩形的f值决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，这个问题具有最优子结构。由于每个状态为一个矩形，因此需要4个维度来记录状态（及左上、右下两个顶点）。下面是横切时的状态转移方程，纵切时同理可得：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;f(up, down, left, right) = min{f(up, i, left, right) + f(i, down, left, right) + right - left} (i = up + 1 .. down -1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{$R-}
const INF = maxint div 5; //正无穷
var
    f: array [0..20, 0..20, 0..20, 0..20] of integer;
    cherries: array [1..500, 1..2] of integer;
    map: array [0..20, 0..20] of boolean;
    n, m, i, k: integer;

function min(x, y: integer): integer; inline;
begin
    if x&amp;lt;y then exit(x) else exit(y);
end;

function cherryin(u, d, l, r: integer): integer; inline; //判断矩形内有没有樱桃
var
    i, j: integer;
begin
    cherryin := 0;
    for i := u+1 to d do
        for j := l+1 to r do
            if map[i, j] then
            begin
                inc(cherryin);
                if cherryin = 2 then exit;
            end;
end;

function dp(u, d, l, r: integer): integer;
var
    b: integer;
    i: integer;
begin
    if f[u, d, l, r] &amp;lt;&amp;gt; -1 then
        exit(f[u,d , l, r]);
    b := cherryin(u, d, l, r);
    if b = 1 then
    begin
        f[u, d, l, r] := 0;
        exit(0);
    end;
    if b = 0 then
    begin
        f[u, d, l, r] := INF;
        exit(INF);
    end;
    dp := INF;
    for i := u+1 to d-1 do
        dp := min(dp, dp(u, i, l, r)+dp(i, d, l, r)+r-l);
    for i := l+1 to r-1 do
        dp := min(dp, dp(u, d, l, i)+dp(u, d, i, r)+d-u);
    f[u, d, l, r] := dp;
end;

var
    _: integer;

begin
    assign(input, 'main.in');reset(input);
    assign(output, 'main.out');rewrite(output);
    _ := 0;
    readln(n, m, k);
    while n&amp;gt;0 do
    begin
        inc(_);
        fillchar(map, sizeof(map), 0);
        fillchar(f, sizeof(f), -1);
        for i := 1 to k do
        begin
            readln(cherries[i, 1], cherries[i, 2]);
            map[cherries[i, 1], cherries[i, 2]] := true;
        end;
        writeln('Case ',_,': ', dp(0,n,0,m));
        readln(n, m, k);
    end;
    close(input);close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva10285-cake-slicing/</link>
                <guid>http://hsfzxjy.github.io/uva10285-cake-slicing</guid>
                <pubDate>2014-10-01T12:20:18+08:00</pubDate>
        </item>

        <item>
                <title>UVa10285 Longest Run on a Snowboard</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=14&amp;amp;problem=1226&amp;amp;mosmsg=Submission%20received%20with%20ID%2014282250&quot;&gt;Link&lt;/a&gt; 耗时：0.028s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一道简单的动态规划，主要思路就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;用f[i,j]表示到达(i,j)的最长路径的长度。&lt;/strong&gt;找到每个最高点，从其开始向四周的低处搜索。如果该点已搜过并且f值大于当前长度则退出回溯。直到达到某个最低点为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不多说了，直接上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const
    delta :array [1..4, 1..2] of integer = ((-1, 0), (1, 0), (0, 1), (0, -1)); //四个方向向量
var
    _: Integer;
    name: string;
    n, m, i, j, x: Integer;
    ans: longint;
    map: array [0..101, 0..101] of integer;
    f: array [1..100, 1..100] of longint;

function max(x, y: longint): longint; inline;
begin
    if x&amp;gt;y then exit(x) else exit(y);
end;

function can(x, y: integer): Boolean; inline; //判断是否是最高点
var
    i: Integer;
    tx, ty: integer;
begin
    can := true;
    for i := 1 to 4 do
    begin
        tx := x + delta[i, 1];
        ty := y + delta[i, 2];
        can := can and (map[x, y] &amp;gt;= map[tx, ty]);
        if not can then break;
    end;
end;

procedure dp(x, y: integer; len: longint); //回溯进行动态规划
var
    i: Integer;
    tx, ty: integer;
begin
    inc(len);
    if f[x, y] &amp;gt; len then exit;
    f[x, y] := len;
    ans := max(ans, len);
    for i := 1 to 4 do
    begin
        tx := delta[i, 1] + x;
        ty := delta[i, 2] + y;
        if (tx = 0) or (tx &amp;gt; n) or (ty = 0) or (ty &amp;gt; m) then continue;
        if map[x, y] &amp;lt;= map[tx, ty] then continue;
        dp(tx, ty, len);
    end;
end;

procedure ReadAndProcessName; //处理那行该死的名字！！
var
    s: string;
    i: integer;
begin
    readln(s);
    i := 1;
    name := '';
    n := 0;
    m := 0;
    while s[i] &amp;lt;&amp;gt; ' ' do
    begin
        name := name + s[i];
        inc(i);
    end;
    inc(i);
    while s[i] &amp;lt;&amp;gt; ' ' do
    begin
        n := n * 10 + ord(s[i]) - ord('0');
        inc(i);
    end;
    inc(i);
    while i &amp;lt;= length(s) do
    begin
        m := m * 10 + ord(s[i]) - ord('0');
        inc(i);
    end;
end;

begin
    assign(input, 'main.in');reset(input);
    assign(output, 'main.out');rewrite(output);
    readln(_);
    while _&amp;gt;0 do
    begin
        dec(_);
        fillchar(map, sizeof(map), 0);
        ReadAndProcessName;

        for i := 1 to n do
            for j := 1 to m do
            begin
                read(x);
                map[i, j] := x+1;
            end;
        readln;

        fillchar(f, sizeof(f), 0);
        ans := 0;
        for i := 1 to n do
            for j := 1 to m do
                if can(i, j) then
                    dp(i, j, 0);
        writeln(name, ': ', ans);
    end;
    close(input);close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva10285-longest-run-on-a-snowboard/</link>
                <guid>http://hsfzxjy.github.io/uva10285-longest-run-on-a-snowboard</guid>
                <pubDate>2014-09-29T22:00:35+08:00</pubDate>
        </item>

        <item>
                <title>关于Ubuntu突然无法连接Wifi的解决方案</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;事实上我也不知道发生了什么，大概是几天前插了“小度Wifi”的缘故。没有任何征兆地，Wifi就用不了了。 其实我也不知道原理，大概是某个驱动被刷掉了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是从网上找来的答案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install wicd-daemon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;做个记录。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/ubuntu-offline-solution/</link>
                <guid>http://hsfzxjy.github.io/%e5%85%b3%e4%ba%8eubuntu%e7%aa%81%e7%84%b6%e6%97%a0%e6%b3%95%e8%bf%9e%e6%8e%a5wifi%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88</guid>
                <pubDate>2014-09-27T18:41:31+08:00</pubDate>
        </item>

        <item>
                <title>UVa12186 Another Crisis && [Dynamic Arrays in Pascal]</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=243&amp;amp;page=show_problem&amp;amp;problem=3338&quot;&gt;Link&lt;/a&gt; 耗时：0.586s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨晚做的太急了，没时间写总结，正好下午有空，补上。&lt;br /&gt;
这是一道典型的树形动态规划，不是很难，但十分坑语言。思路大致如下：&lt;/p&gt;
&lt;p&gt;对于第i个节点，用d(i)表示其上诉所需的最小工人数。若i为叶节点，则d(i)=1；否则，遍历求出i的子节点所对应的d值，并由小到大排序，取出最小的几个相加，即为d(i)。&lt;/p&gt;
&lt;p&gt;很容易想到用递归来实现。但对于“子节点的d值的排序”实现起来却十分困难：因为事先不知道有多少个数。当然啦，如果是C++组，用vector可以轻松搞定，可至于P党，实现起来却难上加难。思来想去，决定试试Pascal的动态数组。磕磕碰碰调了近1个小时，终于AC了。&lt;br /&gt;
Code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//Accepted
var
    tree: array [0..100000] of array of int64;
    T: Integer;
    f: array [0..100000] of int64;
    i,l,n,x:longint;

function min(x,y: int64): int64;
begin
    if x&amp;lt;y then exit(x) else exit(y);
end;

procedure sort(var arr: array of int64;l,r:longint); overload;
var
  i,j:longint;
  m,t: int64;
begin
  i := l;
  j := r;
  m := arr[(l+r) &amp;gt;&amp;gt; 1];
  repeat
    while arr[i]&amp;lt;m do inc(i);
    while arr[j]&amp;gt;m do dec(j);
    if i&amp;lt;=j then
    begin
      t := arr[i];
      arr[i] := arr[j];
      arr[j] := t;
      inc(i);
      dec(j);
    end;
  until i&amp;gt;j;
  if i&amp;lt;r then sort(arr, i, r);
  if l&amp;lt;j then sort(arr, l, j);
end;

procedure sort(var arr: array of int64); overload;
begin
  sort(arr, low(arr), high(arr));
end;
function dp(x: longint): int64;
var
  arr: array of int64;
  l,i, num: longint;
begin
    if f[x] &amp;lt;&amp;gt; 0 then
    begin
        dp := f[x];
        exit;
    end;
    if length(tree[x]) = 0 then
    begin
      dp := 1;
      f[x] := 1;
      exit;
    end;
    l := length(tree[x]);
    SetLength(arr, l);
    for i := Low(tree[x]) to High(Tree[x]) do
      arr[i] := dp(tree[x][i]);
    Sort(arr);
    num := (l*T-1) div 100+1;
    for i := Low(arr) to num-1 do
      f[x] := f[x] + arr[i];
    dp := f[x];
end;

begin
    assign(input, 'main.in');reset(input);
    assign(output,'main.out');rewrite(output);
    readln(n, T);
    while n&amp;gt;0 do
    begin
        fillchar(f, sizeof(f), 0);
        fillchar(tree, sizeof(tree), 0);
        for i := 1 to n do
        begin
            read(x);
            SetLength(tree[x], length(tree[x])+1);
            tree[x][high(tree[x])] := i;
        end;
        readln;
        dp(0);
        writeln(f[0]);
        readln(n, T);
    end;
    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Dynamic Arrays&lt;/h2&gt;
&lt;p&gt;这里，再总结一下动态数组的用法。&lt;br /&gt;
1&amp;#46; 定义：&lt;code&gt;a: array of [type];&lt;/code&gt;&lt;br /&gt;
2&amp;#46; 设置长度： &lt;code&gt;SetLength(a, 10);&lt;/code&gt;&lt;br /&gt;
3&amp;#46; 长度加一： &lt;code&gt;SetLength(a, Length(a)+1);&lt;/code&gt;&lt;br /&gt;
4&amp;#46; 取得最大、最小下标： &lt;code&gt;High(a)&lt;/code&gt;, &lt;code&gt;Low(a)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;事实上，从&lt;a href=&quot;http://freepascal.org/docs-html/ref/refsu18.html#x42-480003.3.1&quot;&gt;1&amp;#46;1&lt;/a&gt;版本开始FPC就支持Dynamic Arrays了。所以在NOIP竞赛中我们大可放心使用。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/uva12186-another-crisis-dynamic-arrays-in-pascal/</link>
                <guid>http://hsfzxjy.github.io/uva12186-another-crisis-dynamic-arrays-in-pascal</guid>
                <pubDate>2014-09-27T16:26:32+08:00</pubDate>
        </item>

        <item>
                <title>UVa11584 Partitioning by Palindromes</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;这是一道区间型DP，转移方程很简单，但在实现的过程中却遇见了很多坑，在此记录一下。 链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=27&amp;amp;problem=2631&amp;amp;mosmsg=Submission%20received%20with%20ID%2014256745&quot;&gt;Link&lt;/a&gt; 耗时：0.368s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容易想到，前i个数的划分情况可以由1,2,3...,i-1的划分情况来决定。因此很容易得到状态转移方程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;d[i] = min(d[i], d[j]+1) //j = 0, 1, 2...n-1 并且 s[j+1, i]为回文串，初始条件：d[i] = i。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;d[i]表示前i项的最小划分。这样一来状态转移的复杂度就为O($n^2$)。&lt;br /&gt;
但状态转移的判断呢？“回文串”是一个复杂的条件，判断一个串是否为回文串需要将该串至少遍历一遍。这样一来时间复杂度就上升为O($n^3$)了。而事实上在这种算法中有许多无谓的计算，因此我们可以先对字符串进行预处理：用huiwen[i,j]表示s[i,j]是否为回文串（奇怪的名字。。。）。如此一来，时间复杂度就降为O($n^2$)了。&lt;/p&gt;
&lt;p&gt;Code：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var
    s: AnsiString;
    n, _, i, j, l: integer;
    huiwen: array [1..1000, 1..1000] of boolean; //s[i,j]是否为回文串
    dp: array [0..1000] of integer; //一定从0开始，否则当整串为回文串时就考虑不到了。

function min(x,y: integer): integer;
begin
    if x&amp;lt;y then exit(x) else exit(y);
end;

procedure process(i,j: integer); //对回文串进行预处理
var
    mid: Integer;
    x,y: integer;
begin
    if j = i then
    begin
        huiwen[i,j] := true;
        exit;
    end;
    mid := i + (j-i+1) shr 1;
    x := i;
    y := j;
    while (x &amp;lt;= mid) and (s[x] = s[y]) do
    begin
        inc(x);
        dec(y);
    end;
    huiwen[i, j] := x &amp;gt; mid;
end;

begin
    //assign(input, 'main.in'); reset(input);
    //assign(output, 'main.out'); rewrite(output);
    readln(n);
    for _ := 1 to n do
    begin
        readln(s);
        l := length(s);
        //Pre-process
        fillchar(huiwen, sizeof(huiwen), 0);
        for i := 1 to l do
            for j := i to l do //一定是从i开始，这个错卡了我很久。
                process(i, j);
        //DP
        for i := 1 to l do
        begin
            dp[i] := i;
            for j := 0 to i-1 do
                if huiwen[j+1, i] then
                    dp[i] := min(dp[i], dp[j]+1);
        end;
        write(dp[l]);
        {if _ &amp;lt;&amp;gt;n then }writeln; //吐槽一下：一开始我还谨慎地加上这句以避免行末回车，没想到UVa居然报错了。。看来UVa的比较算法还有待改进啊。
    end;

    //close(input);close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva-11584-partitioning-by-palindromes/</link>
                <guid>http://hsfzxjy.github.io/uva-11584-partitioning-by-palindromes</guid>
                <pubDate>2014-09-24T22:00:14+08:00</pubDate>
        </item>

        <item>
                <title>UVa437 The Tower of Babylon</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=6&amp;amp;page=show_problem&amp;amp;problem=378&quot;&gt;The Tower of Babylon&lt;/a&gt; 耗时：0.015s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是刘汝佳的紫书中“DAG中的动态规划”中的习题，我拿它用来熟悉DAG中的动态规划。&lt;/p&gt;
&lt;p&gt;我们不妨进行逆向考虑：现堆上面的方块，然后考虑在下面进行叠加。这样子一来，影响决策的就只是最下面方块的尺寸了。&lt;br /&gt;
对于这种出现了“大套小”这样的二元关系的题，我们可以将其视为一个有向无环图：&lt;strong&gt;其中每个节点为一个状态，状态的转移是有固定的方向的&lt;/strong&gt;（在此题中，状态转移为从小的方块到大的方块）。&lt;br /&gt;
但是这道题又不同于平常的DAG动态规划：若将边长视为状态的话，则要开一个巨大的数组，这是不可以接受的。因此，我们要换一种思维方式：只记录方块的序号和摆放的方式（如现将边长从小到大进行排序，然后用一个标志k表示当前是以第k小的边长作为高）。&lt;br /&gt;
至此，思路已经清晰了。用dp(i, k)表示&lt;strong&gt;“第i个方块以第k条边为高进行摆放”&lt;/strong&gt;，以下给出状态转移方程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dp(i, k) = max{dp(i, k), dp(j, k2)} j，k2遍历所有顶面矩形比dp(i, k)小的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码实现首次尝试了Pascal中的object类型，使其更加工整，但不可避免地损耗了一些性能。&lt;/p&gt;
&lt;p&gt;Code：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type
    Cube = object
        a: array [1..3] of longint;
        procedure init(x,y,z: longint);
        function height(k: integer): longint;
        function low(k: integer): longint;
        function high(k: integer): longint;
    end;

function max(x,y: longint): longint;
begin
    if x&amp;gt;y then max := x else max := y;
end;

procedure swap(var x,y: longint);
var
    t: longint;
begin
    t := x;
    x := y;
    y := t;
end;

function Cube.height(k: integer): longint;
begin
    height := self.a[k];
end;

function Cube.high(k: integer): longint;
begin
    case k of
        1: high := a[3];
        2: high := a[3];
        3: high := a[2];
    end;
end;

function Cube.low(k: integer): longint;
begin
    case k of
        1: low := a[2];
        2,3: low := a[1];
    end;
end;

procedure Cube.init(x, y, z: longint);
begin
   if x&amp;gt;y then swap(x,y);
   if y&amp;gt;z then swap(y,z);
   if x&amp;gt;y then swap(x,y);
   a[1] := x;
   a[2] := y;
   a[3] := z;
end;

var
    f: array [1..30, 1..3] of longint;
    i,j,m,n,x,y,z: longint;
    cnt: longint;
    cubes: array [1..30] of Cube;

function dp(id, k: integer): longint;
var
    l, h, hi: longint;
    i, j: integer;
begin
    if f[id, k] &amp;gt; 0 then
        exit(f[id, k]);
    l := cubes[id].low(k);
    hi := cubes[id].height(k);
    h := cubes[id].high(k);

    f[id, k] := hi;

    for i := 1 to n do
    begin
        //if i = id then continue;  //此处在一开始时忘记考虑了立方体有无穷多个这一条件。
        for j := 1 to 3 do
        begin
            if not ((cubes[i].low(j) &amp;lt; l) and (cubes[i].high(j) &amp;lt; h)) then
                continue;
            f[id, k] := max(f[id, k], dp(i, j)+hi);
        end;
    end;

    dp := f[id, k];
end;

begin
    assign(input, 'main.in');reset(input);
    assign(output, 'main.out');rewrite(output);
    read(n);
    cnt := 0;
    while n &amp;gt; 0 do
    begin
        inc(cnt);
        for i := 1 to n do
        begin
            read(x,y,z);
            cubes[i].init(x,y,z);
        end;
        fillchar(f, sizeof(f), 0);

        m := 0;
        for i := 1 to n do
            for j := 1 to 3 do
                m := max(m, dp(i, j));

        writeln('Case ', cnt, ': maximum height = ', m);

        read(n);
    end;
    close(input);close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva437-the-tower-of-babylon/</link>
                <guid>http://hsfzxjy.github.io/uva437-the-tower-of-babylon</guid>
                <pubDate>2014-09-23T22:00:56+08:00</pubDate>
        </item>

        <item>
                <title>NOIP2011 表达式计算</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;记得11年的时候，觉得这道题爆难，根本无从下手。三年后再次回顾，终于AC了，就当是对表达式求值和动态规划的复习吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;题目：&lt;a href=&quot;http://codevs.cn/problem/1133/&quot;&gt;Link&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Accepted. 
#include &amp;lt;iostream&amp;gt;
#define Mod 10007;
using namespace std;

typedef struct {
    long long v0;  //当前值为0的个数
    long long v1;  //当前值为1的个数
    char ch;  //当前字符
} vertex;

vertex f[100000];

void merge_sum(int p) {
    int w0 = f[p-1].v0 * f[p].v0;
    int w1 = f[p-1].v0*f[p].v1+f[p-1].v1*f[p].v0+f[p-1].v1*f[p].v1;
    f[p-1].v0 = w0 % Mod;
    f[p-1].v1 = w1 % Mod; 
}

inline void merge_product(int p)  //处理当前的值和前一个值取'*'的操作
{
       int w0=f[p-1].v0*f[p].v0+f[p-1].v0*f[p].v1+f[p-1].v1*f[p].v0;
       int w1=f[p-1].v1*f[p].v1;
       f[p-1].v0=w0%Mod;
       f[p-1].v1=w1%Mod;
}

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    f[0].v0=f[0].v1=1;
    while (n--)
    {
          now++;   //新建一个空位读入新符号
          cin&amp;gt;&amp;gt;f[now].ch;
          f[now].v0=f[now].v1=1;  //初始化当前符号的前面的值(虽然')'除外,但也不影响)
          if (f[now].ch=='+')
          {
             if (f[now-1].ch=='*') //处理'*'
             {
                now--;
                merge_product(now);
                f[now]=f[now+1];
             }
             if (f[now-1].ch=='+') //处理'+'
             {
                now--;
                merge_sum(now);
                f[now]=f[now+1];
             }
          }
          if (f[now].ch=='*')
           if (f[now-1].ch=='*') //处理'*'
           {
              now--;
              merge_product(now);
              f[now]=f[now+1];
           }
          if (f[now].ch==')') //处理')'(比较麻烦)
          {
             now--;
             if (f[now].ch=='*')
             {
                merge_product(now);
                now--;
             }
             if (f[now].ch=='+')
             {
                merge_sum(now);
                now--;
             }
             now--;
             f[now].v0=f[now+1].v0;
             f[now].v1=f[now+1].v1;
             if (f[now].ch=='*')
             {
                merge_product(now);
                now--;
             }
          }
    }
    if (f[now].ch=='*')  //处理完了以后,可能还有残留的'*'和'+'
    {
       merge_product(now);
       now--;
    }
    if (f[now].ch=='+')
    {
       merge_sum(now);
       now--;
    }
    cout&amp;lt;&amp;lt;f[0].v0;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/noip2011-expression/</link>
                <guid>http://hsfzxjy.github.io/noip2011-%e8%a1%a8%e8%be%be%e5%bc%8f%e8%ae%a1%e7%ae%97</guid>
                <pubDate>2014-09-22T21:57:50+08:00</pubDate>
        </item>

        <item>
                <title>Extended和Double的奇怪问题</title>
                <description>&lt;p&gt;最近在做一个项目，其中有一段判断一个Extended浮点数是否为整数的代码。我用如下方式实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function IsInt(F: Extended): Boolean;
begin
  result := Trunc(F)-F = 0; //整数部分等于自身
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试了许多样例都过了，唯独这个没过：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IsInt(4.000000002*1000000000); //False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调试时发现： Trunc(F)居然等于4000000001！开始以为是精度的问题，找了许多资料也没能解决。后来将Extended换成了Double，就通过了。百思不得其解中。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/strange-extended-and-double-problem/</link>
                <guid>http://hsfzxjy.github.io/extended%e5%92%8cdouble%e7%9a%84%e5%a5%87%e6%80%aa%e9%97%ae%e9%a2%98</guid>
                <pubDate>2014-08-20T13:37:46+08:00</pubDate>
        </item>

        <item>
                <title>MySQLDump导出时不加锁</title>
                <description>&lt;p&gt;在SAE上进行应用开发时，常常需要导入数据库，这时候就需要用MySQLDump工具进行本地数据库导出。&lt;/p&gt;
&lt;p&gt;首先MySQLDump最基本的语法是这样的 &lt;code&gt;mysqldump &amp;lt;database_name&amp;gt;&lt;/code&gt;，执行之后可以在控制台上看到SQL源码。但我第一次尝试将导出的源码上传至SAE时SAE却报错，原因是SAE的数据库管理不支持LOCK和UNLOCK语句。曾有一段时间，我是手动一行行删除LOCK语句。。30多张表那叫一个蛋疼。。后来，我翻阅了mysqlDump的help文档，发现可以添加这么一个参数&lt;code&gt;--ADD-LOCKS=FALSE&lt;/code&gt;。几经尝试后发现果然没有LOCK语句了。 在此记录下整句命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysqldump --add-locks=FALSE -uroot -p &amp;lt;database_name&amp;gt; &amp;gt;example.sql
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/mysqldump-without-lock/</link>
                <guid>http://hsfzxjy.github.io/mysqldump%e5%af%bc%e5%87%ba%e6%97%b6%e4%b8%8d%e5%8a%a0%e9%94%81</guid>
                <pubDate>2014-08-19T17:50:37+08:00</pubDate>
        </item>

        <item>
                <title>窥视香港</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;用心灵窥视，用良知感悟，寻觅精神世界的失落。 ——题记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;地铁票&lt;/h2&gt;

&lt;p&gt;才刚到晚上八点，地铁站便已“门可罗雀”，偶尔一两个人从眼前晃过。偌大的站台，空虚着，萧索着——这并不像一个大城市的作风。&lt;/p&gt;

&lt;p&gt;紧攥着手中的地铁票，生怕它被风吹走了——香港真能信任人呵，地铁票制作得如此薄，如此简陋，一点也不“高科技”，难道就不怕有人造假？对于见惯了内地地铁票的我来说，实在值得琢磨。&lt;/p&gt;

&lt;h2&gt;电梯&lt;/h2&gt;

&lt;p&gt;“嘿，”同伴拍了拍我肩膀，轻声说，“你看……”&lt;/p&gt;

&lt;p&gt;我回头一看——顿时觉得糗大了。&lt;/p&gt;

&lt;p&gt;后面一排人都靠在扶梯右边有秩序地站着，整齐而不乱；而我——像往常一样靠在左边的扶手上，入迷地玩着手机……我“刷”地脸红了，立刻向右边挪了一步。&lt;/p&gt;

&lt;p&gt;“上下楼梯靠右边”，这是幼儿园就应该了解的常识。但我，作为一个中学生，却忘得一干二净，真是惭愧。但愿后面站着的人没有把我的做法放在心上。&lt;/p&gt;

&lt;p&gt;不过，既然手扶梯是单向的，为什么要让出左边的一半呢？两边都站满利用率不是更高吗？&lt;/p&gt;

&lt;p&gt;突然，身后传来一阵急促的脚步声——原来是一位“上班族”。只见他一手拎着包，一手扶着电梯扶手，气喘吁吁地从左边的通道跑下，很快，便消失在月台深处。&lt;/p&gt;

&lt;p&gt;原来如此，香港人的守秩序是为了有需要的人。&lt;/p&gt;

&lt;p&gt;电梯虽小，却折射出人生百相。&lt;/p&gt;

&lt;h2&gt;换乘&lt;/h2&gt;

&lt;p&gt;“金钟站到了。”&lt;/p&gt;

&lt;p&gt;透过车窗望去，外面黑压压地挤了一群人——想必这里应该是繁华地段吧。&lt;/p&gt;

&lt;p&gt;车门开了，车厢里的人涌了出去。但奇怪的是，他们并没有跑向楼梯或电梯，而是跑向了对面的一辆列车。&lt;/p&gt;

&lt;p&gt;按照内地人的思路，两辆相对的列车理应是开往相反方向的。难道很多人都坐错车了？要不怎么都想往回走。我顿生狐疑。&lt;/p&gt;

&lt;p&gt;仔细端详对面的那辆列车，无意间，我发现了一个奇怪之处：那辆车和我乘坐的这一辆根本就不是同一条线路的！这也太奇怪了！&lt;/p&gt;

&lt;p&gt;但仔细想想，这样的安排似乎也有他的合理之处。&lt;/p&gt;

&lt;p&gt;这里是靠近市中心的地方，客流量大，每天都有几百万人次的换乘量。把两条人们常坐的线路靠的近一点，从一定程度上可以减小换乘带来的麻烦。况且，坐错车的人只是极少数，的确没有必要把两条相反方向的线路靠在一起。&lt;/p&gt;

&lt;p&gt;繁华的都市，竟然也粗中有细，实为可贵。&lt;/p&gt;

&lt;h2&gt;路人&lt;/h2&gt;

&lt;p&gt;“劳驾……请问皇后大道东怎么走？”&lt;/p&gt;

&lt;p&gt;香港小巷密集，巷与巷之间又没有什么突出的不同之处，因此一不小心就会迷路。&lt;/p&gt;

&lt;p&gt;听说香港人有些排斥说普通话的游客，因此不会说粤语的我一直都不敢问路。但走到这个十字路口，我再也坚持不住了，只靠硬着头皮去问路。&lt;/p&gt;

&lt;p&gt;眼前的这位阿姨大概三十岁出头，拎着包，好像是一位刚下班的白领。她先是用奇怪的眼光打量我，看得我暗暗不安。几秒后，她终于开口了，用的是不很熟练的国语：“皇后大道东这么长，你具体要去哪？”&lt;/p&gt;

&lt;p&gt;这可把我问住了。“嗯……只要到那就行了……我只是想去走走。”&lt;/p&gt;

&lt;p&gt;这时，路对面的信号灯变绿了。我心里“咯噔”一下：不好，“救命稻草”可能要走了。可幸运的是，阿姨并没有要走的意思。她先问我有没有地图，在昏暗的路灯下，她艰难地从地图上找出了我们现在所处的位置。接着，她开始详细地讲解路线：需要乘哪些地铁，出了站后应该怎么走等等。经过了近5分钟的讲解，我终于把路线弄清了。&lt;/p&gt;

&lt;p&gt;“你会不会坐地铁啊？”临走前，阿姨还问我。&lt;/p&gt;

&lt;p&gt;“嗯，会的。我就是搭地铁来的。谢谢！”&lt;/p&gt;

&lt;p&gt;这时我才发现，对面的红绿灯已经变绿了两三次了。这要是在内地，对方非咒死你不可。&lt;/p&gt;

&lt;p&gt;还好，我在香港迷路了。&lt;/p&gt;

&lt;h2&gt;反思&lt;/h2&gt;

&lt;p&gt;都说社会主义社会比资本主义社会优越，但我一路走下来，却并不这么认为。&lt;/p&gt;

&lt;p&gt;看来，经济高速发展带来了很多问题。古老的中国，年轻的中国，还有许多地方需要学习。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/peeking-hongkong/</link>
                <guid>http://hsfzxjy.github.io/peeking-hongkong</guid>
                <pubDate>2013-07-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>最后的晚餐</title>
                <description>&lt;p&gt;又到了周日了，短暂的“回家之旅”也接近了尾声。每当这时，我心中总会泛起莫名的惆怅，有些焦虑，也有些恐慌。&lt;/p&gt;

&lt;p&gt;周日下午，每次，我都会睡到接近四点。没办法，家里的床，家里的阳光太舒服了。闹钟怎么叫都叫不醒。几次醒来，几次又昏昏沉沉地睡去。直到看到钟表的指针懒懒地爬向4，又想到还有许多作业没做，我这才不情愿地，懒懒地起床。&lt;/p&gt;

&lt;p&gt;或许是睡太久的缘故罢，起床后的一段时光中人还是晕乎乎的 。甚至洗把脸，静坐许久后，头仍是沉重的。但，没办法，作业还是要做的，我只得硬着头皮坐到书桌前。&lt;/p&gt;

&lt;p&gt;而大概这时，妈妈就开始张罗晚饭了。一周最后的晚饭。&lt;/p&gt;

&lt;p&gt;一般来说，她不问我想吃什么。或许是不想打扰疲惫的我，或许认为我吃什么都好，又或许是，她已经知道我想吃什么。但不管怎么样，每次的晚餐都是我想吃的。&lt;/p&gt;

&lt;p&gt;她想要的食材家里总是没有，因此每当这时，她总要去菜市场逛一圈。待回来时已经五点多了。在厨房里叮叮当当地忙活上一阵，六点出头，晚饭就上桌了。&lt;/p&gt;

&lt;p&gt;初三了，每个星期都有不同的烦恼。因此，周六总是快乐的，因为一周的烦恼已终结；而周日又总是心烦的，因为一周的新烦恼又开始了。&lt;/p&gt;

&lt;p&gt;但，带着烦恼吃饭，总是不太妥。毕竟，这是妈妈忙活了一个下午的杰作。&lt;/p&gt;

&lt;p&gt;面对一桌子好菜，我吃得很慢，很慢。&lt;/p&gt;

&lt;p&gt;电视在一旁嗡嗡地响着，放着妈妈喜欢看的八卦娱乐节目。我也陪着看。这样一来，吃饭速度就更慢了。一碗饭，一堆菜，好像怎么也吃不完。&lt;/p&gt;

&lt;p&gt;或许，不是我吃不完——&lt;/p&gt;

&lt;p&gt;毕竟，这是最后的晚餐了。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/the-last-dinner/</link>
                <guid>http://hsfzxjy.github.io/the-last-dinner</guid>
                <pubDate>2013-03-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>过路人</title>
                <description>&lt;p&gt;匆匆地走过街口，我只是一个过路人。&lt;/p&gt;

&lt;p&gt;×××，又快迟到了。我心里暗想，不禁加快了脚步。&lt;/p&gt;

&lt;p&gt;不远处有两个小女孩在玩耍——玩一把破扫把。其中一个骑在扫把上，像巫师一样跑来跑去。另一个却说：“不，应该这样！”一把抢过扫把抱在胸前，作弹吉他状。两个人不约而同地笑了起来。
周围行人匆匆——像我一样。但她们并不在乎，似乎这场演出不需要看客，又或者——她们自己便是看客。&lt;/p&gt;

&lt;p&gt;我不禁放慢了脚步。&lt;/p&gt;

&lt;p&gt;好久没看到这么天真的笑容了，有些欣喜，也有些惆怅。&lt;/p&gt;

&lt;p&gt;思绪一下又回到了多年以前， 当世界的一切都是我的玩具时。&lt;/p&gt;

&lt;p&gt;记得一年级时，我对电脑充满了好奇，但有没有机会见识一下真正的电脑，高科技只能存在于脑海里。那时，我经常和朋友在一起，用手上一切可获得的材料——纸板，绳子以及笔，再加上自己的想象来制作“电脑”。“电脑”功能和齐全，不仅有键盘、屏幕、时钟，甚至还有雷达、指南针等——当然，都是画的，但画得很认真。“电脑”是纸板做的，因此一折就断。但我们不在乎，仍乐此不疲地做着。尽管没人用，尽管只有我们俩在用。&lt;/p&gt;

&lt;p&gt;如今，电脑有了，可童年时的那种欢乐却远了。&lt;/p&gt;

&lt;p&gt;好想再回到那些年的时光，但时光一去不复返了。&lt;/p&gt;

&lt;p&gt;突然发现，这么多年我好像是匆匆走过。童年已远但我却仍在憧憬，是不是走得太麻木了呢？&lt;/p&gt;

&lt;p&gt;两个小女孩走远了，但她们银铃般的笑声却仍在回响着，回响着……&lt;/p&gt;

&lt;p&gt;作为生命的过路人，我不甘只当看客，我也要做演绎者。 &lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/passer-by/</link>
                <guid>http://hsfzxjy.github.io/passer-by</guid>
                <pubDate>2013-02-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>搬家有感</title>
                <description>&lt;p&gt;要搬家了，有喜，有忧。&lt;/p&gt;

&lt;p&gt;黄埔的老房子住了十几年了，说走就走，还真有点舍不得。毕竟，我在这度过了童年，度过了最难忘的时光。&lt;/p&gt;

&lt;p&gt;老房子冬暖夏凉，不是吹牛。十几年来，我在家没开过一次空调，一次暖气，可我仍健康。楼顶还有个天台，大晴时可以晒被子。这么得天独厚的地方，在市里不是随便能找到的。&lt;/p&gt;

&lt;p&gt;门前的体育馆修了补，补了修，终于还是被拆除了，准备建成商贸中心；屋后的大草地剃了长，长了剃，终于还是被拆除了，建起了20多层的居民楼。远处的“荒地”被开垦了，取而代之的是雄伟的图书馆；周围的“跳跳路”消失了，取而代之的是锃亮的柏油。一切都在变，但看久了也就有了感情，甩也甩不掉。&lt;/p&gt;

&lt;p&gt;三年前，邻居也是基友搬到了华景，我们的感情也冲淡了。如今三年后，我也要去华景，又要做邻居了。&lt;/p&gt;

&lt;p&gt;记得好多年以前，黄埔还有田，而且不只一两处，绿油油的一大片。一天中午和他一起溜出去乱逛，穿到别人田里捞鱼，顺手牵羊了几个番茄，结果被发现了…至今想起仍想发笑。可惜，田早己不在了，记忆中很“野”的黄埔也只能留在记忆中了。&lt;/p&gt;

&lt;p&gt;想想爸妈花了十多年的积蓄买了套比十年前还小的房子，心里总有些不爽。可经济在“发展”，也只能这样了。&lt;/p&gt;

&lt;p&gt;城市在变迁，我也将走出郊区，住进城里。多了几分便利，却也少了几分清静。&lt;/p&gt;

&lt;p&gt;梦中的自然呵，越来越远了……&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/sigh-for-house-moving/</link>
                <guid>http://hsfzxjy.github.io/sigh-for-house-moving</guid>
                <pubDate>2013-01-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>一个键盘钩子的写法，很实用</title>
                <description>&lt;h2&gt;0x00 前言&lt;/h2&gt;

&lt;p&gt;早就想写一个键盘监听器了，学校的电子阅览室设了Administrator屏障，想装软件什么的很麻烦，因此想截获管理员密码。。    &lt;/p&gt;

&lt;p&gt;花了大概一个星期编写了一个，效果还不错，因此来分享一下。。&lt;/p&gt;

&lt;h2&gt;0x01 基本概念&lt;/h2&gt;

&lt;p&gt;首先解释一下什么是键盘钩子：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;钩子（Hook）是Windows消息处理机制中的一个监视点，应用程序可以在这里安装一个子程序（钩子函数）以监视指定窗口某种类型的消息，所监视的窗口可以是其他进程创建的。当消息到达后，在目标窗口处理函数处理之前，钩子机制允许应用程序截获它进行处理。     &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SetWindowsHookEx函数可以把应用程序定义的钩子函数安装到系统中：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;n&quot;&gt;HHOOK&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetWindowsHookEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idHook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 指定钩子的类型&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HOOKPROC&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpfn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//钩子函数的地址。如果使用的是远程钩子，钩子函数必须放在一个DLL中。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HINSTANCE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hMod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//钩子函数所在DLL的实例句柄。如果是一个局部的钩子，该参数为NULL。&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;DWORD&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;dwThreadID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//指定要为哪个线程安装钩子。若该值为0被解释成系统范围内的。&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IdHook参数指定了要安装的钩子的类型，可以是下列取值之一：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WH_CALLWNDPROC      当目标线程调用SendMessage函数发送消息时，钩子函数被调用。&lt;/li&gt;
&lt;li&gt;WH_CALLWNDPROCRET                  当SendMessage发送的消息返回时，钩子函数被调用。&lt;/li&gt;
&lt;li&gt;WH_GETMESSAGE          当目标线程调用GetMessage或者PeekMessage时。&lt;/li&gt;
&lt;li&gt;WH&lt;em&gt;KEYBOARD              当从消息队列中查询WM&lt;/em&gt;KEYUP或WM_KEYDOWN消息时&lt;/li&gt;
&lt;li&gt;WH_MOUSE                      当调用从消息队列中查询鼠标事件消息&lt;/li&gt;
&lt;li&gt;WH_MSGFILTER              当对话框，菜单或滚动条要处理一个消息时，钩子函数被调用。该钩子是局部的，它是为哪些有自己消息处理过程的控件对象设计的。&lt;/li&gt;
&lt;li&gt;WH&lt;em&gt;SYSMSGFILTER       和WH&lt;/em&gt;MSGFILTER一样，只不过是系统范围的。&lt;/li&gt;
&lt;li&gt;WH_JOURNALRECORD 当Windows从硬件队列中获取消息时。&lt;/li&gt;
&lt;li&gt;WH_JOURNALPLAYBACK      当一个事件从系统的硬件输入队列中别请求时&lt;/li&gt;
&lt;li&gt;WH_SHELL                        当关于Windows外壳事件发生时，比如任务条需要重画它的按钮&lt;/li&gt;
&lt;li&gt;WH_CBT                            当基于计算机的训练（CBT）事件发生时。&lt;/li&gt;
&lt;li&gt;WH_FOREGROUNDIDLE Windows自己使用，一般应用程序很少使用。&lt;/li&gt;
&lt;li&gt;WH_DEBUG                      用来给钩子函数除错。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lpfn参数是钩子函数的地址。钩子安装后如果有消息发生，Windows将调用此参数所指向的函数。&lt;/p&gt;

&lt;p&gt;如果dwThreadId参数是0，或者指定一个由其他进程创建的线程ID，lpfn参数指向的钩子函数必须位于一个DLL中。这是因为进程的地址空间是相互隔离的，发生事件的进程不能调用其他进程地址空间的钩子函数。如果钩子函数的实现代码在DLL中，在相关事件发生时，系统会把这个DLL插入到发生事件的进程的地址空间，使它能够调用钩子函数。这种需要将钩子函数写入DLL以便挂钩其他进程事件的钩子称为&lt;strong&gt;远程钩子&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果dwThreadId参数指定一个由自身进程创建的线程ID，lpfn参数指向的钩子函数只要在当前进程中即可，不必非要写入DLL。这种挂钩属于自身进程事件的钩子称为局部钩子。&lt;/p&gt;

&lt;p&gt;hMod参数是钩子函数所在DLL的实例句柄，如果钩子函数不再DLL中，应将hMod设置为NULL。&lt;/p&gt;

&lt;p&gt;dwThreadId参数指定要与钩子函数相关联的线程ID号。如果设为0，那么钩子就是系统范围内的，即钩子函数将关联到系统内所有线程。&lt;/p&gt;

&lt;p&gt;要卸载钩子，可以调用UnhookWindowsHookEx函数。
 BOOL UnhookWindowsHookEx(HHOOK hhk); // hhk 为要卸载的钩子的句柄&lt;/p&gt;

&lt;p&gt;注意：安装钩子的代码可以在DLL模块中，也可以在主模块中，但是一般在DLL里实现它，主要是为了使程序更加模块化。&lt;/p&gt;

&lt;p&gt;既然我们要截获的是全局的按键消息，那么就应该将钩子放在DLL中。&lt;/p&gt;

&lt;p&gt;Windows钩子都有一个回调函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;LRESULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CALLBACK&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HookProc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WPARAM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPARAM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 处理该消息的代码 …..&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CallNextHookEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hHook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HookProc是应用程序的名称。nCode参数是Hook代码，钩子函数使用这个参数来确定任务，它的值依赖于Hook的类型。wParam和lParam参数的值依赖于Hook代码，但是它们典型的值是一些关于发送或者接收消息的信息。&lt;/p&gt;

&lt;p&gt;因为系统中可能会有多个钩子的存在，所以要调用那个CallNextHookEx函数把消息传到链中下一个钩子函数。hHook参数是安装钩子时得到的钩子句柄（SetWindowsHookEx的返回值）。&lt;/p&gt;

&lt;h2&gt;0x02 实现&lt;/h2&gt;

&lt;p&gt;有了这些知识，我们就可以开始编写：&lt;/p&gt;

&lt;p&gt;首先，先创建一个DLL Wizard，为了在主程序中创建钩子，我们需要键入以下代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InstallHook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hwnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;THandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;stdcall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;export&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetWindowsHookEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WH_JOURNALRECORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HookProc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//其中hook是一个HHOOK类型的全局变量，用来保存钩子句柄&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hWindow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hwnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//hWindow也是一个HWND类型的全局变量，用来保存主程序的窗口句柄，在后面要用到&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于DLL与主程序是独立的，所以DLL截获的消息需要发送到主窗口，这里采用的是发送消息，因此要保留主窗体句柄&lt;/p&gt;

&lt;p&gt;下面是卸载钩子代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnInstallHook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;stdcall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;export&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;UnhookWindowshookEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有回调函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HookProc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;longint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;wParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WPARAM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPARAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LRESULT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;stdcall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEventMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;keyState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TKeyState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HC_ACTION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PEventMsg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WM_KEYDOWN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WM_SYSKEYDOWN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keystate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoByte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;paramL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//得到键的虚拟键码&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keystate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bCapsLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetKeyState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VK_CAPITAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//得到CapsLock键状态&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keyState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bNumLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetKeyState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VK_NUMLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//得到Num Lock的状态&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keyState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bCtrl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetKeyState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VK_CONTROL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;$80000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;$80000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//得到Ctrl键的状态&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keyState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bAlt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetKeyState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VK_MENU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;$80000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;$80000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//得到Alt键的状态&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keyState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bShift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetKeyState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VK_SHIFT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;$80000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;$80000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//得到Shift键的状态&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keystate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetActiveWindow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//得到当前活动的窗口句柄&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keystate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//得到当前时间&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;SendMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hWindow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WM_MYMSG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//发给主窗口，WM_MYMSG为一个自定义消息，用于区别于其他消息&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CallNextHookEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//挂上下一个钩子&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中TKeyState定义为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TKeyState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;record&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;vKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;longint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;bCapsLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bNumLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bShift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bCtrl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bAlt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HWND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
               &lt;span class=&quot;nb&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TDateTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
             &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用于记录按键消息。&lt;/p&gt;

&lt;p&gt;最后将他们输出：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;exports&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;InstallHook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnInstallHook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HookProc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在主窗体Main.pas中写入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InstallHook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hwnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;THandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;stdcall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;external&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;Hookdll&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnInstallHook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;stdcall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;external&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;hookdll&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//静态链接函数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后调用时用&lt;code&gt;InstallHook(self.Handle);&lt;/code&gt;就可以安装钩子了。&lt;/p&gt;

&lt;p&gt;至此一个键盘监听器就写好了（详细参考CSDN资源：4428899）&lt;/p&gt;

&lt;h2&gt;0x03 后记&lt;/h2&gt;

&lt;p&gt;但是，这个程序还有一点缺陷，就是不能跨用户监听，即如果一台电脑中有多个用户，则用户A的监听器监听不到用户B的按键消息。&lt;/p&gt;

&lt;p&gt;我研究过，用户的实质是多个Desktop（即窗口工作站）同时运行（这也是虚拟桌面的工作原理）。我曾试图用CreateProcess()这个API将一个进程跨用户注入到另一个用户的空间中，虽说成功了，但一旦用户切换用户，所有的钩子都将停止，这也令我很苦恼，如果有兴趣的也可以研究一下。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/sharing-a-keyboard-hook-in-delphi/</link>
                <guid>http://hsfzxjy.github.io/sharing-a-keyboard-hook-in-delphi</guid>
                <pubDate>2012-09-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>学习Delphi面向对象编程的一点心得</title>
                <description>&lt;p&gt;以前我是完全不理解类的概念的，我只是把它当成一个Record来看，只不过它里面可以包含函数和过程罢了。但深入VCL学习后我才发现，原来面向对象的世界是这么精彩。&lt;/p&gt;

&lt;p&gt;大家都应该见过闹钟吧？随便给一个人一个闹钟，他都会用，不管是电子钟还是机械钟。但如果给一个人一堆零件，有谁能够将他们组装成一个闹钟呢？如果没有专业的知识，恐怕没有人会。为什么呢？为什么人人都会用但很少人懂得其内部结构呢？因为闹钟这一类事物提供一个标准的操作接口，如发条、钟表盘等。不管是液晶屏还是钟表盘，虽然他们形式不同，但他们都是用来显示时间的；同时，闹钟有隐藏了其内部实现的细节，用一层外壳将他们“封装”起来，使外界无法接触其内部，保持了内部的稳定性以及保证了机械运作的安全。这，便是类在生活中的一个真实缩影。&lt;/p&gt;

&lt;p&gt;类有三个特性：封装，继承，多态。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;“封装”就是隐藏内部实现细节。就像一个人，有为人知的一面，像外表，性格，衣着等；也有不为人知的一面，如其的心理状态以及复杂的内心世界及想法。在面向对象中，为人知的一面称为“接口”，即public段和published段的成员；不为人知的一面称为“私有成员”，即private和protected段（其实protected段也不完全是）。人们可以通过接口获得一些数据或完成一些操作，但不会影响类自己的数据的安全性、合法性和稳定性（当然，要保证类封装的合法性和合理性，像一辆只剩下骨架的汽车，连发动机都露出来了，有人敢去开吗？能保证发动机运行的稳定吗？）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“继承”就是“子承父业”。一个类可以继承另一个类的所有成员（不包括private段），并在其基础上增加属于自己的成员。这样做的好处是提高代码的可重用性。就像金属和铝的关系一样，铝是一种金属并且拥有金属的一切性质。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“多态”就是“多种状态”，即一个method，可以在本类中实现（static），也可以实现一部分，另一部分让子类去实现（dynamic或virtual），还可以不实现，让子类自己去发挥（abstract）。这极大地提升了类的灵活性，同时也真实地反应了现实生活：一个人不是万能的，他不能干所有的事，但或许他的后代可以，即“青出于蓝而胜于蓝”。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;类似乎是生活中的一个真实写照，世界上任何一个物体都满足这三个特性，无论是抽象的（如水果）还是具体的（如苹果）。这不仅仅是一种编程思想，还是对生活的一种总结，对生命的一种感悟，对世界的一种新认识。&lt;/p&gt;

&lt;p&gt;程序基于数，而数皆万物也。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/impression-for-delphi-OOP/</link>
                <guid>http://hsfzxjy.github.io/impression-for-delphi-OOP</guid>
                <pubDate>2012-09-29T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
