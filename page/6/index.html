<a id="rocket" href="#top" class="show"></a><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description"/><title>thoughts of hsfzxjy</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">thoughts of hsfzxjy</h1><a id="logo" href="/">thoughts of hsfzxjy</a><p class="description"></p><iframe src="https://ghbtns.com/github-btn.html?user=hsfzxjy&amp;type=follow&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px" class="github-btn"></iframe></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> 首页</i></a><a href="/categories/编程/"><i class="icon-code"> 码海拾贝</i></a><a href="/categories/杂感/"><i class="icon-life"> 五味杂感</i></a><a href="/about/"><i class="icon-about"> 我</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/uva12219-common-subexpression-elimination/">UVa12219 Common Subexpression Elimination</a></h2><div class="post-meta">2014-10-05</div><span data-thread-key="/uva12219-common-subexpression-elimination/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3371" target="_blank" rel="external">Link</a> 状态：<strong>Runtime Error</strong></p>
</blockquote>
<h2 id="前言">前言</h2><p>这题做的可真够久的，整整三个小时。但即便如此，还是只过了一部分的点，另一部分报运行时错误——估计是哈希表设计的不太好。但这确实是一道好题，因此，在睡觉前决定记录一下。</p>
<h2 id="分析">分析</h2><p>很容易便想到：用一个三元组$(x,y,z)$表示节点，表示内容为x的节点下跟着标号为y和z的左右子树。这样一来，一类相同的子树便可以唯一确定了，而不必每构造一棵子树就把整棵树遍历一遍。<br>对于三元组的储存，刚开始图方便，用了数组。查找也是用了$O(n)$的线性查找。磕磕碰碰写了两个多小时然后兴冲冲地提交，结果TLE了…………没办法，只好又花了半个小时写了一个哈希表，然后就是上文说过的情况了：<strong>Runtime Error204</strong>。可能是哈希数组过大的原因，日后再微调一下，今天实在是没有脑子了。</p>
<h2 id="Code">Code</h2><pre><code><span class="keyword">const</span>
  maxn = <span class="number">20000</span>;
<span class="keyword">type</span>
  NodeRec = <span class="keyword">record</span>
    Value: <span class="keyword">string</span>;
    l, r, <span class="keyword">index</span>: longint;
  <span class="keyword">end</span>;
  Node = <span class="keyword">record</span>
     left, right: longint;   <span class="comment">//Index of left and right child in the `tree` array, -1 for none.</span>
     Rec: NodeRec;
     <span class="keyword">index</span>: longint;
  <span class="keyword">end</span>;
  <span class="comment">//以下为哈希表的定义</span>
  _PNode = ^_Node;
  _Node = <span class="keyword">record</span>
    n: Node;
    next: _PNode;
  <span class="keyword">end</span>;

  HashTable = <span class="keyword">object</span>
    arr: <span class="keyword">array</span> [<span class="number">0</span>..maxn] <span class="keyword">of</span> _PNode;
    <span class="function"><span class="keyword">function</span> <span class="title">hash</span><span class="params">(n: NodeRec)</span>:</span> longint;
    <span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(n: Node)</span>;</span>
    <span class="function"><span class="keyword">procedure</span> <span class="title">clear</span>;</span>
    <span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(n: NodeRec)</span>:</span> longint;
  <span class="keyword">end</span>;

<span class="function"><span class="keyword">procedure</span> <span class="title">HashTable</span>.<span class="title">clear</span>;</span>
<span class="keyword">var</span>
  i: longint;
  p, q: _PNode;
<span class="keyword">begin</span>
  <span class="keyword">for</span> i := <span class="number">0</span> <span class="keyword">to</span> maxn <span class="keyword">do</span>
  <span class="keyword">begin</span>
    p := arr[i];
    <span class="keyword">while</span> p&lt;&gt;<span class="keyword">nil</span> <span class="keyword">do</span>
    <span class="keyword">begin</span>
      q := p^.next;
      dispose(p);
      p := q;
    <span class="keyword">end</span>;
  <span class="keyword">end</span>;
  fillchar(arr, sizeof(arr),<span class="number">0</span>);
<span class="keyword">end</span>;

<span class="function"><span class="keyword">function</span> <span class="title">cmp</span><span class="params">(r1, r2: NodeRec)</span>:</span> Boolean;
<span class="keyword">begin</span>
  cmp := (r1.l = r2.l) <span class="keyword">and</span> (r1.r = r2.r) <span class="keyword">and</span> (r1.Value = r2.Value);
<span class="keyword">end</span>;

<span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>.<span class="title">hash</span><span class="params">(n: NodeRec)</span>:</span> longint;
<span class="keyword">var</span>
  i: longint;
<span class="keyword">begin</span>
  hash := <span class="number">0</span>;
  <span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> length(n.Value) <span class="keyword">do</span>
    hash := (hash*<span class="number">5</span> + ord(n.Value[i]) - ord(<span class="string">'a'</span>)) <span class="keyword">mod</span> maxn;
  hash := (hash + n.l * <span class="number">10</span> + n.r * <span class="number">5</span>) <span class="keyword">mod</span> maxn;
<span class="keyword">end</span>;

<span class="function"><span class="keyword">procedure</span> <span class="title">HashTable</span>.<span class="title">add</span><span class="params">(n: Node)</span>;</span>
<span class="keyword">var</span>
  h: longint;
  p, q: _PNode;
<span class="keyword">begin</span>
  h := hash(n.rec);
  new(q);
  fillchar(q^, sizeof(_Node), <span class="number">0</span>);
  q^.next := arr[h];
  q^.n := n;
  arr[h] := q;
<span class="keyword">end</span>;

<span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>.<span class="title">find</span><span class="params">(n: NodeRec)</span>:</span> longint;
<span class="keyword">var</span>
  p: _PNode;
<span class="keyword">begin</span>
  find := -<span class="number">1</span>;
  p := arr[hash(n)];
  <span class="keyword">while</span> (p&lt;&gt;<span class="keyword">nil</span>) <span class="keyword">and</span> <span class="keyword">not</span> cmp(n, p^.n.rec) <span class="keyword">do</span> p := p^.next;
  <span class="keyword">if</span> p &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
    find := p^.n.<span class="keyword">index</span>;
<span class="keyword">end</span>;
<span class="comment">//哈系表定义结束</span>
<span class="keyword">var</span>
  inputs: Ansistring;
  _: longint;
  tree: <span class="keyword">array</span> [<span class="number">1</span>..<span class="number">50001</span>] <span class="keyword">of</span> Node;
  cur: longint;              <span class="comment">//The current pointer of the input string.</span>
  num: longint;              <span class="comment">//The current number of the `tree` array.</span>
  ls: longint;
  t: longint;
  tot: longint;
  ht: HashTable;

<span class="function"><span class="keyword">function</span> <span class="title">build</span>:</span> longint; <span class="comment">//建树</span>
<span class="keyword">label</span> lb;
<span class="keyword">var</span>
  rec: NodeRec;
  i,j,l,r: longint;
<span class="keyword">begin</span>
  l := <span class="number">0</span>;
  r := <span class="number">0</span>;
  fillchar(rec, sizeof(rec), <span class="number">0</span>);
  inc(tot);
  rec.<span class="keyword">index</span> := tot;
  <span class="keyword">while</span> (cur&lt;=ls) <span class="keyword">and</span> (inputs[cur] <span class="keyword">in</span> [<span class="string">'a'</span>..<span class="string">'z'</span>]) <span class="keyword">do</span>
  <span class="keyword">begin</span>
    rec.Value := rec.Value+inputs[cur];
    inc(cur);
  <span class="keyword">end</span>;
  <span class="keyword">if</span> cur&gt;ls <span class="keyword">then</span> <span class="keyword">goto</span> lb;    <span class="comment">//。。。这里被迫跳转控制流，由于实在不想多谢，就用了臭名昭著的label</span>
  <span class="keyword">if</span> inputs[cur] = <span class="string">'('</span> <span class="keyword">then</span>
  <span class="keyword">begin</span>
    inc(cur);
    l := build();
    rec.l := tree[l].rec.<span class="keyword">index</span>;
    inc(cur);
    r := build();
    rec.r := tree[r].rec.<span class="keyword">index</span>;
    inc(cur);
  <span class="keyword">end</span>;
  j := ht.find(rec);
  <span class="keyword">if</span> j&gt;<span class="number">0</span> <span class="keyword">then</span>
  <span class="keyword">begin</span>
    dec(tot);
    <span class="keyword">exit</span>(j);
  <span class="keyword">end</span>
  <span class="keyword">else</span>
  <span class="keyword">begin</span>
lb:
    inc(num);
    tree[num].left := l;
    tree[num].right := r;
    tree[num].rec := rec;
    tree[num].<span class="keyword">index</span> := num;
    ht.add(tree[num]);
    <span class="keyword">exit</span>(num);
  <span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="function"><span class="keyword">procedure</span> <span class="title">print</span><span class="params">(n: longint)</span>;</span>
<span class="keyword">begin</span>
  <span class="keyword">if</span> tree[n].rec.<span class="keyword">index</span> &gt; t <span class="keyword">then</span>
  <span class="keyword">begin</span>
    <span class="keyword">write</span>(tree[n].rec.Value);
    t := tree[n].rec.<span class="keyword">index</span>;
  <span class="keyword">end</span>
  <span class="keyword">else</span>
  <span class="keyword">begin</span>
    <span class="keyword">write</span>(tree[n].rec.<span class="keyword">index</span>);
    <span class="keyword">exit</span>;
  <span class="keyword">end</span>;
  <span class="keyword">if</span> tree[n].right = <span class="number">0</span> <span class="keyword">then</span>
    <span class="keyword">exit</span>;
  <span class="keyword">write</span>(<span class="string">'('</span>);
  print(tree[n].left);
  <span class="keyword">write</span>(<span class="string">','</span>);
  print(tree[n].right);
  <span class="keyword">write</span>(<span class="string">')'</span>);
<span class="keyword">end</span>;
<span class="keyword">begin</span>
  assign(input, <span class="string">'main.in'</span>); reset(input);
  assign(output, <span class="string">'main.out'</span>); rewrite(output);
  readln(_);
  fillchar(ht.arr, sizeof(ht.arr),<span class="number">0</span>);
  <span class="keyword">while</span> _&gt;<span class="number">0</span> <span class="keyword">do</span>
  <span class="keyword">begin</span>
    dec(_);
    readln(inputs);
    fillchar(tree, sizeof(tree), <span class="number">0</span>);
    ht.clear;
    ls := length(inputs);
    cur := <span class="number">1</span>;  num := <span class="number">0</span>; tot := <span class="number">0</span>;
    build;
    t := <span class="number">0</span>;
    print(num);
    writeln;
  <span class="keyword">end</span>;
  close(input); close(output);
<span class="keyword">end</span>.
</code></pre></div></div><div class="post"><h2 class="post-title"><a href="/uva536-recovery/">UVa536 Recovery</a></h2><div class="post-meta">2014-10-05</div><span data-thread-key="/uva536-recovery/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=7&amp;page=show_problem&amp;problem=477" target="_blank" rel="external">Link</a> 耗时: 0.012s</p>
</blockquote>
<h2 id="前言">前言</h2><p>真是疯玩了几天，脑袋都残了，一道弱智题做了近一个小时。</p>
<h2 id="Code">Code</h2><pre><code><span class="keyword">var</span>
    pre, mid, s: string;
    tree: <span class="keyword">array</span> [<span class="number">1</span>..<span class="number">50</span>] <span class="keyword">of</span> <span class="keyword">record</span>
        l, r: integer;
        ch: char;
    <span class="keyword">end</span>;
    cur: integer;
<span class="function"><span class="keyword">function</span> <span class="title">init</span>:</span> integer;
<span class="keyword">var</span>
    m: integer;
<span class="keyword">begin</span>
    readln(s);
    m := length(s) &gt;&gt; <span class="number">1</span> + <span class="number">1</span>;
    pre := <span class="keyword">Copy</span>(s, <span class="number">1</span>, m-<span class="number">1</span>);
    mid := <span class="keyword">Copy</span>(s, m+<span class="number">1</span>, length(s));
    init := m-<span class="number">1</span>;
<span class="keyword">end</span>;
<span class="function"><span class="keyword">function</span> <span class="title">build</span><span class="params">(l1, l2, r2: integer)</span>:</span> integer;
<span class="keyword">var</span>
    m,len: integer;
    t: integer;
<span class="keyword">begin</span>
    <span class="keyword">if</span> l2 &gt; r2 <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>); <span class="comment">//该子树不存在。**这个地方坑了我很久**</span>
    inc(cur);
    t := cur;      <span class="comment">// 这里也坑了我，当下面构造完左右子树后，cur已经变了，所以要缓存起来</span>
    build := t;  
    tree[t].ch := pre[l1]; 
    <span class="keyword">if</span> r2-l2 = <span class="number">0</span> <span class="keyword">then</span> <span class="comment">//叶节点</span>
        <span class="keyword">exit</span>;
    m := pos(pre[l1], mid); <span class="comment">//在中序遍历中找根节点</span>
    len := m - l2;
    tree[t].l := build(l1+<span class="number">1</span>, l2, m-<span class="number">1</span>); <span class="comment">//构造左子树</span>
    tree[t].r := build(l1+len+<span class="number">1</span>, m+<span class="number">1</span>, r2); <span class="comment">//构造右子树</span>
<span class="keyword">end</span>;
<span class="function"><span class="keyword">procedure</span> <span class="title">print</span><span class="params">(x: integer)</span>;</span>
<span class="keyword">begin</span>
    <span class="keyword">if</span> x = <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>;
    print(tree[x].l);
    print(tree[x].r);
    <span class="keyword">write</span>(tree[x].ch);
<span class="keyword">end</span>;
<span class="keyword">begin</span>
    assign(input, <span class="string">'main.in'</span>); reset(input);
    assign(output, <span class="string">'main.out'</span>); rewrite(output);
    <span class="keyword">while</span> <span class="keyword">not</span> eof <span class="keyword">do</span>
    <span class="keyword">begin</span>
        fillchar(tree, sizeof(tree), <span class="number">0</span>);
        cur := <span class="number">0</span>;
        build(<span class="number">1</span>, <span class="number">1</span>, init);
        print(<span class="number">1</span>);
        writeln;
    <span class="keyword">end</span>;
    close(input);
    close(output);
<span class="keyword">end</span>.
</code></pre></div></div><div class="post"><h2 class="post-title"><a href="/uva11582-colossal-fibonacci-numbers/">UVa11582 Colossal Fibonacci Numbers! &amp;&amp; 大数操作</a></h2><div class="post-meta">2014-10-01</div><span data-thread-key="/uva11582-colossal-fibonacci-numbers/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=27&amp;problem=2629&amp;mosmsg=Submission%20received%20with%20ID%2014290914" target="_blank" rel="external">Link</a> 耗时：0.139s</p>
</blockquote>
<h2 id="前言">前言</h2><p>这道题的主要思路就是打表，看看Fibonacci数列模n几个一循环。但由于这题给的数太大了，从而在细节上耗了很久。在此记录一下：</p>
<pre><code><span class="tag">var</span>
    x<span class="value">: qword;</span>
    y<span class="value">: longint;</span>
begin
    x <span class="value">:= <span class="number">1</span>&lt;&lt;<span class="number">64</span>-<span class="number">1</span>;</span>
    y <span class="value">:= <span class="number">100</span>;</span>
    x <span class="value">:= x mod y;</span> <span class="comment">//报错201</span>
    x <span class="value">:= x mod <span class="function">qword</span>(y);</span> <span class="comment">//正确</span>
end.
</code></pre><h2 id="Code">Code</h2><pre><code><span class="keyword">var</span>
    a,b: qword;
    _, n, i, k, cnt: longint;
    f: <span class="keyword">array</span> [<span class="number">1</span>..<span class="number">1000000</span>] <span class="keyword">of</span> longint;

<span class="function"><span class="keyword">function</span> <span class="title">superMod</span><span class="params">(a, b: qword; m: longint)</span>:</span> longint;
<span class="keyword">var</span>
    x: qword;
<span class="keyword">begin</span>
    <span class="keyword">if</span> b = <span class="number">0</span> <span class="keyword">then</span>
        <span class="keyword">exit</span>(<span class="number">1</span>);
    x := superMod(a, b <span class="keyword">shr</span> <span class="number">1</span>, m);
    superMod := x * x <span class="keyword">mod</span> m;
    <span class="keyword">if</span> odd(b) <span class="keyword">then</span>
        superMod := superMod * a <span class="keyword">mod</span> m;
<span class="keyword">end</span>;

<span class="keyword">begin</span>
    assign(input, <span class="string">'main.in'</span>); reset(input);
    assign(output, <span class="string">'main.out'</span>); rewrite(output);
    readln(_);
    <span class="keyword">while</span> _ &gt; <span class="number">0</span> <span class="keyword">do</span>
    <span class="keyword">begin</span>
        dec(_);
        readln(a, b, n);
        <span class="keyword">if</span> a = <span class="number">0</span> <span class="keyword">then</span>
        <span class="keyword">begin</span>
            writeln(<span class="number">0</span>);
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>;
        <span class="keyword">if</span> n = <span class="number">1</span> <span class="keyword">then</span>
        <span class="keyword">begin</span>
            writeln(<span class="number">0</span>);
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>;
        f[<span class="number">1</span>] := <span class="number">1</span>;
        f[<span class="number">2</span>] := <span class="number">1</span>;
        cnt := <span class="number">2</span>;
        <span class="keyword">while</span> <span class="keyword">not</span> ((f[cnt-<span class="number">1</span>] = <span class="number">1</span>) <span class="keyword">and</span> (f[cnt] = <span class="number">0</span>)) <span class="keyword">do</span>
        <span class="keyword">begin</span>
            inc(cnt);
            f[cnt] := (f[cnt-<span class="number">1</span>] + f[cnt-<span class="number">2</span>]) <span class="keyword">mod</span> n;
        <span class="keyword">end</span>;
        <span class="comment">//while x &gt; int64(1 &lt;&lt;60) do</span>
        <span class="comment">//    x := x - int64((cnt &lt;&lt; 59));</span>
        a := a <span class="keyword">mod</span> qword(cnt);
        k := superMod(a, b, cnt);
        writeln(f[k]);
    <span class="keyword">end</span>;
    close(output); close(input);
<span class="keyword">end</span>.
</code></pre></div></div><div class="post"><h2 class="post-title"><a href="//extended-gcd-algorithm//">扩展欧几里得算法</a></h2><div class="post-meta">2014-10-01</div><span data-thread-key="//extended-gcd-algorithm//" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>今天开始学习数论方面的算法。这部分在NOIP中并不常出现，即使出现了也不会像高联这么难（。。。）。</p>
</blockquote>
<h2 id="什么是扩展欧几里得算法">什么是扩展欧几里得算法</h2><p>所谓欧几里得算法，实际上就是辗转相除法——求两个数最大公约数的一种高效算法。而扩展欧几里得算法则是来源于于一类方程的解决：</p>
<p>$$ax+by=gcd(a,b)$$<br>这有点像是<strong>裴蜀定理</strong>的一般形式。和裴蜀定理类似，这类方程也有无数多个整数解。如何高效率地求得它的一组特解呢？</p>
<h2 id="代码"><strong>代码</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure gcd_ex(a, b: longint; var d: longint; var x, y: longint);&#10;begin&#10;    if b = 0 then&#10;    begin&#10;        d := a;&#10;        x := 1;&#10;        y := 0;&#10;        exit;&#10;    end;&#10;    gcd_ex(b, a mod b, d, y, x); //&#37325;&#35201;&#10;    y := y-(a div b) * x;&#10;end;</span><br></pre></td></tr></table></figure>
<h2 id="详解"><strong>详解</strong></h2><p>乍一看，算法似乎和一般欧几里得算法很是相似：都是递归实现，参数传递过程中都体现了“辗转相除”的思想。那为什么这个算法是正确的呢？<br>这里先解释一下参数：</p>
<ul>
<li>a：方程中的参数a</li>
<li>b：方程中的参数b</li>
<li>d：即<code>gcd(a,b)</code>。由于和辗转相除法的相似性，在这里最大公约数也可以“顺便”算出。当然，去掉也无大碍</li>
<li>x&amp;y：方程的一组特解(x, y)</li>
</ul>
<p>下面解释标注了<strong>重要</strong>的那行代码。<br>假设方程 $ax+by=gcd(a,b)$ 有一组特解$(x_0,y_0)$。则有$ax_0+by_0=gcd(a,b)$。</p>
<p>由最大公约数原理可知：$gcd(a,b)=gcd(b, a\ mod\ b)$。从而有$ax_0+by_0=gcd(b,a\ mod\ b)$。</p>
<p>又方程：$bx+(a\ mod\ b)y=gcd(b,a\ mod\ b)$一定有整数解，设其为$(x_1,y_1)$。则有</p>
<p>$$ax_0+by_0=gcd(b,a\ mod\ b)=bx_1+(a\ mod\ b)y_1$$即$$ax_0+by_0=bx_1+(a-(a\ div\ b)*b)y_1$$即$$a(x_0-y_1)=b(x_1-(a\ div\ b)y_1-y_0)$$由恒等原理可知：$$x_0=y_1$$$$y_0=x_1-(a\ div\ b)y_1$$。</p>
<p>因此，当$a,b\neq0$时，$x,y$的值可以递归求得。递归边界为：$b=0$时$x=1,y=0$。</p>
<p>注意到上面的算法用到了一个技巧：在递归传参数的时候将y,x调换了。这样做的好处是节省了一个中间变量用来储存$y_1$，否则在计算$y_0$时$y_1$也被覆盖了。从而使算法更加的精简。</p>
<h2 id="应用"><strong>应用</strong></h2><ul>
<li>计算几何中求整点的问题</li>
<li>求一元一次同余方程$a\equiv b\pmod{m}$的一组特解。（即方程$ax+my=b$的一组特解）</li>
</ul>
</div></div><div class="post"><h2 class="post-title"><a href="/uva10285-cake-slicing/">UVa10285 Cake Slicing</a></h2><div class="post-meta">2014-10-01</div><span data-thread-key="/uva10285-cake-slicing/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=825&amp;page=show_problem&amp;problem=4504" target="_blank" rel="external">Link</a>  耗时：1.825s</p>
</blockquote>
<p>这道题做的可真够久的：前前后后加起来将近有两个小时，因此当AC的那一刻，自己心中还是挺自豪的。</p>
<p>事实上，这是一道复杂一点的区间型动态规划，之所以说“复杂”，是因为它的状态转移是<strong>二维</strong>的：切蛋糕既可以横切，也可以纵切。由此我想到了分治算法：</p>
<blockquote>
<p>假设一个矩形它所需要切的刀数是f，则f可以由组成该矩形的小矩形的f值决定。</p>
</blockquote>
<p>因此，这个问题具有最优子结构。由于每个状态为一个矩形，因此需要4个维度来记录状态（及左上、右下两个顶点）。下面是横切时的状态转移方程，纵切时同理可得：</p>
<blockquote>
<p>f(up, down, left, right) = min{f(up, i, left, right) + f(i, down, left, right) + right - left} (i = up + 1 .. down -1)</p>
</blockquote>
<p>Code:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="label">$R</span>-&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">INF</span> = maxint div 5; <span class="comment">//正无穷</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    f: array [0..20, 0..20, 0..20, 0..20] of integer;</span><br><span class="line">    cherries: array [1..500, 1..2] of integer;</span><br><span class="line">    map: array [0..20, 0..20] of boolean;</span><br><span class="line">    <span class="keyword">n</span>, <span class="keyword">m</span>, i, k: integer;</span><br><span class="line"></span><br><span class="line">function <span class="literal">min</span>(x, y: integer): integer; inline;</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">if</span> x&amp;lt;y then <span class="keyword">exit</span>(x) <span class="keyword">else</span> <span class="keyword">exit</span>(y);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">function cherryin(<span class="keyword">u</span>, <span class="keyword">d</span>, <span class="keyword">l</span>, r: integer): integer; inline; <span class="comment">//判断矩形内有没有樱桃</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    i, j: integer;</span><br><span class="line">begin</span><br><span class="line">    cherryin := 0;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">u</span>+1 to <span class="keyword">d</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">l</span>+1 to r <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> map[i, j] then</span><br><span class="line">            begin</span><br><span class="line">                inc(cherryin);</span><br><span class="line">                <span class="keyword">if</span> cherryin = 2 then <span class="keyword">exit</span>;</span><br><span class="line">            end;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">function dp(<span class="keyword">u</span>, <span class="keyword">d</span>, <span class="keyword">l</span>, r: integer): integer;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    b: integer;</span><br><span class="line">    i: integer;</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">if</span> f[<span class="keyword">u</span>, <span class="keyword">d</span>, <span class="keyword">l</span>, r] &amp;lt;&amp;gt; -1 then</span><br><span class="line">        <span class="keyword">exit</span>(f[<span class="keyword">u</span>,<span class="keyword">d</span> , <span class="keyword">l</span>, r]);</span><br><span class="line">    b := cherryin(<span class="keyword">u</span>, <span class="keyword">d</span>, <span class="keyword">l</span>, r);</span><br><span class="line">    <span class="keyword">if</span> b = 1 then</span><br><span class="line">    begin</span><br><span class="line">        f[<span class="keyword">u</span>, <span class="keyword">d</span>, <span class="keyword">l</span>, r] := 0;</span><br><span class="line">        <span class="keyword">exit</span>(0);</span><br><span class="line">    end;</span><br><span class="line">    <span class="keyword">if</span> b = 0 then</span><br><span class="line">    begin</span><br><span class="line">        f[<span class="keyword">u</span>, <span class="keyword">d</span>, <span class="keyword">l</span>, r] := <span class="keyword">INF</span>;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="keyword">INF</span>);</span><br><span class="line">    end;</span><br><span class="line">    dp := <span class="keyword">INF</span>;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">u</span>+1 to <span class="keyword">d</span>-1 <span class="keyword">do</span></span><br><span class="line">        dp := <span class="literal">min</span>(dp, dp(<span class="keyword">u</span>, i, <span class="keyword">l</span>, r)+dp(i, <span class="keyword">d</span>, <span class="keyword">l</span>, r)+r-<span class="keyword">l</span>);</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">l</span>+1 to r-1 <span class="keyword">do</span></span><br><span class="line">        dp := <span class="literal">min</span>(dp, dp(<span class="keyword">u</span>, <span class="keyword">d</span>, <span class="keyword">l</span>, i)+dp(<span class="keyword">u</span>, <span class="keyword">d</span>, i, r)+<span class="keyword">d</span>-<span class="keyword">u</span>);</span><br><span class="line">    f[<span class="keyword">u</span>, <span class="keyword">d</span>, <span class="keyword">l</span>, r] := dp;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    _: integer;</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">    assign(<span class="keyword">input</span>, 'main.<span class="keyword">in</span>');reset(<span class="keyword">input</span>);</span><br><span class="line">    assign(output, 'main.<span class="keyword">out</span>');rewrite(output);</span><br><span class="line">    _ := 0;</span><br><span class="line">    readln(<span class="keyword">n</span>, <span class="keyword">m</span>, k);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">n</span>&amp;gt;0 <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        inc(_);</span><br><span class="line">        fillchar(map, sizeof(map), 0);</span><br><span class="line">        fillchar(f, sizeof(f), -1);</span><br><span class="line">        <span class="keyword">for</span> i := 1 to k <span class="keyword">do</span></span><br><span class="line">        begin</span><br><span class="line">            readln(cherries[i, 1], cherries[i, 2]);</span><br><span class="line">            map[cherries[i, 1], cherries[i, 2]] := true;</span><br><span class="line">        end;</span><br><span class="line">        writeln('Case ',_,': ', dp(0,<span class="keyword">n</span>,0,<span class="keyword">m</span>));</span><br><span class="line">        readln(<span class="keyword">n</span>, <span class="keyword">m</span>, k);</span><br><span class="line">    end;</span><br><span class="line">    <span class="keyword">close</span>(<span class="keyword">input</span>);<span class="keyword">close</span>(output);</span><br><span class="line">end.</span><br></pre></td></tr></table></figure></div></div><div class="post"><h2 class="post-title"><a href="/uva10285-longest-run-on-a-snowboard/">UVa10285 Longest Run on a Snowboard</a></h2><div class="post-meta">2014-09-29</div><span data-thread-key="/uva10285-longest-run-on-a-snowboard/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=14&amp;problem=1226&amp;mosmsg=Submission%20received%20with%20ID%2014282250" target="_blank" rel="external">Link</a> 耗时：0.028s</p>
</blockquote>
<p>一道简单的动态规划，主要思路就是：</p>
<blockquote>
<p><strong>用f[i,j]表示到达(i,j)的最长路径的长度。</strong>找到每个最高点，从其开始向四周的低处搜索。如果该点已搜过并且f值大于当前长度则退出回溯。直到达到某个最低点为止。</p>
</blockquote>
<p>不多说了，直接上代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const&#10;    delta :array [1..4, 1..2] of integer = ((-1, 0), (1, 0), (0, 1), (0, -1)); //&#22235;&#20010;&#26041;&#21521;&#21521;&#37327;&#10;var&#10;    _: Integer;&#10;    name: string;&#10;    n, m, i, j, x: Integer;&#10;    ans: longint;&#10;    map: array [0..101, 0..101] of integer;&#10;    f: array [1..100, 1..100] of longint;&#10;&#10;function max(x, y: longint): longint; inline;&#10;begin&#10;    if x&#38;gt;y then exit(x) else exit(y);&#10;end;&#10;&#10;function can(x, y: integer): Boolean; inline; //&#21028;&#26029;&#26159;&#21542;&#26159;&#26368;&#39640;&#28857;&#10;var&#10;    i: Integer;&#10;    tx, ty: integer;&#10;begin&#10;    can := true;&#10;    for i := 1 to 4 do&#10;    begin&#10;        tx := x + delta[i, 1];&#10;        ty := y + delta[i, 2];&#10;        can := can and (map[x, y] &#38;gt;= map[tx, ty]);&#10;        if not can then break;&#10;    end;&#10;end;&#10;&#10;procedure dp(x, y: integer; len: longint); //&#22238;&#28335;&#36827;&#34892;&#21160;&#24577;&#35268;&#21010;&#10;var&#10;    i: Integer;&#10;    tx, ty: integer;&#10;begin&#10;    inc(len);&#10;    if f[x, y] &#38;gt; len then exit;&#10;    f[x, y] := len;&#10;    ans := max(ans, len);&#10;    for i := 1 to 4 do&#10;    begin&#10;        tx := delta[i, 1] + x;&#10;        ty := delta[i, 2] + y;&#10;        if (tx = 0) or (tx &#38;gt; n) or (ty = 0) or (ty &#38;gt; m) then continue;&#10;        if map[x, y] &#38;lt;= map[tx, ty] then continue;&#10;        dp(tx, ty, len);&#10;    end;&#10;end;&#10;&#10;procedure ReadAndProcessName; //&#22788;&#29702;&#37027;&#34892;&#35813;&#27515;&#30340;&#21517;&#23383;&#65281;&#65281;&#10;var&#10;    s: string;&#10;    i: integer;&#10;begin&#10;    readln(s);&#10;    i := 1;&#10;    name := &#39;&#39;;&#10;    n := 0;&#10;    m := 0;&#10;    while s[i] &#38;lt;&#38;gt; &#39; &#39; do&#10;    begin&#10;        name := name + s[i];&#10;        inc(i);&#10;    end;&#10;    inc(i);&#10;    while s[i] &#38;lt;&#38;gt; &#39; &#39; do&#10;    begin&#10;        n := n * 10 + ord(s[i]) - ord(&#39;0&#39;);&#10;        inc(i);&#10;    end;&#10;    inc(i);&#10;    while i &#38;lt;= length(s) do&#10;    begin&#10;        m := m * 10 + ord(s[i]) - ord(&#39;0&#39;);&#10;        inc(i);&#10;    end;&#10;end;&#10;&#10;begin&#10;    assign(input, &#39;main.in&#39;);reset(input);&#10;    assign(output, &#39;main.out&#39;);rewrite(output);&#10;    readln(_);&#10;    while _&#38;gt;0 do&#10;    begin&#10;        dec(_);&#10;        fillchar(map, sizeof(map), 0);&#10;        ReadAndProcessName;&#10;&#10;        for i := 1 to n do&#10;            for j := 1 to m do&#10;            begin&#10;                read(x);&#10;                map[i, j] := x+1;&#10;            end;&#10;        readln;&#10;&#10;        fillchar(f, sizeof(f), 0);&#10;        ans := 0;&#10;        for i := 1 to n do&#10;            for j := 1 to m do&#10;                if can(i, j) then&#10;                    dp(i, j, 0);&#10;        writeln(name, &#39;: &#39;, ans);&#10;    end;&#10;    close(input);close(output);&#10;end.</span><br></pre></td></tr></table></figure>
</div></div><div class="post"><h2 class="post-title"><a href="/ubuntu-suddenly-no-wifi/">关于Ubuntu突然无法连接Wifi的解决方案</a></h2><div class="post-meta">2014-09-27</div><span data-thread-key="/ubuntu-suddenly-no-wifi/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>事实上我也不知道发生了什么，大概是几天前插了“小度Wifi”的缘故。没有任何征兆地，Wifi就用不了了。 其实我也不知道原理，大概是某个驱动被刷掉了。</p>
</blockquote>
<p>下面是从网上找来的答案：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wicd-daemon</span><br></pre></td></tr></table></figure>
<p>做个记录。</p>
</div></div><div class="post"><h2 class="post-title"><a href="/uva12186-another-crisis-dynamic-arrays-in-pascal/">UVa12186 Another Crisis &amp;&amp; [Dynamic Arrays in Pascal]</a></h2><div class="post-meta">2014-09-27</div><span data-thread-key="/uva12186-another-crisis-dynamic-arrays-in-pascal/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=243&amp;page=show_problem&amp;problem=3338" target="_blank" rel="external">Link</a> 耗时：0.586s </p>
</blockquote>
<p>昨晚做的太急了，没时间写总结，正好下午有空，补上。</p>
<p>这是一道典型的树形动态规划，不是很难，但十分坑语言。思路大致如下：</p>
<p>对于第i个节点，用d(i)表示其上诉所需的最小工人数。若i为叶节点，则d(i)=1；否则，遍历求出i的子节点所对应的d值，并由小到大排序，取出最小的几个相加，即为d(i)。</p>
<p>很容易想到用递归来实现。但对于“子节点的d值的排序”实现起来却十分困难：因为事先不知道有多少个数。当然啦，如果是C++组，用vector可以轻松搞定，可至于P党，实现起来却难上加难。思来想去，决定试试Pascal的动态数组。磕磕碰碰调了近1个小时，终于AC了。</p>
<p>Code:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Accepted&#10;var&#10;    tree: array [0..100000] of array of int64;&#10;    T: Integer;&#10;    f: array [0..100000] of int64;&#10;    i,l,n,x:longint;&#10;&#10;function min(x,y: int64): int64;&#10;begin&#10;    if x&#38;lt;y then exit(x) else exit(y);&#10;end;&#10;&#10;procedure sort(var arr: array of int64;l,r:longint); overload;&#10;var&#10;  i,j:longint;&#10;  m,t: int64;&#10;begin&#10;  i := l;&#10;  j := r;&#10;  m := arr[(l+r) &#38;gt;&#38;gt; 1];&#10;  repeat&#10;    while arr[i]&#38;lt;m do inc(i);&#10;    while arr[j]&#38;gt;m do dec(j);&#10;    if i&#38;lt;=j then&#10;    begin&#10;      t := arr[i];&#10;      arr[i] := arr[j];&#10;      arr[j] := t;&#10;      inc(i);&#10;      dec(j);&#10;    end;&#10;  until i&#38;gt;j;&#10;  if i&#38;lt;r then sort(arr, i, r);&#10;  if l&#38;lt;j then sort(arr, l, j);&#10;end;&#10;&#10;procedure sort(var arr: array of int64); overload;&#10;begin&#10;  sort(arr, low(arr), high(arr));&#10;end;&#10;function dp(x: longint): int64;&#10;var&#10;  arr: array of int64;&#10;  l,i, num: longint;&#10;begin&#10;    if f[x] &#38;lt;&#38;gt; 0 then&#10;    begin&#10;        dp := f[x];&#10;        exit;&#10;    end;&#10;    if length(tree[x]) = 0 then&#10;    begin&#10;      dp := 1;&#10;      f[x] := 1;&#10;      exit;&#10;    end;&#10;    l := length(tree[x]);&#10;    SetLength(arr, l);&#10;    for i := Low(tree[x]) to High(Tree[x]) do&#10;      arr[i] := dp(tree[x][i]);&#10;    Sort(arr);&#10;    num := (l*T-1) div 100+1;&#10;    for i := Low(arr) to num-1 do&#10;      f[x] := f[x] + arr[i];&#10;    dp := f[x];&#10;end;&#10;&#10;begin&#10;    assign(input, &#39;main.in&#39;);reset(input);&#10;    assign(output,&#39;main.out&#39;);rewrite(output);&#10;    readln(n, T);&#10;    while n&#38;gt;0 do&#10;    begin&#10;        fillchar(f, sizeof(f), 0);&#10;        fillchar(tree, sizeof(tree), 0);&#10;        for i := 1 to n do&#10;        begin&#10;            read(x);&#10;            SetLength(tree[x], length(tree[x])+1);&#10;            tree[x][high(tree[x])] := i;&#10;        end;&#10;        readln;&#10;        dp(0);&#10;        writeln(f[0]);&#10;        readln(n, T);&#10;    end;&#10;    close(input); close(output);&#10;end.</span><br></pre></td></tr></table></figure>
<h2 id="Dynamic_Arrays">Dynamic Arrays</h2><p>这里，再总结一下动态数组的用法。</p>
<ol>
<li>定义：<code>a: array of [type];</code></li>
<li>设置长度： <code>SetLength(a, 10);</code></li>
<li>长度加一： <code>SetLength(a, Length(a)+1);</code></li>
<li>取得最大、最小下标： <code>High(a)</code>, <code>Low(a)</code></li>
</ol>
<p>事实上，从<a href="http://freepascal.org/docs-html/ref/refsu18.html#x42-480003.3.1" target="_blank" rel="external">1.1</a>版本开始FPC就支持Dynamic Arrays了。所以在NOIP竞赛中我们大可放心使用。</p>
</div></div><div class="post"><h2 class="post-title"><a href="/uva-11584-partitioning-by-palindromes/">UVa11584 Partitioning by Palindromes</a></h2><div class="post-meta">2014-09-24</div><span data-thread-key="/uva-11584-partitioning-by-palindromes/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>这是一道区间型DP，转移方程很简单，但在实现的过程中却遇见了很多坑，在此记录一下。 链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=27&amp;problem=2631&amp;mosmsg=Submission%20received%20with%20ID%2014256745&quot;" target="_blank" rel="external">Link</a> 耗时：0.368s</p>
</blockquote>
<p>容易想到，前i个数的划分情况可以由1,2,3…,i-1的划分情况来决定。因此很容易得到状态转移方程：</p>
<blockquote>
<p>d[i] = min(d[i], d[j]+1) //j = 0, 1, 2…n-1 并且 s[j+1, i]为回文串，初始条件：d[i] = i。</p>
</blockquote>
<p><code>d[i]</code>表示前i项的最小划分。这样一来状态转移的复杂度就为O($n^2$)。</p>
<p>但状态转移的判断呢？“回文串”是一个复杂的条件，判断一个串是否为回文串需要将该串至少遍历一遍。这样一来时间复杂度就上升为O($n^3$)了。而事实上在这种算法中有许多无谓的计算，因此我们可以先对字符串进行预处理：用huiwen[i,j]表示s[i,j]是否为回文串（奇怪的名字。。。）。如此一来，时间复杂度就降为O($n^2$)了。</p>
<p>Code：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var&#10;    s: AnsiString;&#10;    n, _, i, j, l: integer;&#10;    huiwen: array [1..1000, 1..1000] of boolean; //s[i,j]&#26159;&#21542;&#20026;&#22238;&#25991;&#20018;&#10;    dp: array [0..1000] of integer; //&#19968;&#23450;&#20174;0&#24320;&#22987;&#65292;&#21542;&#21017;&#24403;&#25972;&#20018;&#20026;&#22238;&#25991;&#20018;&#26102;&#23601;&#32771;&#34385;&#19981;&#21040;&#20102;&#12290;&#10;&#10;function min(x,y: integer): integer;&#10;begin&#10;    if x&#38;lt;y then exit(x) else exit(y);&#10;end;&#10;&#10;procedure process(i,j: integer); //&#23545;&#22238;&#25991;&#20018;&#36827;&#34892;&#39044;&#22788;&#29702;&#10;var&#10;    mid: Integer;&#10;    x,y: integer;&#10;begin&#10;    if j = i then&#10;    begin&#10;        huiwen[i,j] := true;&#10;        exit;&#10;    end;&#10;    mid := i + (j-i+1) shr 1;&#10;    x := i;&#10;    y := j;&#10;    while (x &#38;lt;= mid) and (s[x] = s[y]) do&#10;    begin&#10;        inc(x);&#10;        dec(y);&#10;    end;&#10;    huiwen[i, j] := x &#38;gt; mid;&#10;end;&#10;&#10;begin&#10;    //assign(input, &#39;main.in&#39;); reset(input);&#10;    //assign(output, &#39;main.out&#39;); rewrite(output);&#10;    readln(n);&#10;    for _ := 1 to n do&#10;    begin&#10;        readln(s);&#10;        l := length(s);&#10;        //Pre-process&#10;        fillchar(huiwen, sizeof(huiwen), 0);&#10;        for i := 1 to l do&#10;            for j := i to l do //&#19968;&#23450;&#26159;&#20174;i&#24320;&#22987;&#65292;&#36825;&#20010;&#38169;&#21345;&#20102;&#25105;&#24456;&#20037;&#12290;&#10;                process(i, j);&#10;        //DP&#10;        for i := 1 to l do&#10;        begin&#10;            dp[i] := i;&#10;            for j := 0 to i-1 do&#10;                if huiwen[j+1, i] then&#10;                    dp[i] := min(dp[i], dp[j]+1);&#10;        end;&#10;        write(dp[l]);&#10;        &#123;if _ &#38;lt;&#38;gt;n then &#125;writeln; //&#21520;&#27133;&#19968;&#19979;&#65306;&#19968;&#24320;&#22987;&#25105;&#36824;&#35880;&#24910;&#22320;&#21152;&#19978;&#36825;&#21477;&#20197;&#36991;&#20813;&#34892;&#26411;&#22238;&#36710;&#65292;&#27809;&#24819;&#21040;UVa&#23621;&#28982;&#25253;&#38169;&#20102;&#12290;&#12290;&#30475;&#26469;UVa&#30340;&#27604;&#36739;&#31639;&#27861;&#36824;&#26377;&#24453;&#25913;&#36827;&#21834;&#12290;&#10;    end;&#10;&#10;    //close(input);close(output);&#10;end.</span><br></pre></td></tr></table></figure></div></div><div class="post"><h2 class="post-title"><a href="/uva437-the-tower-of-babylon/">UVa437 The Tower of Babylon</a></h2><div class="post-meta">2014-09-23</div><span data-thread-key="/uva437-the-tower-of-babylon/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>链接：<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=6&amp;page=show_problem&amp;problem=378" target="_blank" rel="external">The Tower of Babylon</a> 耗时：0.015s</p>
</blockquote>
<p>这是刘汝佳的紫书中”DAG中的动态规划”中的习题，我拿它用来熟悉DAG中的动态规划。</p>
<p>我们不妨进行逆向考虑：现堆上面的方块，然后考虑在下面进行叠加。这样子一来，影响决策的就只是最下面方块的尺寸了。</p>
<p>对于这种出现了”大套小”这样的二元关系的题，我们可以将其视为一个有向无环图：<strong>其中每个节点为一个状态，状态的转移是有固定的方向的</strong>（在此题中，状态转移为从小的方块到大的方块）。</p>
<p>但是这道题又不同于平常的DAG动态规划：若将边长视为状态的话，则要开一个巨大的数组，这是不可以接受的。因此，我们要换一种思维方式：只记录方块的序号和摆放的方式（如现将边长从小到大进行排序，然后用一个标志k表示当前是以第k小的边长作为高）。<br> 至此，思路已经清晰了。用dp(i, k)表示<strong>“第i个方块以第k条边为高进行摆放”</strong>，以下给出状态转移方程：</p>
<blockquote>
<p>dp(i, k) = max{dp(i, k), dp(j, k2)} j，k2遍历所有顶面矩形比dp(i, k)小的状态。</p>
</blockquote>
<p>代码实现首次尝试了Pascal中的object类型，使其更加工整，但不可避免地损耗了一些性能。</p>
<p>Code：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type&#10;    Cube = object&#10;        a: array [1..3] of longint;&#10;        procedure init(x,y,z: longint);&#10;        function height(k: integer): longint;&#10;        function low(k: integer): longint;&#10;        function high(k: integer): longint;&#10;    end;&#10;&#10;function max(x,y: longint): longint;&#10;begin&#10;    if x&#38;gt;y then max := x else max := y;&#10;end;&#10;&#10;procedure swap(var x,y: longint);&#10;var&#10;    t: longint;&#10;begin&#10;    t := x;&#10;    x := y;&#10;    y := t;&#10;end;&#10;&#10;function Cube.height(k: integer): longint;&#10;begin&#10;    height := self.a[k];&#10;end;&#10;&#10;function Cube.high(k: integer): longint;&#10;begin&#10;    case k of&#10;        1: high := a[3];&#10;        2: high := a[3];&#10;        3: high := a[2];&#10;    end;&#10;end;&#10;&#10;function Cube.low(k: integer): longint;&#10;begin&#10;    case k of&#10;        1: low := a[2];&#10;        2,3: low := a[1];&#10;    end;&#10;end;&#10;&#10;procedure Cube.init(x, y, z: longint);&#10;begin&#10;   if x&#38;gt;y then swap(x,y);&#10;   if y&#38;gt;z then swap(y,z);&#10;   if x&#38;gt;y then swap(x,y);&#10;   a[1] := x;&#10;   a[2] := y;&#10;   a[3] := z;&#10;end;&#10;&#10;var&#10;    f: array [1..30, 1..3] of longint;&#10;    i,j,m,n,x,y,z: longint;&#10;    cnt: longint;&#10;    cubes: array [1..30] of Cube;&#10;&#10;function dp(id, k: integer): longint;&#10;var&#10;    l, h, hi: longint;&#10;    i, j: integer;&#10;begin&#10;    if f[id, k] &#38;gt; 0 then&#10;        exit(f[id, k]);&#10;    l := cubes[id].low(k);&#10;    hi := cubes[id].height(k);&#10;    h := cubes[id].high(k);&#10;&#10;    f[id, k] := hi;&#10;&#10;    for i := 1 to n do&#10;    begin&#10;        //if i = id then continue;  //&#27492;&#22788;&#22312;&#19968;&#24320;&#22987;&#26102;&#24536;&#35760;&#32771;&#34385;&#20102;&#31435;&#26041;&#20307;&#26377;&#26080;&#31351;&#22810;&#20010;&#36825;&#19968;&#26465;&#20214;&#12290;&#10;        for j := 1 to 3 do&#10;        begin&#10;            if not ((cubes[i].low(j) &#38;lt; l) and (cubes[i].high(j) &#38;lt; h)) then&#10;                continue;&#10;            f[id, k] := max(f[id, k], dp(i, j)+hi);&#10;        end;&#10;    end;&#10;&#10;    dp := f[id, k];&#10;end;&#10;&#10;begin&#10;    assign(input, &#39;main.in&#39;);reset(input);&#10;    assign(output, &#39;main.out&#39;);rewrite(output);&#10;    read(n);&#10;    cnt := 0;&#10;    while n &#38;gt; 0 do&#10;    begin&#10;        inc(cnt);&#10;        for i := 1 to n do&#10;        begin&#10;            read(x,y,z);&#10;            cubes[i].init(x,y,z);&#10;        end;&#10;        fillchar(f, sizeof(f), 0);&#10;&#10;        m := 0;&#10;        for i := 1 to n do&#10;            for j := 1 to 3 do&#10;                m := max(m, dp(i, j));&#10;&#10;        writeln(&#39;Case &#39;, cnt, &#39;: maximum height = &#39;, m);&#10;&#10;        read(n);&#10;    end;&#10;    close(input);close(output);&#10;end.</span><br></pre></td></tr></table></figure></div></div><div class="page-navigator"><a href="/page/5/" class="pre">上一页</a><a href="/page/7/" class="next">下一页</a></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div id="search"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://hsfzxjy.github.io"></form></div></div><div class="widget"><div class="widget-title">导航<ul><li><a href="/archives/"> <i class="icon-archives"> 归档</i></a></li><li><a href="/works/"> <i class="icon-works"> 个人作品</i></a></li><li><a href="/atom.xml"> <i class="icon-rss"> 订阅</i></a></li></ul></div></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂感/">杂感</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载文章/">转载文章</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随手记/">随手记</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/不经意间的感动/" style="font-size: 15px;">不经意间的感动</a> <a href="/tags/Delphi/" style="font-size: 15px;">Delphi</a> <a href="/tags/随想/" style="font-size: 15px;">随想</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/DIY/" style="font-size: 15px;">DIY</a> <a href="/tags/字符串模板/" style="font-size: 15px;">字符串模板</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Meta-Classes/" style="font-size: 15px;">Meta Classes</a> <a href="/tags/黑魔法/" style="font-size: 15px;">黑魔法</a> <a href="/tags/元编程/" style="font-size: 15px;">元编程</a> <a href="/tags/杂感/" style="font-size: 15px;">杂感</a> <a href="/tags/诗/" style="font-size: 15px;">诗</a> <a href="/tags/作文/" style="font-size: 15px;">作文</a> <a href="/tags/家书/" style="font-size: 15px;">家书</a> <a href="/tags/成人礼/" style="font-size: 15px;">成人礼</a> <a href="/tags/产品/" style="font-size: 15px;">产品</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/web设计/" style="font-size: 15px;">web设计</a> <a href="/tags/wisecity/" style="font-size: 15px;">wisecity</a> <a href="/tags/前端自动化测试，总结/" style="font-size: 15px;">前端自动化测试，总结</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/单元测试/" style="font-size: 15px;">单元测试</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/OOP/" style="font-size: 15px;">OOP</a> <a href="/tags/HFMUN重构系列/" style="font-size: 15px;">HFMUN重构系列</a> <a href="/tags/化学/" style="font-size: 15px;">化学</a> <a href="/tags/ubuntu/" style="font-size: 15px;">ubuntu</a> <a href="/tags/apt-get/" style="font-size: 15px;">apt-get</a> <a href="/tags/物理/" style="font-size: 15px;">物理</a> <a href="/tags/创新作文大赛/" style="font-size: 15px;">创新作文大赛</a> <a href="/tags/Sublime/" style="font-size: 15px;">Sublime</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/字体/" style="font-size: 15px;">字体</a> <a href="/tags/百题大过关/" style="font-size: 15px;">百题大过关</a> <a href="/tags/逆袭/" style="font-size: 15px;">逆袭</a> <a href="/tags/MySql/" style="font-size: 15px;">MySql</a> <a href="/tags/NOIP2014/" style="font-size: 15px;">NOIP2014</a> <a href="/tags/信息学竞赛/" style="font-size: 15px;">信息学竞赛</a> <a href="/tags/北大金秋营/" style="font-size: 15px;">北大金秋营</a> <a href="/tags/树状数组/" style="font-size: 15px;">树状数组</a> <a href="/tags/LCA/" style="font-size: 15px;">LCA</a> <a href="/tags/归并排序/" style="font-size: 15px;">归并排序</a> <a href="/tags/逆序对/" style="font-size: 15px;">逆序对</a> <a href="/tags/最小生成树/" style="font-size: 15px;">最小生成树</a> <a href="/tags/数论/" style="font-size: 15px;">数论</a> <a href="/tags/数学/" style="font-size: 15px;">数学</a> <a href="/tags/数列/" style="font-size: 15px;">数列</a> <a href="/tags/高精度/" style="font-size: 15px;">高精度</a> <a href="/tags/UVa/" style="font-size: 15px;">UVa</a> <a href="/tags/Pascal/" style="font-size: 15px;">Pascal</a> <a href="/tags/搜索/" style="font-size: 15px;">搜索</a> <a href="/tags/剪枝/" style="font-size: 15px;">剪枝</a> <a href="/tags/浮点数/" style="font-size: 15px;">浮点数</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/游记/" style="font-size: 15px;">游记</a> <a href="/tags/win32/" style="font-size: 15px;">win32</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/thinking-in-the-day-before-lunar-new-year-of-2016/">除夕杂感</a></li><li class="post-list-item"><a class="post-list-link" href="/a-simple-javascript-template-language/">17 行代码实现的简易 Javascript 字符串模板</a></li><li class="post-list-item"><a class="post-list-link" href="/meta-class-in-python/">Python “黑魔法” 之 Meta Classes</a></li><li class="post-list-item"><a class="post-list-link" href="/poems/">诗集</a></li><li class="post-list-item"><a class="post-list-link" href="/life-needs-discovery/">生活，需要被“发现”</a></li><li class="post-list-item"><a class="post-list-link" href="/letter-to-parents/">家书·十八岁成人礼</a></li><li class="post-list-item"><a class="post-list-link" href="/hobby-or-needs/">炫技？还是需求？</a></li><li class="post-list-item"><a class="post-list-link" href="/the-state-of-responsive-images-in-2015/">【译】响应式图片的现状</a></li><li class="post-list-item"><a class="post-list-link" href="/why-are-so-many-programming-languages/">【译】“为什么有这么多的编程语言？”</a></li><li class="post-list-item"><a class="post-list-link" href="/wisecity-conclusion/">Wisecity 商赛总结——也谈前端自动化测试</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">thoughts of hsfzxjy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></body><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script>
<script src="/js/adjust-wechat.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>$(document).ready(function() {
    $('img').each(function() {
        if ($(this).parent().hasClass('fancybox')) return;
        if ($(this).hasClass('nofancybox')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="caption">' + alt + '</span>');
        $(this).wrap('<a href="' + ($(this).attr('data-src') == null ? this.src : $(this).attr('data-src')) + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article');
    });
});</script><script>$(document).ready(function() {
    $("a[href$='.jpg'],a[href$='.png'],a[href$='.gif']").attr('rel', 'gallery').fancybox({
     helpers : {
     title: { type: 'inside'}
     }
 });
});
</script><script>var duoshuoQuery = {short_name:'hsfzxjy'};
(function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]},
    jax: ["input/TeX","output/HTML-CSS"]
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></html>