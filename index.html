<a id="rocket" href="#top" class="show"></a><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description"/><title>thoughts of hsfzxjy</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">thoughts of hsfzxjy</h1><a id="logo" href="/">thoughts of hsfzxjy</a><p class="description"></p><iframe src="https://ghbtns.com/github-btn.html?user=hsfzxjy&amp;type=follow&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px" class="github-btn"></iframe></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> 首页</i></a><a href="/categories/编程/"><i class="icon-code"> 码海拾贝</i></a><a href="/categories/杂感/"><i class="icon-life"> 五味杂感</i></a><a href="/about/"><i class="icon-about"> 我</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/python-generator-coroutine/">Python “黑魔法” 之 Generator Coroutines</a></h2><div class="post-meta">2016-04-02</div><span data-thread-key="/python-generator-coroutine/" class="ds-thread-count"></span><div class="post-content"><h2 id="写在前面">写在前面</h2><blockquote>
<ul>
<li>本文默认读者对 Python 生成器 有一定的了解，不了解者请移步至<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000" target="_blank" rel="external">生成器 - 廖雪峰的官方网站</a>。</li>
<li>本文基于 Python 3.5.1，文中所有的例子都可在 <a href="https://github.com/hsfzxjy/python-generator-coroutine-examples" target="_blank" rel="external">Github</a> 上获得。</li>
</ul>
</blockquote>
<p>学过 Python 的都知道，Python 里有一个很厉害的概念叫做 生成器（Generators）。一个生成器就像是一个微小的线程，可以随处暂停，也可以随时恢复执行，还可以和代码块外部进行数据交换。恰当使用生成器，可以极大地简化代码逻辑。</p>
<p>也许，你可以熟练地使用生成器完成一些看似不可能的任务，如“无穷斐波那契数列”，并引以为豪，认为所谓的生成器也不过如此——那我可要告诉你：这些都太小儿科了，下面我所要介绍的绝对会让你大开眼界。</p>
<p><strong>生成器 可以实现 协程，你相信吗？</strong></p>
<h2 id="什么是协程">什么是协程</h2><p>在异步编程盛行的今天，也许你已经对 协程（coroutines） 早有耳闻，但却不一定了解它。我们先来看看 <a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="external">Wikipedia</a> 的定义：</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations.</p>
</blockquote>
<p>也就是说：协程是一种 <strong>允许在特定位置暂停或恢复的子程序</strong>——这一点和 生成器 相似。但和 生成器 不同的是，协程 可以控制子程序暂停之后代码的走向，而 生成器 仅能被动地将控制权交还给调用者。</p>
<p>协程 是一种很实用的技术。和 多进程 与 多线程 相比，协程 可以只利用一个线程更加轻便地实现 多任务，将任务切换的开销降至最低。和 回调 等其他异步技术相比，协程 维持了正常的代码流程，在保证代码可读性的同时最大化地利用了 阻塞 IO 的空闲时间。它的高效与简洁赢得了开发者们的拥戴。</p>
<h2 id="Python_中的协程">Python 中的协程</h2><p>早先 Python 是没有原生协程支持的，因此在 协程 这个领域出现了百家争鸣的现象。主流的实现由以下两种：</p>
<ul>
<li>用 C 实现协程调度。这一派以 gevent 为代表，在底层实现了协程调度，并将大部分的 阻塞 IO 重写为异步。</li>
<li>用 生成器模拟。这一派以 Tornado 为代表。Tornado 是一个老牌的异步 Web 框架，涵盖了五花八门的异步编程方式，其中包括 协程。本文部分代码借鉴于 Tornado。</li>
</ul>
<p>直至 Python 3.4，Python 第一次将异步编程纳入标准库中（参见 <a href="https://www.python.org/dev/peps/pep-3156/" target="_blank" rel="external">PEP 3156</a>），其中包括了用生成器模拟的 协程。而在 Python 3.5 中，Guido 总算在语法层面上实现了 协程（参见 <a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="external">PEP 0492</a>）。比起 <code>yield</code> 关键字，新关键字 <code>async</code> 和 <code>await</code> 具有更好的可读性。在不久的将来，新的实现将会慢慢统一混乱已久的协程领域。</p>
<p>尽管 生成器协程 已成为了过去时，但它曾经的辉煌却不可磨灭。下面，让我们一起来探索其中的魔法。</p>
<h2 id="一个简单的例子">一个简单的例子</h2><p>假设有两个子程序 <code>main</code> 和 <code>printer</code>。<code>printer</code> 是一个死循环，等待输入、加工并输出结果。<code>main</code> 作为主程序，不时地向 <code>printer</code> 发送数据。    </p>
<p>这应该怎么实现呢？</p>
<p>传统方式中，这几乎不可能在一个线程中实现，因为死循环会阻塞。而协程却能很好地解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        string = (<span class="keyword">yield</span>)</span><br><span class="line">        print(<span class="string">'[&#123;0&#125;] &#123;1&#125;'</span>.format(counter, string))</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = printer()</span><br><span class="line">    next(p)</span><br><span class="line">    p.send(<span class="string">'Hi'</span>)</span><br><span class="line">    p.send(<span class="string">'My name is hsfzxjy.'</span>)</span><br><span class="line">    p.send(<span class="string">'Bye!'</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[0]</span> Hi</span><br><span class="line"><span class="comment">[1]</span> My name <span class="keyword">is</span> hsfzxjy.</span><br><span class="line"><span class="comment">[2]</span> Bye!</span><br></pre></td></tr></table></figure>
<p>这其实就是最简单的协程。程序由两个分支组成。主程序通过 <code>send</code> 唤起子程序并传入数据，子程序处理完后，用 <code>yield</code> 将自己挂起，并返回主程序，如此交替进行。</p>
<h2 id="协程调度">协程调度</h2><p>有时，你的手头上会有多个任务，每个任务耗时很长，而你又不想同步处理，而是希望能像多线程一样交替执行。这时，你就需要一个调度器来协调流程了。</p>
<p>作为例子，我们假设有这么一个任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name, times)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        print(name, i)</span><br></pre></td></tr></table></figure>
<p>如果你直接执行 <code>task</code>，那它会在遍历 <code>times</code> 次之后才会返回。为了实现我们的目的，我们需要将 <code>task</code> 人为地切割成若干块，以便并行处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name, times)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        print(name, i)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>yield</code> 没有逻辑意义，仅是作为暂停的标志点。程序流可以在此暂停，也可以在此恢复。而通过实现一个调度器，我们可以完成多个任务的并行处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tasks)</span>:</span></span><br><span class="line">        self.tasks = deque(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.tasks.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> len(self.tasks):</span><br><span class="line">            task = self.next()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                next(task)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.tasks.appendleft(task)</span><br></pre></td></tr></table></figure>
<p>这里我们用一个队列（deque）储存任务列表。其中的 <code>run</code> 是一个重要的方法： <strong>它通过轮转队列依次唤起任务，并将已经完成的任务清出队列</strong>，简洁地模拟了任务调度的过程。</p>
<p>而现在，我们只需调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runner([</span><br><span class="line">    task(<span class="string">'hsfzxjy'</span>, <span class="number">5</span>),</span><br><span class="line">    task(<span class="string">'Jack'</span>, <span class="number">4</span>),</span><br><span class="line">    task(<span class="string">'Bob'</span>, <span class="number">6</span>)</span><br><span class="line">]).run()</span><br></pre></td></tr></table></figure>
<p>就可以得到预想中的效果了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Bob <span class="number">0</span></span><br><span class="line">Jack <span class="number">0</span></span><br><span class="line">hsfzxjy <span class="number">0</span></span><br><span class="line">Bob <span class="number">1</span></span><br><span class="line">Jack <span class="number">1</span></span><br><span class="line">hsfzxjy <span class="number">1</span></span><br><span class="line">Bob <span class="number">2</span></span><br><span class="line">Jack <span class="number">2</span></span><br><span class="line">hsfzxjy <span class="number">2</span></span><br><span class="line">Bob <span class="number">3</span></span><br><span class="line">Jack <span class="number">3</span></span><br><span class="line">hsfzxjy <span class="number">3</span></span><br><span class="line">Bob <span class="number">4</span></span><br><span class="line">hsfzxjy <span class="number">4</span></span><br><span class="line">Bob <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>简直完美！答案和丑陋的多线程别无二样，代码却简单了不止一个数量级。</p>
<h2 id="异步_IO_模拟">异步 IO 模拟</h2><p>你绝对有过这样的烦恼：程序常常被时滞严重的 IO 操作（数据库查询、大文件读取、越过长城拿数据）阻塞，在等待 IO 返回期间，线程就像死了一样，空耗着时间。为此，你不得不用多线程甚至是多进程来解决问题。</p>
<p>而事实上，在等待 IO 的时候，你完全可以做一些与数据无关的操作，最大化地利用时间。Node.js 在这点做得不错——它将一切异步化，压榨性能。只可惜它的异步是基于事件回调机制的，稍有不慎，你就有可能陷入 Callback Hell 的深渊。</p>
<p>而协程并不使用回调，相比之下可读性会好很多。其思路大致如下：</p>
<ul>
<li>维护一个消息队列，用于储存 IO 记录。</li>
<li>协程函数 IO 时，自身挂起，同时向消息队列插入一个记录。</li>
<li>通过轮询或是 epoll 等事件框架，捕获 IO 返回的事件。</li>
<li>从消息队列中取出记录，恢复协程函数。</li>
</ul>
<p>现在假设有这么一个耗时任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(name, <span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    print(name, <span class="number">2</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(name, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>正常情况下，这个任务执行完需要 3 秒，倘若多个同步任务同步执行，执行时间会成倍增长。而如果利用协程，我们就可以在接近 3 秒的时间内完成多个任务。</p>
<p>首先我们要实现消息队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">events_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.callback = <span class="keyword">lambda</span>: <span class="keyword">None</span></span><br><span class="line">        events_list.append(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_callback</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">        self.callback = callback</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self._is_ready()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            self.callback()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><code>Event</code> 是消息的基类，其在初始化时会将自己放入消息队列 <code>events_list</code> 中。<code>Event</code> 和 调度器 使用回调进行交互。</p>
<p>接着我们要 hack 掉 <code>sleep</code> 函数，这是因为原生的 <code>time.sleep()</code> 会阻塞线程。通过自定义 <code>sleep</code> 我们可以模拟异步延时操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sleep.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> event <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepEvent</span><span class="params">(Event)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, timeout)</span>:</span></span><br><span class="line">        super(SleepEvent, self).__init__(timeout)</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.start_time = time()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> time() - self.start_time &gt;= self.timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(timeout)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> SleepEvent(timeout)</span><br></pre></td></tr></table></figure>
<p>可以看出：<code>sleep</code> 在调用后就会立即返回，同时一个 <code>SleepEvent</code> 对象会被放入消息队列，经过<code>timeout</code> 秒后执行回调。</p>
<p>再接下来便是协程调度了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># runner.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> event <span class="keyword">import</span> events_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(tasks)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        _next(task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(events_list):</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events_list:</span><br><span class="line">            <span class="keyword">if</span> event.is_ready():</span><br><span class="line">                events_list.remove(event)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_next</span><span class="params">(task)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        event = next(task)</span><br><span class="line">        event.set_callback(<span class="keyword">lambda</span>: _next(task)) <span class="comment"># 1</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>run</code> 启动了所有的子程序，并开始消息循环。每遇到一处挂起，调度器自动设置回调，并在回调中重新恢复代码流。“1” 处巧妙地利用闭包保存状态。</p>
<p>最后是主代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sleep <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> runner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(name, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">1</span>)</span><br><span class="line">    print(name, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">2</span>)</span><br><span class="line">    print(name, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    runner.run((task(<span class="string">'hsfzxjy'</span>), task(<span class="string">'Jack'</span>)))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hsfzxjy <span class="number">1</span></span><br><span class="line">Jack <span class="number">1</span></span><br><span class="line">hsfzxjy <span class="number">2</span></span><br><span class="line">Jack <span class="number">2</span></span><br><span class="line">hsfzxjy <span class="number">3</span></span><br><span class="line">Jack <span class="number">3</span></span><br><span class="line"><span class="preprocessor"># [Finished in <span class="number">3.0</span>s]</span></span><br></pre></td></tr></table></figure>
<h2 id="协程函数的层级调用">协程函数的层级调用</h2><p>上面的代码有一个不足之处，即协程函数返回的是一个 <code>Event</code> 对象。然而事实上只有直接操纵 IO 的协程函数才有可能接触到这个对象。那么，对于调用了 IO 的函数的调用者，它们应该如何实现呢？</p>
<p>设想如下任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_add</span><span class="params">(x, y, duration=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> sleep(duration)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(duration)</span>:</span></span><br><span class="line">    print(<span class="string">'start:'</span>, time())</span><br><span class="line">    print((<span class="keyword">yield</span> long_add(<span class="number">1</span>, <span class="number">2</span>, duration)))</span><br><span class="line">    print((<span class="keyword">yield</span> long_add(<span class="number">3</span>, <span class="number">4</span>, duration)))</span><br></pre></td></tr></table></figure>
<p><code>long_add</code> 是 IO 的一级调用者，<code>task</code> 调用 <code>long_add</code>，并利用其返回值进行后续操作。</p>
<p>简而言之，我们遇到的问题是：<strong>一个被唤起的协程函数如何唤起它的调用者？</strong></p>
<p>正如在上个例子中，协程函数通过 <code>Event</code> 的回调与调度器交互。同理，我们也可以使用一个类似的对象，在这里我们称其为 <code>Future</code>。</p>
<p><code>Future</code> 保存在被调用者的闭包中，并由被调用者返回。而调用者通过在其上面设置回调函数，实现两个协程函数之间的交互。</p>
<p><code>Future</code> 的代码如下，看起来有点像 <code>Event</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># future.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Future, self).__init__()</span><br><span class="line">        self.callback = <span class="keyword">lambda</span> *args: <span class="keyword">None</span></span><br><span class="line">        self._done = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_callback</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">        self.callback = callback</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">done</span><span class="params">(self, value=None)</span>:</span></span><br><span class="line">        self._done = <span class="keyword">True</span></span><br><span class="line">        self.callback(value)</span><br></pre></td></tr></table></figure>
<p><code>Future</code> 的回调函数允许接受一个参数作为返回值，以尽可能地模拟一般函数。</p>
<p>但这样一来，协程函数就会有些复杂了。它们不仅要负责唤醒被调用者，还要负责与调用者之间的交互。这会产生许多重复代码。为了 D.R.Y，我们用装饰器封装这一逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># co.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> future <span class="keyword">import</span> Future</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_next</span><span class="params">(gen, future, value=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            yielded_future = gen.send(value)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            yielded_future = next(gen)</span><br><span class="line"></span><br><span class="line">        yielded_future.set_callback(<span class="keyword">lambda</span> value: _next(gen, future, value))</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        future.done(e.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="decorator">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        future = Future()</span><br><span class="line"></span><br><span class="line">        gen = func(*args, **kwargs)</span><br><span class="line">        _next(gen, future)</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>被 <code>coroutine</code> 包装过的生成器成为了一个普通函数，返回一个 <code>Future</code> 对象。<code>_next</code> 为唤醒的核心逻辑，通过一个类似递归的回调设置简洁地实现自我唤醒。当自己执行完时，会将自己闭包内的<code>Future</code>对象标记为<code>done</code>，从而唤醒调用者。</p>
<p>为了适应新变化，<code>sleep</code> 也要做相应的更改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> event <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">from</span> future <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepEvent</span><span class="params">(Event)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, timeout)</span>:</span></span><br><span class="line">        super(SleepEvent, self).__init__()</span><br><span class="line">        self.start_time = time()</span><br><span class="line">        self.timeout = timeout</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> time() - self.start_time &gt;= self.timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(timeout)</span>:</span></span><br><span class="line">    future = Future()</span><br><span class="line">    event = SleepEvent(timeout)</span><br><span class="line">    event.set_callback(<span class="keyword">lambda</span>: future.done())</span><br><span class="line">    <span class="keyword">return</span> future</span><br></pre></td></tr></table></figure>
<p><code>sleep</code> 不再返回 <code>Event</code> 对象，而是一致地返回 <code>Future</code>，并作为 <code>Event</code> 和 <code>Future</code> 之间的代理者。</p>
<p>基于以上更改，调度器可以更加简洁——这是因为协程函数能够自我唤醒：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># runner.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> event <span class="keyword">import</span> events_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> len(events_list):</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events_list:</span><br><span class="line">            <span class="keyword">if</span> event.is_ready():</span><br><span class="line">                events_list.remove(event)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>主程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> co <span class="keyword">import</span> coroutine</span><br><span class="line"><span class="keyword">from</span> sleep <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> runner</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_add</span><span class="params">(x, y, duration=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> sleep(duration)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(duration)</span>:</span></span><br><span class="line">    print(<span class="string">'start:'</span>, time())</span><br><span class="line">    print((<span class="keyword">yield</span> long_add(<span class="number">1</span>, <span class="number">2</span>, duration)), time())</span><br><span class="line">    print((<span class="keyword">yield</span> long_add(<span class="number">3</span>, <span class="number">4</span>, duration)), time())</span><br><span class="line"></span><br><span class="line">task(<span class="number">2</span>)</span><br><span class="line">task(<span class="number">1</span>)</span><br><span class="line">runner.run()</span><br></pre></td></tr></table></figure>
<p>由于我们使用了一个糟糕的事件轮询机制，密集的计算会阻塞通往 <code>stdout</code> 的输出，因而看起来所有的结果都是一起打印出来的。为此，我在打印时特地加上了时间戳，以演示协程的效果。输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="number">1459609512.263156</span></span><br><span class="line">start: <span class="number">1459609512.263212</span></span><br><span class="line"><span class="number">3</span> <span class="number">1459609513.2632613</span></span><br><span class="line"><span class="number">3</span> <span class="number">1459609514.2632234</span></span><br><span class="line"><span class="number">7</span> <span class="number">1459609514.263319</span></span><br><span class="line"><span class="number">7</span> <span class="number">1459609516.2633028</span></span><br></pre></td></tr></table></figure>
<p>这事实上是 <code>tornado.gen.coroutine</code> 的简化版本，为了叙述方便我略去了许多细节，如异常处理以及调度优化，目的是让大家能较清晰地了解 生成器协程 背后的机制。因此，<strong>这段代码并不能用于实际生产中</strong>。</p>
<h2 id="小结">小结</h2><ul>
<li>这，才叫精通生成器。</li>
<li>学习编程，不仅要知其然，亦要知其所以然。</li>
<li>Python 是有魔法的，只有想不到，没有做不到。</li>
</ul>
<h2 id="References">References</h2><ul>
<li><a href="https://github.com/tornadoweb/tornado/blob/master/tornado/gen.py#L245" target="_blank" rel="external">tornado.gen.coroutine</a></li>
</ul>
</div></div><div class="post"><h2 class="post-title"><a href="/the-simplest-way-to-find-out-if-two-segments-are-intersected/">数学美 之 判断线段相交的最简方法</a></h2><div class="post-meta">2016-02-19</div><span data-thread-key="/the-simplest-way-to-find-out-if-two-segments-are-intersected/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>解析几何的巅峰<br>是 向量<br>那无关过程的狂妄与简洁<br>映射着大自然无与伦比的美</p>
</blockquote>
<h2 id="引子">引子</h2><p>如何判断两条直线是否相交？</p>
<p>这很容易。平面直线，无非就是两种关系：相交 或 平行。因此，只需判断它们是否平行即可。而直线平行，等价于它们的斜率相等，只需分别计算出它们的斜率，即可做出判断。</p>
<p>但倘若我把“直线”换成“线段”呢——如何判断两条线段是否相交？</p>
<p>这就有些难度了。和 直线 不同，线段 是有固定长度的，即使它们所属的两条直线相交，这两条线段也不一定相交。</p>
<p>也许你会说：分情况讨论不就行了嘛：</p>
<ul>
<li>先计算两条线段的斜率，判断是否平行。若平行，则一定不相交。</li>
<li>若不平行，求出两条线段的直线方程，联立之，解出交点坐标。</li>
<li>运用定比分点公式，判断交点是否在两条线段上。</li>
</ul>
<p>的确，从理论上这是一个可行的办法，这也是人们手动计算时普遍采用的方法。</p>
<p>然而，这个方法并不怎么适用于计算机。原因如下：</p>
<ul>
<li>计算中出现了除法（斜率计算、定比分点），因此每次计算前都要判断除数是否为 0（或接近 0）。这很麻烦，严重干扰逻辑的表达。</li>
<li>浮点精度丢失带来的误差。人类计算时可以采用分数，但计算机不行。计算机在储存浮点数时会有精度丢失的现象。一旦算法的计算量大起来，误差会被急剧放大，影响结果准确性。</li>
<li>效率低下。浮点乘除会十分耗时，不适用于对实时性要求较高的生产环境（如 游戏）。</li>
</ul>
<p><img src="http://www.qqday.com/uploads/allimg/120627/09210Bb8-3.png" alt=""></p>
<p>那么，有更好的方法？</p>
<p>当然有。<br></div><p class="readmore"><a href="/the-simplest-way-to-find-out-if-two-segments-are-intersected/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/thinking-in-the-day-before-lunar-new-year-of-2016/">除夕杂感</a></h2><div class="post-meta">2016-02-13</div><span data-thread-key="/thinking-in-the-day-before-lunar-new-year-of-2016/" class="ds-thread-count"></span><div class="post-content"><!--## 一-->
<p>直到下午四点，供桌才摆上。</p>
<p>冒着热气的鸡，整只；两尾鱼，张着嘴卧在盘中；一摞柑，愣是叠成了宝塔的形状；此外，还有一包包花花绿绿的零食。一米见方的桌子被塞得满满的，全是贡品。</p>
<p>母亲忙得团团转。本来是不想拜天公的，但转念一想，不是太好，便摆上了。阳光下，热气一直往上冒，往上冒，直到看不见的地方——那里，想必就住着那位神。</p>
<p>看来，这位神一定是个重要人物了——不然，母亲怎会遗忘了其他的几位，而只供奉他一个？</p>
<p>搬家之前，家里可还是住着许多神的：门口有一个，阳台上有一个，厨房有一个，抽屉下有一个，就连洗衣机上也有一个。听母亲说：每一家都有，每一位神，都在守卫着这个家。</p>
<p>神们也不是白干活，也是要吃饭的。不只是过年，每个月中总有那么几天，神们会一起来要吃的。每到这时，母亲便会忙活起来，为他们张罗吃的。好在他们并不挑剔——生的，熟的，速食的，神们都默默地收下了。当然，贡品在屋子里转了一圈，自然又都进到了我们的肚子里。</p>
<p>每换一个地方，母亲便上一炷香，虔诚地跪下来，轻轻地拜两拜，口中念念有词。</p>
<p>接着，她又拉我一起来。</p>
<p>我不懂，她便教我——想着自己想要的事就好了。</p>
<p>我学着样子跪下来，胡乱说了几句，装模作样地拜了两拜，余光却仍盯着那食物。</p>
<p>听母亲说，这是老家带来的习俗。对神的敬畏，在那个古老的地方，说着那古老语言的人们，已经沿袭了很久很久了。</p>
<p>人终是怕神的——以前是，现在也是；中国是，外国也是。神像一群喜欢偷窥的人，在这里，也在那里，在每个角落偷窥着你。你受欺负时，神会给你庇护；你做坏事时，神会予你惩罚。因此，怕神的人，多是善良的。</p>
<p>说是怕神，倒不如说是怕天，敬畏变幻莫测的未知。活物总是怀着对死亡的恐惧，人类也不例外。未知中蕴藏着杀机，使愚昧的人类感到不安，转而求助于那假象中的造物主，那超能力者，那个开着全局视角看戏的“人”，这便成了“神”。神为人类抵挡着未知，人类也因此安分守己，深怕触犯了神，再次被暴露于未知的荒野中。</p>
<p>然而，神正在离去，因为未知正在散去。</p>
<p>但藏在那未知背后的是什么，谁又知道呢？未知的背后仍是未知，现实可以是虚幻，真理也可以是谬误，时间洪流夹带着未知，使任何人都只能屏息，任何人，都不可以妄自尊大。</p>
<p>好在，还有神——尽管神正在离去。</p>
<p>但终究，怕神的人是善良的。</p>
<!--## 二

母亲跪在供桌前，红着眼圈，抽泣着。

供桌背后，是明净的落地窗——厚重的窗帘已被拆下，在洗衣机里轰鸣着。透过窗子，可以看见这个城市，在阳光下闪着金光。

与其说是在拜天公，倒不如说是在祭拜整个世界。

物欲横流的世界。人们渐行渐远的世界。

门外，父亲许久没有发声。

母亲和父亲刚吵了一架。父亲又出去打麻将了，在除夕，家里只有母亲一个人在忙活。

母亲措辞犀利，出言不逊，像是有憋了一整年的怨气。叫罢，便像孩子一样失声哭了起来。

父亲自知理亏，一直没有发声。

其实，父亲只是想娱乐一下而已。纷纷扰扰的世事，压迫着每一个人，谁都有烦恼的时候。

或许，父亲只是把春节当成是一个稍长的假期罢了，但母亲不这么想。观念的分歧，引起了这场纠纷。
-->
</div></div><div class="post"><h2 class="post-title"><a href="/a-simple-javascript-template-language/">17 行代码实现的简易 Javascript 字符串模板</a></h2><div class="post-meta">2016-02-12</div><span data-thread-key="/a-simple-javascript-template-language/" class="ds-thread-count"></span><div class="post-content"><p>这是源于两年前，当我在做人生中第一个真正意义上的网站时遇到的一个问题</p>
<p>该网站采用前后端分离的方式，由后端的 REST 接口返回 JSON 数据，再由前端渲染到页面上。</p>
<p>同许多初学 Javascript 的菜鸟一样，起初，我也是采用拼接字符串的形式，将 JSON 数据嵌入 HTML 中。开始时代码量较少，暂时还可以接受。但当页面结构复杂起来后，其弱点开始变得无法忍受起来：</p>
<ul>
<li><strong>书写不连贯</strong>。每写一个变量就要断一下，插入一个 <code>+</code> 和 <code>&quot;</code>。十分容易出错。</li>
<li><strong>无法重用</strong>。HTML 片段都是离散化的数据，难以对其中重复的部分进行提取。</li>
<li><strong>无法很好地利用 <code>&lt;template&gt;</code> 标签</strong>。这是 HTML5 中新增的一个标签，标准极力推荐将 HTML 模板放入 <code>&lt;template&gt;</code> 标签中，使代码更简洁。</li>
</ul>
<p>当时我的心情就是这样的：</p>
<p><img src="http://i6.hexunimg.cn/2012-05-09/141219425.jpg" alt=""></p>
<p>为了解决这个问题，我暂时放下了手上的项目，花了半个小时实现一个极简易的字符串模板。</p>
</div><p class="readmore"><a href="/a-simple-javascript-template-language/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/meta-class-in-python/">Python “黑魔法” 之 Meta Classes</a></h2><div class="post-meta">2016-02-10</div><span data-thread-key="/meta-class-in-python/" class="ds-thread-count"></span><div class="post-content"><p>接触过 Django 的同学都应该十分熟悉它的 ORM 系统。对于 python 新手而言，这是一项几乎可以被称作“黑科技”的特性：只要你在<code>models.py</code>中随便定义一个<code>Model</code>的子类，Django 便可以：</p>
<ul>
<li>获取它的字段定义，并转换成表结构</li>
<li>读取<code>Meta</code>内部类，并转化成相应的配置信息。对于特殊的<code>Model</code>（如<code>abstract</code>、<code>proxy</code>），还要进行相应的转换</li>
<li>为没有定义<code>objects</code>的<code>Model</code>加上一个默认的<code>Manager</code></li>
</ul>
<p>开发之余，我也曾脑补过其背后的原理。曾经，我认为是这样的：</p>
<blockquote>
<p>启动时，遍历<code>models.py</code>中的所有属性，找到<code>Model</code>的子类，并对其进行上述的修改。</p>
</blockquote>
<p>当初，我还以为自己触碰到了真理，并曾将其应用到实际生产中——为 SAE 的 KVDB 写了一个类 ORM 系统。然而在实现的过程中，我明显感受到了这种方法的丑陋，而且性能并不出色（因为要遍历所有的定义模块）。</p>
<p>那么事实上，Django 是怎么实现的呢？</p>
<blockquote>
<p>自古以来我们制造东西的方法都是“自上而下”的，是用切削、分割、组合的方法来制造。然而，生命是自下而上地，自发地建造起来的，这个过程极为低廉。<br><cite>——王晋康 《水星播种》</cite></p>
</blockquote>
<p>这句话揭示了生命的神奇所在：<strong>真正的生命都是由基本物质自发构成的，而非造物主流水线式的加工</strong>。</p>
<p>那么，如果 类 也有生命的话，对它自己的修饰就不应该由调用者来完成，而应该是<strong>自发的</strong>。</p>
<p>幸而，python 提供了造物主的接口——这便是 Meta Classes，或者称为“元类”。</p>
</div><p class="readmore"><a href="/meta-class-in-python/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/poems/">诗集</a></h2><div class="post-meta">2015-12-01</div><span data-thread-key="/poems/" class="ds-thread-count"></span><div class="post-content"><h3 id="2015-11-04">2015-11-04</h3><p>第 -206 天</p>
<p>曾经的不屑</p>
<p>早已如烟</p>
<p>曾经不屑的</p>
<p>却又沉淀</p>
<h3 id="2015-11-24">2015-11-24</h3><p>当能力成为本能 恰似鱼儿潜入水中</p>
<p>你问 何以会凫水？</p>
<p>鱼答 我也不知道</p>
<p>:-(</p>
<h3 id="2015-11-26">2015-11-26</h3><p>一夜的寒冷 仿佛击碎了文明</p>
<p>在黎明的迷雾中 人们聚集于旷野</p>
<p>向东方的鱼肚白祈祷 渴求着光与热</p>
<p>目光 狂热而虔诚</p>
<p>就像 他们的祖先一样</p>
</div></div><div class="post"><h2 class="post-title"><a href="/life-needs-discovery/">生活，需要被“发现”</a></h2><div class="post-meta">2015-11-28</div><span data-thread-key="/life-needs-discovery/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>40 分钟赶完的作文，没想到居然成了范文。 <strong>Scores：47</strong></p>
</blockquote>
<p>互联网，从当初的雨后春笋发展成为了我们生活中必不可缺的一部分——二十年，有如白驹过隙，但就是在如此短的时间中，世界已完全被网络颠覆了。</p>
</div><p class="readmore"><a href="/life-needs-discovery/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/letter-to-parents/">家书·十八岁成人礼</a></h2><div class="post-meta">2015-10-18</div><span data-thread-key="/letter-to-parents/" class="ds-thread-count"></span><div class="post-content"><p>事实上，截至目前，我只有十七岁，但无论年龄的多与少，今天这个特殊的日子，都有着其特殊的意义——是的，我要成人了。</p>
<p>这里，我想先说一声谢谢。</p>
</div><p class="readmore"><a href="/letter-to-parents/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/hobby-or-needs/">炫技？还是需求？</a></h2><div class="post-meta">2015-10-04</div><span data-thread-key="/hobby-or-needs/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>一款产品，其生命周期始于想法的萌发<br>但其终结，无人能预测<br>诚然，有些产品能够颠覆世界<br>但更多的，只是湮灭在残酷的市场中<br>甚至——<br>有的只是一场白日梦<br>连真正的出生都未曾经历    </p>
</blockquote>
</div><p class="readmore"><a href="/hobby-or-needs/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/the-state-of-responsive-images-in-2015/">【译】响应式图片的现状</a></h2><div class="post-meta">2015-09-19</div><span data-thread-key="/the-state-of-responsive-images-in-2015/" class="ds-thread-count"></span><div class="post-content"><blockquote>
<p>原文链接：<a href="http://www.webdesignerdepot.com/2015/08/the-state-of-responsive-images/" target="_blank" rel="external">戳这里</a></p>
</blockquote>
<p><img src="http://netdna.webdesignerdepot.com/uploads/2015/08/featured_images1.jpg" alt=""></p>
<p>Web 是一种可视化的媒体。绚丽的视觉效果，很大程度上离不开图片文件所作出的贡献。虽然（Whilst）其中的许多效果都可以用 CSS 和 内联 SVG 来实现，互联网上的许多站点仍需要图片文件。</p>
<p>从去年的统计来看，每个站点中，图片平均占了一半的页面体积，并且随着时间的推移，图片体积有持续增加的趋势；就 2014 年而言，图片的大小便增长了 <strong>21%</strong>。</p>
<p>与此同时，互联网终端的种类、数量也在增长。从 72 ppi（市场份额正在下降）到 600 ppi，不同设备的分辨率（resolution）有着天壤之别。</p>
<p>创建能在任何设备中都有着高质量的图片，其实再容易不过了——用 1000 ppi 的质量保存图片，然后就可以不用再理他了（译者注：原文是 call it a day）。生成的图片，即使是在分辨率最高的设备上查看也是十分清晰的（crisp）。但是，在图片质量提升的同时，图片文件的大小也会相应地增加。要知道，<strong>页面加载时间</strong>可是影响用户体验的<strong>首要因素</strong>——因此，保证站点能够及时地呈现在用户面前是我们义不容辞（incrumbent）的责任。高质量的图片，即使是在宽带环境下加载也要耗费几十秒，更不用说（let alone）是移动端的设备了——简直就是无法使用。</p>
<p>响应式图片的目的，不是要为设备提供尽可能高质量的图片（这一点，我们很容易做到），而是要为设备提供它所能支持的最高质量的图片，仅此而已（nothing more）。</p>
<p>从这篇指南中，你将了解到响应式图片的工作原理（what works），响应式图片仍然存在的问题和陷阱（pitfall），以及如何将响应式图片运用到网站中。</p>
</div><p class="readmore"><a href="/the-state-of-responsive-images-in-2015/">阅读更多</a></p></div><div class="page-navigator"><a href="/page/2/" class="next">下一页</a></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div id="search"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://hsfzxjy.github.io"></form></div></div><div class="widget"><div class="widget-title">导航<ul><li><a href="/archives/"> <i class="icon-archives"> 归档</i></a></li><li><a href="/works/"> <i class="icon-works"> 个人作品</i></a></li><li><a href="/atom.xml"> <i class="icon-rss"> 订阅</i></a></li></ul></div></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂感/">杂感</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载文章/">转载文章</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随手记/">随手记</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/Delphi/" style="font-size: 15px;">Delphi</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/generator/" style="font-size: 15px;">generator</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/杂感/" style="font-size: 15px;">杂感</a> <a href="/tags/数学/" style="font-size: 15px;">数学</a> <a href="/tags/计算几何/" style="font-size: 15px;">计算几何</a> <a href="/tags/向量/" style="font-size: 15px;">向量</a> <a href="/tags/随想/" style="font-size: 15px;">随想</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/DIY/" style="font-size: 15px;">DIY</a> <a href="/tags/字符串模板/" style="font-size: 15px;">字符串模板</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/Meta-Classes/" style="font-size: 15px;">Meta Classes</a> <a href="/tags/黑魔法/" style="font-size: 15px;">黑魔法</a> <a href="/tags/元编程/" style="font-size: 15px;">元编程</a> <a href="/tags/诗/" style="font-size: 15px;">诗</a> <a href="/tags/作文/" style="font-size: 15px;">作文</a> <a href="/tags/家书/" style="font-size: 15px;">家书</a> <a href="/tags/成人礼/" style="font-size: 15px;">成人礼</a> <a href="/tags/产品/" style="font-size: 15px;">产品</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/web设计/" style="font-size: 15px;">web设计</a> <a href="/tags/wisecity/" style="font-size: 15px;">wisecity</a> <a href="/tags/前端自动化测试，总结/" style="font-size: 15px;">前端自动化测试，总结</a> <a href="/tags/OOP/" style="font-size: 15px;">OOP</a> <a href="/tags/单元测试/" style="font-size: 15px;">单元测试</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/不经意间的感动/" style="font-size: 15px;">不经意间的感动</a> <a href="/tags/HFMUN重构系列/" style="font-size: 15px;">HFMUN重构系列</a> <a href="/tags/化学/" style="font-size: 15px;">化学</a> <a href="/tags/ubuntu/" style="font-size: 15px;">ubuntu</a> <a href="/tags/apt-get/" style="font-size: 15px;">apt-get</a> <a href="/tags/物理/" style="font-size: 15px;">物理</a> <a href="/tags/创新作文大赛/" style="font-size: 15px;">创新作文大赛</a> <a href="/tags/Sublime/" style="font-size: 15px;">Sublime</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/字体/" style="font-size: 15px;">字体</a> <a href="/tags/百题大过关/" style="font-size: 15px;">百题大过关</a> <a href="/tags/逆袭/" style="font-size: 15px;">逆袭</a> <a href="/tags/MySql/" style="font-size: 15px;">MySql</a> <a href="/tags/NOIP2014/" style="font-size: 15px;">NOIP2014</a> <a href="/tags/信息学竞赛/" style="font-size: 15px;">信息学竞赛</a> <a href="/tags/北大金秋营/" style="font-size: 15px;">北大金秋营</a> <a href="/tags/树状数组/" style="font-size: 15px;">树状数组</a> <a href="/tags/LCA/" style="font-size: 15px;">LCA</a> <a href="/tags/归并排序/" style="font-size: 15px;">归并排序</a> <a href="/tags/逆序对/" style="font-size: 15px;">逆序对</a> <a href="/tags/最小生成树/" style="font-size: 15px;">最小生成树</a> <a href="/tags/数论/" style="font-size: 15px;">数论</a> <a href="/tags/数列/" style="font-size: 15px;">数列</a> <a href="/tags/高精度/" style="font-size: 15px;">高精度</a> <a href="/tags/UVa/" style="font-size: 15px;">UVa</a> <a href="/tags/Pascal/" style="font-size: 15px;">Pascal</a> <a href="/tags/搜索/" style="font-size: 15px;">搜索</a> <a href="/tags/剪枝/" style="font-size: 15px;">剪枝</a> <a href="/tags/浮点数/" style="font-size: 15px;">浮点数</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/游记/" style="font-size: 15px;">游记</a> <a href="/tags/win32/" style="font-size: 15px;">win32</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/python-generator-coroutine/">Python “黑魔法” 之 Generator Coroutines</a></li><li class="post-list-item"><a class="post-list-link" href="/the-simplest-way-to-find-out-if-two-segments-are-intersected/">数学美 之 判断线段相交的最简方法</a></li><li class="post-list-item"><a class="post-list-link" href="/thinking-in-the-day-before-lunar-new-year-of-2016/">除夕杂感</a></li><li class="post-list-item"><a class="post-list-link" href="/a-simple-javascript-template-language/">17 行代码实现的简易 Javascript 字符串模板</a></li><li class="post-list-item"><a class="post-list-link" href="/meta-class-in-python/">Python “黑魔法” 之 Meta Classes</a></li><li class="post-list-item"><a class="post-list-link" href="/poems/">诗集</a></li><li class="post-list-item"><a class="post-list-link" href="/life-needs-discovery/">生活，需要被“发现”</a></li><li class="post-list-item"><a class="post-list-link" href="/letter-to-parents/">家书·十八岁成人礼</a></li><li class="post-list-item"><a class="post-list-link" href="/hobby-or-needs/">炫技？还是需求？</a></li><li class="post-list-item"><a class="post-list-link" href="/the-state-of-responsive-images-in-2015/">【译】响应式图片的现状</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">thoughts of hsfzxjy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></body><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script>
<script src="/js/adjust-wechat.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>$(document).ready(function() {
    $('img').each(function() {
        if ($(this).parent().hasClass('fancybox')) return;
        if ($(this).hasClass('nofancybox')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="caption">' + alt + '</span>');
        $(this).wrap('<a href="' + ($(this).attr('data-src') == null ? this.src : $(this).attr('data-src')) + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article');
    });
});</script><script>$(document).ready(function() {
    $("a[href$='.jpg'],a[href$='.png'],a[href$='.gif']").attr('rel', 'gallery').fancybox({
     helpers : {
     title: { type: 'inside'}
     }
 });
});
</script><script>var duoshuoQuery = {short_name:'hsfzxjy'};
(function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]},
    jax: ["input/TeX","output/HTML-CSS"]
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></html>