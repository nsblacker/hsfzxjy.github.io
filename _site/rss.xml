<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Blog for hsfzxjy</title>
        <description>Blog for hsfzxjy - Jinyi Xie</description>
        <link>http://hsfzxjy.github.io</link>
        <link>http://hsfzxjy.github.io</link>
        <lastBuildDate>2015-04-16T18:53:15+08:00</lastBuildDate>
        <pubDate>2015-04-16T18:53:15+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Ubuntu 网络每20秒断开重连一次的解决方案</title>
                <description>&lt;p&gt;从昨天到现在一直都有这个问题，刚刚突然就解决了，至今不明白原理，在此记录一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在网络设置中取消&lt;strong&gt;需要IPv6完成这个链接&lt;/strong&gt;的选项&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <link>http://hsfzxjy.github.io/ubuntu/2015/03/31/ubuntu-%25e7%25bd%2591%25e7%25bb%259c%25e6%25af%258f20%25e7%25a7%2592%25e6%2596%25ad%25e5%25bc%2580%25e9%2587%258d%25e8%25bf%259e%25e4%25b8%2580%25e6%25ac%25a1%25e7%259a%2584%25e8%25a7%25a3%25e5%2586%25b3%25e6%2596%25b9%25e6%25a1%2588</link>
                <guid>http://hsfzxjy.github.io/ubuntu/2015/03/31/ubuntu-%e7%bd%91%e7%bb%9c%e6%af%8f20%e7%a7%92%e6%96%ad%e5%bc%80%e9%87%8d%e8%bf%9e%e4%b8%80%e6%ac%a1%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88</guid>
                <pubDate>2015-03-31T19:18:38+08:00</pubDate>
        </item>

        <item>
                <title>关于正弦交流电有效值计算公式的证明</title>
                <description>&lt;h3&gt;公式&lt;/h3&gt;
&lt;p&gt;$I = {I_m \over \sqrt{2}}$&lt;/p&gt;
&lt;h3&gt;证明&lt;/h3&gt;
&lt;p&gt;设 $I = Asin\omega t$，则$I^2 = A^2sin^2\omega t$。&lt;/p&gt;
&lt;p&gt;取半个周期进行计算：$${Q \over R} $$&lt;br /&gt;
$$= \int_0^{T \over 2} I^2tdt$$&lt;br /&gt;
$$={A^2 \over 2}(t - {sin2\omega t \over 2\omega})|_{0}^{T \over 2}$$&lt;br /&gt;
$$={A^2T \over 4}$$&lt;br /&gt;
$$={I^2T \over 2}$$&lt;/p&gt;
&lt;p&gt;进而： $I = {A \over \sqrt{2}}$&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/%E6%95%B0%E5%AD%A6/%E7%89%A9%E7%90%86/2015/03/04/%25e5%2585%25b3%25e4%25ba%258e%25e6%25ad%25a3%25e5%25bc%25a6%25e4%25ba%25a4%25e6%25b5%2581%25e7%2594%25b5%25e6%259c%2589%25e6%2595%2588%25e5%2580%25bc%25e8%25ae%25a1%25e7%25ae%2597%25e5%2585%25ac%25e5%25bc%258f%25e7%259a%2584%25e8%25af%2581%25e6%2598%258e</link>
                <guid>http://hsfzxjy.github.io/%E6%95%B0%E5%AD%A6/%E7%89%A9%E7%90%86/2015/03/04/%e5%85%b3%e4%ba%8e%e6%ad%a3%e5%bc%a6%e4%ba%a4%e6%b5%81%e7%94%b5%e6%9c%89%e6%95%88%e5%80%bc%e8%ae%a1%e7%ae%97%e5%85%ac%e5%bc%8f%e7%9a%84%e8%af%81%e6%98%8e</guid>
                <pubDate>2015-03-04T19:32:50+08:00</pubDate>
        </item>

        <item>
                <title>【HFMUN重构系列】3. 消息系统</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;一个真正优秀的系统，值得你无数次地去重构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;消息系统算是网站比较重要的一部分，它承担着将&lt;strong&gt;已发生的事件通知给相关用户&lt;/strong&gt;的责任。看似简单，但若想做到DRY，实现起来却很复杂——因为，通知的类型太多了。&lt;/p&gt;
&lt;p&gt;这个系统，在三个项目中我实现了三次。三次都使用不同的方法，但三次都不怎么满意。这最后一次，算是比较成功的一次了。&lt;/p&gt;
&lt;p&gt;在第一版模联网站中，我采用了一个堪称最糟糕的方案（如图所示）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;assets/wboard_notifications.jpg&quot; alt=&quot;UML&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这个方案最大的缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;耦合度太高&lt;/strong&gt;。如果有一天，又多了一种消息类型，那么就要多加一张表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询的难度大&lt;/strong&gt;。通常来说我们需要显示所有的消息，从而需要使用JOIN语句进行多表联查——这效率是很低的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL本身就不是面向对象的&lt;/strong&gt;。虽说&lt;code&gt;CommentNotification&lt;/code&gt;是&lt;code&gt;Notification&lt;/code&gt;的子类，可查询时却并不能使用类似&lt;code&gt;Notification.objects.all()&lt;/code&gt;一类的语句。在一定程度上可以说：SQL本身就不是面向对象的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而在第二版模联网站中，我采用了&lt;a href=&quot;https://docs.djangoproject.com/en/1.7/ref/contrib/contenttypes/&quot;&gt;泛型&lt;/a&gt;（Generic Model Relations）这一技术来实现——这是Django另一大特色：&lt;strong&gt;通过记录对象的类型信息以及唯一标识符，实现了一种可以指向任何表的外键（GenericRelation）&lt;/strong&gt;。这种技术存在的目的就是为了&lt;strong&gt;解耦合&lt;/strong&gt;，使系统扩展更具灵活性——尽管要损失一些效率，但与架构的“健康”比起来那是微不足道的，无可厚非。&lt;/p&gt;
&lt;p&gt;UML图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;assets/hfmun_notices.jpg&quot; alt=&quot;UML&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这其中，&lt;code&gt;notice_type&lt;/code&gt;的取值决定了&lt;strong&gt;&lt;code&gt;url&lt;/code&gt;域的作用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;link&lt;/code&gt;&lt;/strong&gt;。该消息的&lt;code&gt;url&lt;/code&gt;域表示一个指向&lt;code&gt;related_object&lt;/code&gt;的地址，应该展示给用户看。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/strong&gt;。该消息需要在用户确认后执行一个动作。其&lt;code&gt;url&lt;/code&gt;域表示需要执行的动作的地址——这里有些TaskQueue的意味。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，发消息时又应该怎么做呢？如果在所有的地方都来一句：&lt;code&gt;Notice.create(......)&lt;/code&gt;，那也太不DRY了吧？&lt;/p&gt;
&lt;p&gt;有人说：“懒惰是程序员的天性。”&lt;/p&gt;
&lt;p&gt;我赞同，但我还想补充一句：“懒惰更是程序员精简代码的动力。”&lt;/p&gt;
&lt;p&gt;于是，我创立了一个类&lt;code&gt;NoticeDispatcher&lt;/code&gt;，用于分发消息——其实这一类工具代码在之前的系统中也存在过，只不过这一版本的令我更为满意。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class NoticeDispatcher(object):

    def __init__(self, model, default = {}):
        if not issubclass(model, SendNoticeModelMixin):
            raise TypeError('The `model` must be a subclass of  `SendNoticeModelMixin`.')
        self.__model = model
        self.__default = {}
        self.__default.update(default)

    def send(self, *args, **kwargs):
        klass = Notice

        title = self.__model.generate_title(*args, **kwargs) 
        content = self.__model.generate_content(*args, **kwargs) 
        url = self.__model.generate_url(*args, **kwargs)
        user = self.__model.generate_user(*args, **kwargs)

        valid_keys_set = set(kwargs.iterkeys()) &amp;amp; \
            set(field.name for field in klass._meta.fields)

        params = deepcopy(self.__default)
        params.update({key: kwargs[key] for key in valid_keys_set})
        params.update({
            'title': title,
            'content': content,
            'url': url,
        })

        results = []
        try:
            iter(user)
        except:
            user = (user,)

        for _user in user:
            params['user'] = _user
            notice = klass(*args, **params)
            notice.save()
            results.append(notice)

        return results
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以传入一个模型类作为参数从而获得一个&lt;code&gt;NoticeDispatcher&lt;/code&gt;对象。这个模型类被要求继承于&lt;code&gt;notices.mixins.SendNoticeModelMixin&lt;/code&gt;，以完成一些默认的配置——这是一个抽象基类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SendNoticeModelMixin(object):

    @classmethod
    def generate_title(klass, *args, **kwargs):
        return ''

    @classmethod
    def generate_content(klass, *args, **kwargs):
        return ''

    @classmethod
    def generate_url(klass, *args, **kwargs):
        return ''

    @classmethod
    def generate_user(klass, *args, **kwargs):
        return []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;做完这一切之后，每当调用&lt;code&gt;notice_dispatcher.send()&lt;/code&gt;方法时，&lt;code&gt;NoticeDispatcher&lt;/code&gt;会自动调用模型类中的&lt;code&gt;generate_*&lt;/code&gt;方法以获取构建消息对象的默认参数。像一些基本不变的内容——如&lt;code&gt;url&lt;/code&gt;、&lt;code&gt;title&lt;/code&gt;就可以用代码自动生成，进而提高代码复用率。&lt;/p&gt;
&lt;p&gt;当然，这个系统仍有一些不够完善的地方，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;notice_type&lt;/code&gt;为&lt;code&gt;invoke&lt;/code&gt;时的逻辑至今尚未实现。&lt;/li&gt;
&lt;li&gt;当消息的构建不需要&lt;code&gt;related_object&lt;/code&gt;参数时，仍需调用原生的&lt;code&gt;create&lt;/code&gt;方法，非常麻烦。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;related_object&lt;/code&gt;参数仍需手动传入，有些不干净——最好就是能在&lt;code&gt;SendNoticeModelMixin&lt;/code&gt;上实现&lt;code&gt;send&lt;/code&gt;方法，很多啰嗦的代码便又可以省略掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上问题，或是由于没有需求，或是由于懒惰（- -!），没有来得及去实现。但愿能在下一次改进时解决。&lt;/p&gt;
&lt;p&gt;总而言之呢，事情正在似乎在朝着好的方面发展。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/hfmun%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/%E7%BC%96%E7%A8%8B/2015/03/03/%25e3%2580%2590hfmun%25e9%2587%258d%25e6%259e%2584%25e7%25b3%25bb%25e5%2588%2597%25e3%2580%25913-%25e6%25b6%2588%25e6%2581%25af%25e7%25b3%25bb%25e7%25bb%259f</link>
                <guid>http://hsfzxjy.github.io/hfmun%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/%E7%BC%96%E7%A8%8B/2015/03/03/%e3%80%90hfmun%e9%87%8d%e6%9e%84%e7%b3%bb%e5%88%97%e3%80%913-%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f</guid>
                <pubDate>2015-03-03T21:53:20+08:00</pubDate>
        </item>

        <item>
                <title>十年</title>
                <description>&lt;p&gt;再一次站在这里，我却发现早已没有了熟悉的感觉。一切都是那样陌生：长年累月的雨水冲刷，使原本灰色的墙面变得愈加晦暗，有几处墙皮脱落了，酷似一张布满皱纹的老脸；门前，野草肆意地疯长着，没过了缩在墙角的那根水管——记忆中它一直在渗水，却不知何时被修好了，只留下了一圈丑陋的青苔，像是对这十年光阴的一个标注。&lt;/p&gt;
&lt;p&gt;这里的一切，就像是被人遗弃了。四周站着的那一圈高楼，无时无刻不在表达着对这角隅的不屑——就像长辈们对待无知的孩童一样。&lt;br /&gt;
而事实上，这里比周围的一切都要年长。&lt;/p&gt;
&lt;p&gt;时光上溯十年，那时，我居住于此。那时，还没有周围这一切。&lt;/p&gt;
&lt;p&gt;曾记得，在不远处的那块菜地，我和小伙伴趟过泥水，猫着腰在捕捉小鱼小虾。柔软的泥土记录这我们的足迹，竹架上的蔬果聆听着我们的欢笑，就连那不知名的虫儿，也哼起歌为我们助兴。&lt;/p&gt;
&lt;p&gt;曾记得，在屋后的那片小树林，上演过一次又一次的“探险之旅”。不畏阴暗，不惧神秘，只求抵达尽头时那种大汗淋漓的快意。&lt;/p&gt;
&lt;p&gt;曾记得，在楼顶的天台，我第一次仰望星空。夏夜的风吹起架子上的藤蔓，吹拂着我的脸庞。和着如水的月光，四周的一切就像仙境般梦幻。&lt;/p&gt;
&lt;p&gt;这里，有着我童年的所有回忆。&lt;/p&gt;
&lt;p&gt;可如今，这一切都像是未曾发生过。这里，也未曾记得。&lt;/p&gt;
&lt;p&gt;十年，很长，长得足以让一个人，去遗忘一个地方。&lt;/p&gt;
&lt;p&gt;再一次遇见他，没有太多的喜悦，只是相视一笑，随即，便陷入了沉默。&lt;/p&gt;
&lt;p&gt;比起上一次相遇，他又有了一些变化，整个人显得更加成熟了。但与此同时，一种未知的像雾一样的却在我们中间弥散开来，凝固着空气，窒息着心灵。&lt;/p&gt;
&lt;p&gt;我竭力搜寻着话题，想要打破这恼人的尴尬，但却徒劳无功——真的没有共同语言了，毕竟在新的环境里，我们都有了新的爱好。&lt;/p&gt;
&lt;p&gt;真是一个让人迷惑的时代——在这里，共有着美好的回忆，却也无法维系十年的友情。&lt;/p&gt;
&lt;p&gt;在那人生的上古时期，他，是我最好的朋友，一起逃过课，在小学边上的山坡尽情地疯玩；一起偷过钱，忐忑地在小商店购买垂涎已久的零食。那些年和他，一玩能玩一天，一聊能聊一宿。我们有过争吵，而更多时候，我们亲如弟兄。&lt;/p&gt;
&lt;p&gt;记忆中的那些画面，每一张笑脸，每一滴眼泪，都是那样真诚。&lt;/p&gt;
&lt;p&gt;只是，曾经的旧知己，最终还是变不到老友。&lt;/p&gt;
&lt;p&gt;十年，很长，长得足以让一个人，去疏远另一个人。&lt;/p&gt;
&lt;p&gt;十年，真的很长。承载着过去的回忆，有欢笑，有泪水——就像是人那短暂一生的缩影。&lt;/p&gt;
&lt;p&gt;人生又能有几个十年？无从得知。&lt;/p&gt;
&lt;p&gt;因此，每一个十年都弥足珍贵；每一个十年，都要用心去珍惜。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/%E6%9D%82%E6%84%9F/2015/03/03/%25e5%258d%2581%25e5%25b9%25b4</link>
                <guid>http://hsfzxjy.github.io/%E6%9D%82%E6%84%9F/2015/03/03/%e5%8d%81%e5%b9%b4</guid>
                <pubDate>2015-03-03T20:19:18+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu杀死进程</title>
                <description>&lt;pre&gt;&lt;code&gt;ps -e #查看进程列表
sudo kill &amp;lt;pid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/ubuntu/2015/03/02/ubuntu%25e6%259d%2580%25e6%25ad%25bb%25e8%25bf%259b%25e7%25a8%258b</link>
                <guid>http://hsfzxjy.github.io/ubuntu/2015/03/02/ubuntu%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8b</guid>
                <pubDate>2015-03-02T19:17:55+08:00</pubDate>
        </item>

        <item>
                <title>【HFMUN重构系列】2. 用户系统</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;现在，我比任何时候都要有主见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是这次重构过程中我最想说的一句话了。&lt;/p&gt;
&lt;p&gt;毋庸置疑，Django是一个十分优秀的Web框架：高效的开发模式，完备的应用集成，以及最重要的一点——具有完全自由的扩展能力——这是Django的灵魂所在。但是无知，通常会束缚了一个人的探索欲望与创新能力，让其变得胆怯、变得懒惰。一年前我的遭遇就很好地印证了这一点。&lt;/p&gt;
&lt;p&gt;对于一个网站而言，用户永远是最重要的元素。没有了用户，网站做得再好也只能被放在角落腐烂，与死尸无异。这样看来，打造一个完美的用户系统就显得十分必要了。&lt;/p&gt;
&lt;p&gt;Django为我们提供了一个优秀的用户系统，它位于&lt;code&gt;django.contrib.auth&lt;/code&gt;——想必Djangoers都对它很熟悉了。&lt;code&gt;auth&lt;/code&gt;应用是专门为用户管理打造的一个应用，它提供了以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个用户模型（User）。这是&lt;code&gt;auth&lt;/code&gt;框架的核心所在，用于存储用户信息，包括 用户名、密码、邮箱等内容。该模型可被替换也可被拓展，具有良好的可塑性。&lt;/li&gt;
&lt;li&gt;一个权限系统（Permission）。这部分为实现访问控制提供了可能。一个&lt;code&gt;Permission&lt;/code&gt;对应一个关于&lt;code&gt;Model&lt;/code&gt;的操作，默认有&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;change&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;三种。值得一提的是，在版本&lt;code&gt;1.7&lt;/code&gt;之前，Django并不提供更改默认权限的能力，即每个&lt;code&gt;Model&lt;/code&gt;都会固定拥有以上三种权限。我个人觉得这种做法不太好，并不是所有的模型都需要这种功能划分。更何况权限限制被应用在Django的每一个角落，如果想让一个模型完全开放，就要多敲许多不必要的代码。如今Django1.7改进了这一点，这使得模型更加简洁了。&lt;/li&gt;
&lt;li&gt;用户分组的功能（Groups）。一个&lt;code&gt;Group&lt;/code&gt;可以拥有多个&lt;code&gt;Permission&lt;/code&gt;，一个用户可以选择加入一个&lt;code&gt;Group&lt;/code&gt;，并会自动拥有还&lt;code&gt;Group&lt;/code&gt;的权限。这一设计简化了用户管理的操作，同时也让用户系统的更有层次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，我想说的是关于扩展&lt;code&gt;User&lt;/code&gt;模型的一些技巧。&lt;/p&gt;
&lt;p&gt;一年之前，由于对Django的不了解，我不敢对它的内部实现大动干戈。而事实上，没有什么东西是绝对完美的，即便是集众智于一身的开源框架也是如此。诚然，&lt;code&gt;auth&lt;/code&gt;框架是不错，但在某些特定的应用场景，它便显得心有余而力不足了。因此，我希望能在&lt;code&gt;User&lt;/code&gt;模型上附带一些额外的信息。&lt;/p&gt;
&lt;p&gt;百度一下，我找到了一个被广为流传的方法：&lt;code&gt;Profile&lt;/code&gt;模式。也就是说，额外定义一个&lt;code&gt;Profile&lt;/code&gt;模型和&lt;code&gt;User&lt;/code&gt;模型建立一一对应的关系，用于储存额外信息。我清楚地记得，几乎是每一篇博客都在介绍这种方法，于是乎我毫不犹豫地就采纳了。现在想一想，这其实是一个十分糟糕的方案。它有如下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作麻烦。&lt;/strong&gt;每次访问额外信息，都要先询问是否存在&lt;code&gt;Profile&lt;/code&gt;对象，如果不存在得先创建。然后再调用&lt;code&gt;user_object.profile&lt;/code&gt;来访问信息。同时，这种方案对表单不友好，因为用户信息是被分开储存在两个表中的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率低下。&lt;/strong&gt;每次访问额外信息，先是用&lt;code&gt;IF EXISTS&lt;/code&gt;判断是否存在，再用&lt;code&gt;INNER JOIN&lt;/code&gt;将主信息和次信息从数据库中取出，一共需要两条SQL语句。更何况，&lt;code&gt;INNER JOIN&lt;/code&gt;指令是公认的效率低下的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在这次重构中我采用了一种截然不同的做法：直接重写&lt;code&gt;User&lt;/code&gt;模型。这里的灵感来自&lt;a href=&quot;https://docs.djangoproject.com/en/1.7/topics/auth/customizing/#auth-custom-user&quot;&gt;Django官方文档&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Some kinds of projects may have authentication requirements for which Django’s built-in User model is not always appropriate. For instance, on some sites it makes more sense to use an email address as your identification token instead of a username.&lt;/p&gt;
&lt;p&gt;Django allows you to override the default User model by providing a value for the AUTH_USER_MODEL setting that references a custom model:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; AUTH_USER_MODEL = 'myapp.MyUser'
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;听起来不错，既方便实现起来又简单。于是我重写了我的&lt;code&gt;accounts&lt;/code&gt;应用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#encoding=utf8
&quot;&quot;&quot;
    事实上这里许多实现都模仿自`django.contrib.auth.models.User`，毕竟我只是要存储一些额外信息而已。
&quot;&quot;&quot;
from django.core import validators
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from django.utils.translation import ugettext_lazy as _
from django.utils import timezone
from django.db import models

class UserManager(BaseUserManager):

    def _create_user(self, username, password,
                     is_staff, is_superuser, **extra_fields):
        &quot;&quot;&quot;
        Creates and saves a User with the given username, email and password.
        &quot;&quot;&quot;
        now = timezone.now()
        if not username:
            raise ValueError('The given username must be set')
        user = self.model(username=username,
                          is_staff=is_staff, is_active=True,
                          is_superuser=is_superuser, last_login=now,
                          date_joined=now, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, username, password=None, **extra_fields):
        return self._create_user(username, password, False, False,
                                 **extra_fields)

    def create_superuser(self, username, password, **extra_fields):
        return self._create_user(username, password, True, True,
                                 **extra_fields)

# 这里的`AbstractBaseUser`是用户模型的基类，由于原生的`User`模型中有一些字段并不是我想要的，因此我需要从上一个抽象类继承。
class User(AbstractBaseUser, PermissionsMixin):

    username = models.CharField(_('username'), max_length=30, unique=True,
        help_text=_('Required. 30 characters or fewer. Letters, digits and '
                    '@/./+/-/_ only.'),
        validators=[
            validators.RegexValidator(r'^[\w.@+-]+$', _('Enter a valid username.'), 'invalid')
        ])

    # 用户描述
    description = models.TextField()

    # 昵称
    nickname = models.CharField(_('nickname'),
        max_length=30, unique=True,
        help_text=_('Required. 30 characters or fewer.'),
        )

    # 好友关系
    friends = models.ManyToManyField(
        'self',
        verbose_name=_('friends'),
        blank=True,
        related_name='+'
        )

    #================以下是原有的字段==================
    is_staff = models.BooleanField(_('staff status'), default=False,
        help_text=_('Designates whether the user can log into this admin '
                    'site.'))
    is_active = models.BooleanField(_('active'), default=True,
        help_text=_('Designates whether this user should be treated as '
                    'active. Unselect this instead of deleteing accounts.'))
    date_joined = models.DateTimeField(_('date joined'), auto_now_add=True)

    USERNAME_FIELD = 'username'
    objects = UserManager()

    class Meta:
        verbose_name = _('user')
        verbose_name_plural = _('users')

    def get_full_name(self):
        return self.nickname

    def get_short_name(self):
        return self.nickname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及&lt;code&gt;settings.py&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#...
AUTH_USER_MODEL = 'accounts.User'
#...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了让admin框架同步支持我们的新&lt;code&gt;User&lt;/code&gt;模型，还需要对&lt;code&gt;admin.py&lt;/code&gt;以及&lt;code&gt;forms.py&lt;/code&gt;进行相应的修改，实际上就是把新加入的字段写进相应的类即可，在这里我就不贴代码了。&lt;/p&gt;
&lt;p&gt;做完这一切，一个念头忽然从我脑海中闪过：对于一些第三方应用，如果它们直接引用了&lt;code&gt;django.contrib.auth.models.User&lt;/code&gt;，那该怎么办呢？我的&lt;code&gt;User&lt;/code&gt;模型会生效吗？&lt;/p&gt;
&lt;p&gt;这让我感到不安，因为重构的一大原则便是：不得改变外部接口的调用情况。如果这一改动使得整个网站都崩溃了，那就得不偿失了。可庆幸的是，这样的事情并没有发生。&lt;/p&gt;
&lt;p&gt;这不禁让我感到好奇：django是怎么做到这一点的？&lt;/p&gt;
&lt;p&gt;翻看&lt;code&gt;django.contrib.auth.models&lt;/code&gt;，我发现了如下一句代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User(AbstractUser):
    &quot;&quot;&quot;
    Users within the Django authentication system are represented by this
    model.

    Username, password and email are required. Other fields are optional.
    &quot;&quot;&quot;
    class Meta(AbstractUser.Meta):
        swappable = 'AUTH_USER_MODEL'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查找&lt;a href=&quot;https://docs.djangoproject.com/en/1.8/ref/models/fields/#django.db.models.ForeignKey.swappable&quot;&gt;Django文档&lt;/a&gt;，原来这是Django1.7的一个新特性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ForeignKey.swappable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Controls the migration framework’s reaction if this ForeignKey is pointing at a swappable model. If it is True - the default - then if the ForeignKey is pointing at a model which matches the current value of settings.AUTH_USER_MODEL (or another swappable model setting) the relationship will be stored in the migration using a reference to the setting, not to the model directly.&lt;/p&gt;
&lt;p&gt;You only want to override this to be False if you are sure your model should always point towards the swapped-in model - for example, if it is a profile model designed specifically for your custom user model.&lt;/p&gt;
&lt;p&gt;Setting it to False does not mean you can reference a swappable model even if it is swapped out - False just means that the migrations made with this ForeignKey will always reference the exact model you specify (so it will fail hard if the user tries to run with a User model you don’t support, for example).&lt;/p&gt;
&lt;p&gt;If in doubt, leave it to its default of True.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个特性可以使指向这个模型的ForeignKey自动被替换成&lt;code&gt;Meta.swappable&lt;/code&gt;的内容，实现模型的可替换能力。这是一个巧妙的设计。&lt;/p&gt;
&lt;p&gt;重构后的&lt;code&gt;accounts&lt;/code&gt;应用，逻辑变得更加清晰，也使我不再纠结于冗长的恼人的&lt;code&gt;Profile&lt;/code&gt;调用。&lt;/p&gt;
&lt;p&gt;这，是一个美妙的起点。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/hfmun%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/%E7%BC%96%E7%A8%8B/2015/01/28/%25e3%2580%2590hfmun%25e9%2587%258d%25e6%259e%2584%25e7%25b3%25bb%25e5%2588%2597%25e3%2580%25912-%25e7%2594%25a8%25e6%2588%25b7%25e7%25b3%25bb%25e7%25bb%259f</link>
                <guid>http://hsfzxjy.github.io/hfmun%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/%E7%BC%96%E7%A8%8B/2015/01/28/%e3%80%90hfmun%e9%87%8d%e6%9e%84%e7%b3%bb%e5%88%97%e3%80%912-%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f</guid>
                <pubDate>2015-01-28T20:41:10+08:00</pubDate>
        </item>

        <item>
                <title>【HFMUN重构系列】1. Django1.7</title>
                <description>&lt;p&gt;有人说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“软件更新的速度永远也比不上客户使用的速度。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;的确，网络世界真是一个日新月异的地方，甚至作为开发者的我也能真切地感受到这一点。记得2013年初，Django最高的版本号才是1.5.5。一年之后，已经变成1.7了（事实上，应该是1.7.3，两个月的时间让我又落后了0.3个版本）。比起1.5.x，Django1.7多了如下的新特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Migrations，即实时同步数据库。在此之前，如果要对Model的表结构进行改动，要么自己用MySQL的&lt;code&gt;ALTER TABLE&lt;/code&gt;语句，要么就删除整个数据库再&lt;code&gt;syncdb&lt;/code&gt;（大家可能很惊讶，由于本人较懒，因此常常会做出这样“鲁莽”的操作，反正是在调试- -）。这给开发带来了不少的麻烦。尽管不少博客都说——在解读需求时期就要定好表结构。可对于我，这点实在是比较难办到，总会有一些考虑不周的地方。&lt;/li&gt;
&lt;li&gt;Custom lookups，即自定义查找规则。我们常常会用到QuerySet的查找语句&lt;code&gt;User.objects.filter(id__lt=2)&lt;/code&gt;等等。但如果要某一天我要实现自定义规则，如MySQL的全文搜索，又该怎么做呢？在1.7之前，Django并没有提供相应的接口，只能通过嵌入Raw SQL来实现。如今，1.7的这个特性让大家眼前一亮，同时也使数据库查找变得更加灵活。 &lt;/li&gt;
&lt;li&gt;App Configurations，即关于应用的自定义配置。就我个人看来，这里主要时方便了Admin的应用名显示。在1.7版本之前，我们无法设定应用在Admin中显示的名字，只能让那些格格不入的英文名显示在管理界面中——这也是我不让Admin投入实际应用的一个原因。如今，通过配置&lt;code&gt;AppConfig&lt;/code&gt;，我们可以轻易地实现这一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在HFMUN2.0中我用到的新特性大概就是这些，它们给应用开发带来了愉悦的体验。但可恶的是：&lt;strong&gt;SAE并不同步更新Django。&lt;/strong&gt;如今，那里的Django仍然停留在版本1.5。&lt;/p&gt;
&lt;p&gt;于是，我只能将新鲜出炉的Django1.7放在网站的目录下，一同传上SAE。&lt;/p&gt;
&lt;p&gt;起初，我是将Django打包成Zip文件发在&lt;code&gt;site_packages/&lt;/code&gt;目录下，因为我隐约记得Python是支持直接导入Zip文件的。但尝试了许多次，都说“找不到Django”。迫不得已，只好将Django解压出来再上传——这花费了我不少的时间（哦！中国的上传速度！）。&lt;/p&gt;
&lt;p&gt;接下来便是Django的配置了。先将&lt;code&gt;config.yaml&lt;/code&gt;修改成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: hfmun
version: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然我们已经不用SAE自带的Django了，就应该把依赖关系删除，以免导入其默认的Django。&lt;/p&gt;
&lt;p&gt;接着修改&lt;code&gt;index.wsgi&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#...
import sys
from site_packages import django 
sys.modules['django'] = django
#...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;index.wsgi&lt;/code&gt;是第一个被执行的文件，在此处把Django先导入可以保证之后每次使用的Django都是自己上传的那个版本。&lt;br /&gt;
至此，新版本Django就可以使用了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ps：据测试，这样配置的网站大约会比普通的网站慢几十毫秒，大概是自己的Django需要启动时间。不过比起新功能，这点损耗是微不足道的。&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/hfmun%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/%E7%BC%96%E7%A8%8B/2015/01/27/%25e3%2580%2590hfmun%25e9%2587%258d%25e6%259e%2584%25e7%25b3%25bb%25e5%2588%2597%25e3%2580%25911-django1-7</link>
                <guid>http://hsfzxjy.github.io/hfmun%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/%E7%BC%96%E7%A8%8B/2015/01/27/%e3%80%90hfmun%e9%87%8d%e6%9e%84%e7%b3%bb%e5%88%97%e3%80%911-django1-7</guid>
                <pubDate>2015-01-27T20:49:06+08:00</pubDate>
        </item>

        <item>
                <title>【HFMUN重构系列】0. 前言</title>
                <description>&lt;p&gt;这是2014年初我接到的一个项目：给模拟联合国建立一个网站，实现文章发布以及在线聊天的功能，供在3月初的华附模联大会使用。&lt;/p&gt;
&lt;p&gt;这是我人生中做的第一个网站，也是在这时，我组建了第一支自己的开发团队——尽管，只有两个人；尽管，我们都才高一。至于他们是怎么找到我的，那一刻，我记得十分清楚——那是2013年12月的某天，一个晚自习的课间，阿三突然走进来大喊了一声：“我们班有谁会做网站的？”那时候的我，刚刚接触web编程。我记得，我毫不犹豫地就答应了。这一句回答，改变了我之后一年多的生活。其中，有收获，同时也失去了一些东西——但我不后悔。这一年多的生活，在别人看来我似乎是在固执地溯流行船，逆着大家公认的“好的方向”前进，可我觉得这一切都是值得的。一年来，我收获的不只是技术，还有团队协作能力、与客户交涉的能力、许多解决未知问题的方法，以及最重要的一点——快乐。现在回想起来：如果当初我没有选择这一条路，也许我会通过一些“传统”的努力获得一些“传统”的荣誉，甚至没有了高考的负担，这固然不错，但同时我也会失去上一句话中提到的那些东西——一些在书本中学不到的珍宝，这些都是要通过实践来感知。更何况——每个人都应该拥有属于自己的生活。&lt;/p&gt;
&lt;p&gt;我又想起了黄老师那句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“希望你不要随波逐流。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;言归正传。我先简单概括一下这个系统的情况。这是搭建在SinaAppEngine上的一个网站，使用Python+Django1.7+MySQL+Bootstrap3进行开发。去年的版本做的实在是有些匆忙，在投入使用前一天才草草收尾，没有经过QA测试就投入使用了——或者说我们请客户当了QA(T_T)。幸好客户比较温柔，不像传说中段子里提到的&lt;strong&gt;可怕的甲方&lt;/strong&gt;，或许是因为这是第一版，又或许是碍于同学情面。&lt;/p&gt;
&lt;p&gt;那次的前端做得实在是太挫了：每一个界面元素都是照搬Bootstrap的组件，Bootstrap没有的便用其中一种或几种组合（Panel搭建的超大评论框就这么诞生了...），我们自己只写了少得可怜的几行css——事实上就凭着当年那菜鸟级别的css水平，我们也不敢乱改。另外一个令我们头疼的是IE兼容性问题（EVIL！）——这还是一个用户发现的：bootstrap在IE8-下全乱了。我只得陪着笑乞求他们换用Chrome，别提有多尴尬了。&lt;/p&gt;
&lt;p&gt;问题还不止这些。2013年初，正是新浪云的Channel服务进行公测的时候。Channel服务是新浪云自主开发的一个提供客户端实时推送的服务，可应用于网络聊天室等实时性要求较高的网站中。有了这一技术，我才有能力搭建会议聊天系统。但这毕竟是Alpha版本，难免有些Bug。在调试时，光是和新浪客服交涉就花了我不少的时间。可在实际应用时它还是出了一些毛病，甚至在会议最后半天时它干脆直接无法使用了（π.π）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;凡事都是要走出第一步的，无论是成功或是失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时光荏苒，转眼间一年又过去了。从14年12月开始我又重新启动了这一项目。比起上一次，尽管上次的网站做基础，尽管我有了更多的时间，可用户的需求也更加苛刻了。截至目前，1月27日，重构已经几乎完成了。在这里，我将记下这两个月的重构工程中发生的点点滴滴。&lt;/p&gt;
&lt;p&gt;附：&lt;a href=&quot;http://hfmun.sinaapp.com/&quot;&gt;华附模拟联合国官网&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/hfmun%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/%E7%BC%96%E7%A8%8B/2015/01/27/%25e3%2580%2590hfmun%25e9%2587%258d%25e6%259e%2584%25e7%25b3%25bb%25e5%2588%2597%25e3%2580%25910-%25e5%2589%258d%25e8%25a8%2580</link>
                <guid>http://hsfzxjy.github.io/hfmun%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97/%E7%BC%96%E7%A8%8B/2015/01/27/%e3%80%90hfmun%e9%87%8d%e6%9e%84%e7%b3%bb%e5%88%97%e3%80%910-%e5%89%8d%e8%a8%80</guid>
                <pubDate>2015-01-27T20:02:41+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu安装Sublime 2</title>
                <description>&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:webupd8team/sublime-text-2

sudo apt-get update

sudo apt-get install sublime-text-2
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/sublime/ubuntu/2014/12/29/ubuntu%25e5%25ae%2589%25e8%25a3%2585sublime-2</link>
                <guid>http://hsfzxjy.github.io/sublime/ubuntu/2014/12/29/ubuntu%e5%ae%89%e8%a3%85sublime-2</guid>
                <pubDate>2014-12-29T19:31:02+08:00</pubDate>
        </item>

        <item>
                <title>拉格朗日乘数法</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;今天在听&lt;strong&gt;张心捷同学&lt;/strong&gt;讲题的时候，得知了一个很厉害的&lt;strong&gt;在限制条件下求多远函数极值的办法&lt;/strong&gt;——&lt;strong&gt;拉格朗日乘数法&lt;/strong&gt;。在这里记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;引题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;已知：$a,b,c&gt;0$，$a+b+c=1$。证明：$\sum_{cyc}(1-a^2)^2\geq 2$。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;拉格朗日乘数法的表述&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于多值函数$y=f(x_1,x_2,\ldots ,x_n)$以及约束条件$\phi(x_1,x_2,\ldots,x_n)=0$，若待定一个系数$\lambda$，则由方程组：&lt;br /&gt;
$$\frac{\partial f}{\partial x_1}+\lambda\cdot{\partial \phi \over \partial x_1}=0,$$&lt;br /&gt;
$$\frac{\partial f}{\partial x_2}+\lambda\cdot{\partial \phi \over \partial x_2}=0,$$&lt;br /&gt;
$$\ldots$$&lt;br /&gt;
$$\frac{\partial f}{\partial x_n}+\lambda\cdot{\partial \phi \over \partial x_n}=0,$$&lt;br /&gt;
$$\phi(x_1,x_2,\ldots,x_n)=0$$&lt;br /&gt;
可得一系列的解。这些解即为$y=f(x_1,x_2,\ldots ,x_n)$在约束条件$\phi(x_1,x_2,\ldots,x_n)=0$下可能的极值点。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;由拉格朗日乘数法，我们可解得：$(a,b,c)=(1,0,0),(0,1,0),(0,0,1)$。这是一些可能的极值点，在这些点上$f$都等于2。&lt;br /&gt;
当然，我们还要考虑边界情况：即$a,b,c$有一个为1或0。在这些情况下我们使用拉格朗日乘数法依旧可得上面的结论。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/%E6%95%B0%E5%AD%A6/2014/12/27/%25e6%258b%2589%25e6%25a0%25bc%25e6%259c%2597%25e6%2597%25a5%25e4%25b9%2598%25e6%2595%25b0%25e6%25b3%2595</link>
                <guid>http://hsfzxjy.github.io/%E6%95%B0%E5%AD%A6/2014/12/27/%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e4%b9%98%e6%95%b0%e6%b3%95</guid>
                <pubDate>2014-12-27T16:55:52+08:00</pubDate>
        </item>

        <item>
                <title>【转】十问国人</title>
                <description>&lt;p&gt;&lt;a href=&quot;http://i.ifeng.com/news/zhuanti/mainland/njdtsgj/zx/news?aid=93362281&amp;amp;stt=cpz_newsnext&amp;amp;mid=5UBkCb&amp;amp;all=1&amp;amp;p=1&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/2014/12/14/%25e3%2580%2590%25e8%25bd%25ac%25e3%2580%2591%25e5%258d%2581%25e9%2597%25ae%25e5%259b%25bd%25e4%25ba%25ba</link>
                <guid>http://hsfzxjy.github.io/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/2014/12/14/%e3%80%90%e8%bd%ac%e3%80%91%e5%8d%81%e9%97%ae%e5%9b%bd%e4%ba%ba</guid>
                <pubDate>2014-12-14T18:38:49+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu加入自己的字体</title>
                <description>&lt;p&gt;假设字体文件夹为：&lt;code&gt;～/Fonts&lt;/code&gt;。执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mkdir -p /usr/share/fonts/myFonts
sudo cp ~/Fonts/*.ttf /usr/share/fonts/myFonts/
sudo chmod 644 /usr/share/fonts/myFonts/*.ttf
cd /usr/share/fonts/winFonts/
sudo mkfontscale （创建雅黑字体的fonts.scale文件，它用来控制字体旋转缩放）
sudo mkfontdir （创建雅黑字体的fonts.dir文件，它用来控制字体粗斜体产生）
sudo fc-cache -fv （建立字体缓存信息，也就是让系统认识雅黑）
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/ubuntu/2014/12/13/ubuntu%25e5%258a%25a0%25e5%2585%25a5%25e8%2587%25aa%25e5%25b7%25b1%25e7%259a%2584%25e5%25ad%2597%25e4%25bd%2593</link>
                <guid>http://hsfzxjy.github.io/ubuntu/2014/12/13/ubuntu%e5%8a%a0%e5%85%a5%e8%87%aa%e5%b7%b1%e7%9a%84%e5%ad%97%e4%bd%93</guid>
                <pubDate>2014-12-13T15:50:34+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu下删除不完整的包</title>
                <description>&lt;p&gt;答案来自&lt;a href=&quot;http://stackoverflow.com/questions/27455626/how-to-remove-an-incomplete-package-by-using-apt-get&quot;&gt;StackOverflow&lt;/a&gt;: &lt;code&gt;sudo dpkg --remove --force-remove-reinstreq &amp;lt;your package name&amp;gt;&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/ubuntu/2014/12/13/ubuntu%25e4%25b8%258b%25e5%2588%25a0%25e9%2599%25a4%25e4%25b8%258d%25e5%25ae%258c%25e6%2595%25b4%25e7%259a%2584%25e5%258c%2585</link>
                <guid>http://hsfzxjy.github.io/ubuntu/2014/12/13/ubuntu%e4%b8%8b%e5%88%a0%e9%99%a4%e4%b8%8d%e5%ae%8c%e6%95%b4%e7%9a%84%e5%8c%85</guid>
                <pubDate>2014-12-13T13:41:10+08:00</pubDate>
        </item>

        <item>
                <title>化学 【第二章-第一节】归纳</title>
                <description>&lt;h3&gt;&lt;strong&gt;电解质&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;strong&gt;电解质是溶于水溶液中或在熔融状态下就能够导电（自身电离成阳离子与阴离子）的化合物&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;分类：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;强电解质：&lt;strong&gt;在水溶液中或熔融状态中几乎完全发生电离的电解质&lt;/strong&gt;。一般有：强酸强碱，活泼金属氧化物，大多数的盐。&lt;/li&gt;
&lt;li&gt;弱电解质：&lt;strong&gt;在水溶液中或熔融状态下不完全发生电离的电解质&lt;/strong&gt;。一般有：弱酸弱碱，少数的盐，水。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;同系物&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;strong&gt;结构相似、分子组成相差若干个“CH2”原子团的有机化合物互相称为同系物。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一般来说，同系物的名字都有相同的结尾，如：烷、醇等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;分散系&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;strong&gt;一种或几种物质分散在另一种（或多种）物质中所形成的体系称为分散体系。&lt;/strong&gt;分散系的分类由&lt;strong&gt;分散质的直径大小&lt;/strong&gt;决定。&lt;/li&gt;
&lt;li&gt;具体分类：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;溶液，无丁达尔效应。&lt;/li&gt;
&lt;li&gt;胶体，由丁达尔效应，通常也是透明的。&lt;/li&gt;
&lt;li&gt;浊液，又分为悬浊液（固体小颗粒）和乳浊液（小液滴，不可用过滤分离）。透光的可以有丁达尔效应。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;酸性氧化物&amp;amp;碱性氧化物&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;酸性氧化物：&lt;strong&gt;能与水作用生成相应价态的酸，或与碱作用生成盐和水（且生成物只能有一种盐和水，不可以有任何其它物质生成），或与碱性氧化物反应生成盐的氧化物&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;碱性氧化物：&lt;strong&gt;能跟酸起反应，生成一种盐和水的氧化物叫碱性氧化物(且生成物只能有盐和水,不可以有任何其它物质生成)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;酸性氧化物不一定是非金属氧化物（如$Mn_2O_7$），而碱性氧化物一定为金属氧化物。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;离子化合物&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;由阳离子（通常为金属离子和铵根离子）和阴离子构成的化合物。&lt;/strong&gt;注意 &lt;em&gt;HCl不是，它是共价化合物&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://hsfzxjy.github.io/%E5%8C%96%E5%AD%A6/%E7%99%BE%E9%A2%98%E5%A4%A7%E8%BF%87%E5%85%B3/2014/12/01/%25e5%258c%2596%25e5%25ad%25a6-%25e3%2580%2590%25e7%25ac%25ac%25e4%25ba%258c%25e7%25ab%25a0-%25e7%25ac%25ac%25e4%25b8%2580%25e8%258a%2582%25e3%2580%2591%25e5%25bd%2592%25e7%25ba%25b3</link>
                <guid>http://hsfzxjy.github.io/%E5%8C%96%E5%AD%A6/%E7%99%BE%E9%A2%98%E5%A4%A7%E8%BF%87%E5%85%B3/2014/12/01/%e5%8c%96%e5%ad%a6-%e3%80%90%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e7%ac%ac%e4%b8%80%e8%8a%82%e3%80%91%e5%bd%92%e7%ba%b3</guid>
                <pubDate>2014-12-01T20:58:40+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu下解决apt-get “Hash校验和不符的方案”</title>
                <description>&lt;p&gt;各种坑爹，我也不知道为什么：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo gedit etc/apt/apt.conf.d/00aptitude
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后加一行：&lt;code&gt;Acquire::CompressionTypes::Order &quot;gz&quot;;&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/ubuntu/2014/11/29/ubuntu%25e4%25b8%258b%25e8%25a7%25a3%25e5%2586%25b3apt-get-hash%25e6%25a0%25a1%25e9%25aa%258c%25e5%2592%258c%25e4%25b8%258d%25e7%25ac%25a6%25e7%259a%2584%25e6%2596%25b9%25e6%25a1%2588</link>
                <guid>http://hsfzxjy.github.io/ubuntu/2014/11/29/ubuntu%e4%b8%8b%e8%a7%a3%e5%86%b3apt-get-hash%e6%a0%a1%e9%aa%8c%e5%92%8c%e4%b8%8d%e7%ac%a6%e7%9a%84%e6%96%b9%e6%a1%88</guid>
                <pubDate>2014-11-29T18:26:18+08:00</pubDate>
        </item>

        <item>
                <title>在Ubuntu下更改MYSQL的字符集</title>
                <description>&lt;p&gt;修改&lt;code&gt;/etc/mysql/my.cnf&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[client]
default-character-set=utf8

[mysqld]
character_set_server=utf8

[mysql]
default-character-set=utf8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后：&lt;code&gt;sudo service mysql restart&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/mysql/ubuntu/%E7%BC%96%E7%A8%8B/2014/11/28/%25e5%259c%25a8ubuntu%25e4%25b8%258b%25e6%259b%25b4%25e6%2594%25b9mysql%25e7%259a%2584%25e5%25ad%2597%25e7%25ac%25a6%25e9%259b%2586</link>
                <guid>http://hsfzxjy.github.io/mysql/ubuntu/%E7%BC%96%E7%A8%8B/2014/11/28/%e5%9c%a8ubuntu%e4%b8%8b%e6%9b%b4%e6%94%b9mysql%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86</guid>
                <pubDate>2014-11-28T21:49:30+08:00</pubDate>
        </item>

        <item>
                <title>【转载】北大金秋营题目</title>
                <description>&lt;p&gt;&lt;img src=&quot;assets/b32914dfa9ec8a13aa6514b5f403918fa0ecc06a.jpg&quot; alt=&quot;enter image description here&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;assets/b663d5160924ab18e8f4a16236fae6cd7a890b8e.jpg&quot; alt=&quot;enter image description here&quot; /&gt;&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/%E6%95%B0%E5%AD%A6/2014/11/17/%25e3%2580%2590%25e8%25bd%25ac%25e8%25bd%25bd%25e3%2580%2591%25e5%258c%2597%25e5%25a4%25a7%25e9%2587%2591%25e7%25a7%258b%25e8%2590%25a5%25e9%25a2%2598%25e7%259b%25ae</link>
                <guid>http://hsfzxjy.github.io/%E6%95%B0%E5%AD%A6/2014/11/17/%e3%80%90%e8%bd%ac%e8%bd%bd%e3%80%91%e5%8c%97%e5%a4%a7%e9%87%91%e7%a7%8b%e8%90%a5%e9%a2%98%e7%9b%ae</guid>
                <pubDate>2014-11-17T21:47:39+08:00</pubDate>
        </item>

        <item>
                <title>NOIP2014总结</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;现在算起来，至少有&lt;strong&gt;220分&lt;/strong&gt;是不应该丢的——已经接近我的得分了，都是由各种脑残的错误引起的。总之，经历了这一切，我都早已习惯了。过去的事只能让它过去了，重要的是：经历了这一切，我总要明白一些什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;生活大爆炸版剪刀石头布&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=1328&quot;&gt;Link&lt;/a&gt;  得分：&lt;strong&gt;100&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题是真正的大水题，当然也是我唯一一道满分的题（欲哭无泪）。不说了，模拟就是了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;联合权值&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=1351&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;40&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题不难，关键是要将无根树转化成为有根树，做一次DFS。事实上，两个距离为2的节点，要么一个是另一个的祖父节点，要么两个节点是兄弟关系。一方面，我们在DFS时先求当前节点与祖父节点产生的联合权值（如果有的话）；另一方面，遍历当前节点的子节点。对于一个子节点：只需将其的权值乘以已遍历过的节点中权值最大者即得最大权值，而只需将当前权值乘以已遍历的节点权值之和即可得到总联合权值。因此，该算法的时间复杂度为$O(n)$。&lt;br /&gt;
但关键之处往往就在细节的地方：我自作多情地以为求出的最大联合权值也要模10007，而事实上只需将综合取模即可。在这里丢了&lt;strong&gt;60分&lt;/strong&gt;，真是不应该。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;飞扬的小鸟&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=1941&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;0&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题我能够想到的办法就是爆搜，但因为做一个优化的时候开了10000*10000的longint数组导致MLE。现在算来，如果去掉那个该死的0，我可以拿到60分。同时，求正解。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;无线电网络发射选址&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=2038&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;70&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题按理说应该是最不应该错的一道题了，但也只拿了70分。为此我还花了接近半个小时进行查错。结果发现，还是语文水平不过关——我自作主张地将题目脑补成&lt;strong&gt;“WIFI覆盖范围不得超出街道范围”&lt;/strong&gt;。这导致了有一些边缘区域成了死角。在这里我丢了&lt;strong&gt;30分&lt;/strong&gt;。下次一定要认真看题。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;道路寻找&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=2296&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;30&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题从一开始思路就是错误的：我先做了一遍DFS判断哪些点是可以经过的。而事实上：由于图中有环的存在，很多判断将具有后效性，从而导致错误。这一点我在距离考试结束还有半个小时的时候就发现了，但一直没有想到怎么更改，只能祈祷这样的数据点不要太多。&lt;br /&gt;
这是从别人那里听得的一个解法，花了10分钟来实现并且AC了，挺巧妙的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;先将所有读进来的边反向存储，并删掉所有的自环。这样起点和中点就互换了位置。这是这个算法的核心。&lt;/li&gt;
&lt;li&gt;做一次DFS，将已走过的点做标记，在遍历子节点的时候，对于每个搜到的子节点都将其cnt加一。这样一来我们可以知道起点是否能走到终点；二来如果某个节点的cnt值等于其入度，则这个节点就可以通过。&lt;/li&gt;
&lt;li&gt;做一次SPFA，这就很简单了，只对可以经过的节点做松弛。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一种逆向思维。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;解方程&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://www.luogu.org/problem/show?pid=2312&quot;&gt;Link&lt;/a&gt; 得分：&lt;strong&gt;30&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题我能想到的方法只是直接做高精度，外加数论定理优化。听说可以用求导的办法求得单调区间，然后进行二分查找。个人感觉较为复杂，日后再研究一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;细节决定成败。如果做题时细心一点，而不是过于匆忙，或许，结果就不会这样了。&lt;br /&gt;
  而事实上在这次考试中，心态也很重要。高联的失利使我渐渐变得急功近利起来。没有了高一的淡然，没有了年少时的沉稳，一切都浮躁了起来。&lt;br /&gt;
  这一切，终于结束了。但，未来，未来究竟要怎么样呢？   —— 后记&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/17/noip2014%25e6%2580%25bb%25e7%25bb%2593</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/17/noip2014%e6%80%bb%e7%bb%93</guid>
                <pubDate>2014-11-17T20:22:38+08:00</pubDate>
        </item>

        <item>
                <title>LCA之离线Tarjan算法</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;真是巧妙的算法！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比起树上倍增，Tarjan算法实现起来更为简单，一个DFS加并查集即可。缺点便是：&lt;strong&gt;需要先把所有的查询都读进来，并且要储存结果&lt;/strong&gt;。复杂度为O(n+q)。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    sets: array [1..100] of longint;
    visited: array [1..100] of Boolean;
    a: array [1..100, 1..100] of Boolean;
    questions: array [1..1000] of record
        x, y: longint;
        ans: longint;
    end;
    qn, n, i, m, x, y, root: longint;

function find(x: longint): longint;
begin
    if x = sets[x] then exit(x);
    sets[x] := find(sets[x]);
    exit(sets[x]);
end;

procedure dfs(x: longint);
var
    i: longint;
begin
    visited[x] := true;
    //对于两个节点都已访问到的询问，其结果已经出来了
    for i := 1 to qn do
    begin
        if visited[questions[i].x] and visited[questions[i].y] then
            if questions[i].x = x then
                questions[i].ans := find(questions[i].y)
            else if questions[i].y = x then
                questions[i].ans := find(questions[i].x);
    end;
    for i := 1 to n do
    begin
        if not a[i, x] or visited[i] then continue;
        dfs(i);
        sets[find(i)] := x;
    end;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    read(n, m);
    for i := 1 to n do
        sets[i] := i;
    for i := 1 to m do
    begin
        read(x, y);
        a[x, y] := true;
        a[y, x] := True;
    end;
    read(root);
    qn := 0;
    while not eof do
    begin
        inc(qn);
        read(questions[qn].x, questions[qn].y);
    end;
    dfs(root);
    for i := 1 to qn do
        writeln(questions[i].ans);

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/02/lca%25e4%25b9%258b%25e7%25a6%25bb%25e7%25ba%25bftarjan%25e7%25ae%2597%25e6%25b3%2595</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/02/lca%e4%b9%8b%e7%a6%bb%e7%ba%bftarjan%e7%ae%97%e6%b3%95</guid>
                <pubDate>2014-11-02T17:05:45+08:00</pubDate>
        </item>

        <item>
                <title>LCA树上倍增</title>
                <description>&lt;pre&gt;&lt;code&gt;var
    a: array [1..100, 1..100] of boolean;
    depth: array [1..100] of longint;
    father: array [1..100, 0..16] of longint;
    n, m, i, x, y: longint;
    root: longint;

procedure dfs(x: longint);
var
    i: longint;
    j: longint;
begin
    depth[x] := depth[father[x][0]]+1;
    j := 1;
    while 1&amp;lt;&amp;lt;j&amp;lt;=depth[x]-1 do
    begin
        father[x][j] := father[father[x][j-1]][j-1];
        inc(j);
    end;
    for i := 1 to n do
    begin
        if not a[x][i] or (father[x][0] = i) then continue;
        father[i][0] := x;
        dfs(i);
    end;
end;

procedure swap(var x, y: longint);
var
    t: longint;
begin
    t := x;
    x := y;
    y := t;
end;

function lca(x, y: longint): longint;
var
    t, j: longint;
begin
    if depth[x] &amp;lt; depth[y] then
        swap(x, y);

    t := depth[x] - depth[y];
    for j := 0 to 15 do
        if t and (1&amp;lt;&amp;lt;j) &amp;lt;&amp;gt; 0 then
            x := father[x][j];
    if x = y then
        exit(x);
    for j := 15 downto 0 do
        if father[x][j] &amp;lt;&amp;gt; father[y][j] then
        begin
            x := father[x][j];
            y := father[y][j];
        end;
    lca := father[x][0];
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    read(n, m);
    for i := 1 to m do
    begin
        read(x, y);
        a[x, y] := true;
        a[y, x] := true;
    end;
    read(root);
    father[root][0] := root;
    dfs(root);
    while not eof do
    begin
        read(x, y);
        writeln(lca(x, y));
    end;


    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/02/lca%25e6%25a0%2591%25e4%25b8%258a%25e5%2580%258d%25e5%25a2%259e</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/02/lca%e6%a0%91%e4%b8%8a%e5%80%8d%e5%a2%9e</guid>
                <pubDate>2014-11-02T16:23:13+08:00</pubDate>
        </item>

        <item>
                <title>RMQ（二进制方法）</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;问题描述：已知数组a以及若干个查询(x, y)，求a[x~y]之间的最小值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;不难发现：若取t使得$2^t\leq y-x+1$且$2^{t+1}&gt;y-x+1$，则有：&lt;br /&gt;
$$[x, x+t]\bigcup[y-t+1,y]=[x,y]$$&lt;br /&gt;
运用二进制的思想，我们只需预处理出$i~i+2^k-1$之间的最小值，即可快速完成查询。设dp[i][j]为$i~i+2^j-1$之间的最小值，则有：&lt;br /&gt;
$$dp[i][j]=min(dp[i][j-1],dp[i+2^{j-1}][j-1])$$。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    a: array [1..100000] of longint;
    dp: array [1..100000, 0..20] of longint;
    n, i: longint;

function min(x, y: longint): longint;
begin
    if x &amp;lt; y then exit(x) else exit(y);
end;

procedure init;
var
    i, j: longint;
begin
    for i := 1 to n do dp[i, 0] := a[i];
    j := 1;
    while 1&amp;lt;&amp;lt;j-1&amp;lt;=n do
    begin
        for i := 1 to n-1&amp;lt;&amp;lt;(j-1) do
            dp[i, j] := min(dp[i, j-1], dp[i+1&amp;lt;&amp;lt;(j-1), j-1]);
        inc(j);
    end;
end;

function query(x, y: longint): longint;
var
    t: longint;
begin
    t := 0;
    while (1&amp;lt;&amp;lt;(t+1)&amp;lt;=y-x+1) do inc(t);
    query := min(dp[x][t], dp[y-(1&amp;lt;&amp;lt;t)+1][t]);
end;

var
    x, y: longint;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(n);
    for i := 1 to n do read(a[i]);
    init;
    while not eof do
    begin
        read(x, y);
        writeln(query(X, y));
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/02/rmq%25ef%25bc%2588%25e4%25ba%258c%25e8%25bf%259b%25e5%2588%25b6%25e6%2596%25b9%25e6%25b3%2595%25ef%25bc%2589</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/02/rmq%ef%bc%88%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%b9%e6%b3%95%ef%bc%89</guid>
                <pubDate>2014-11-02T15:07:05+08:00</pubDate>
        </item>

        <item>
                <title>树状数组</title>
                <description>&lt;h2&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;所谓树状数组，就是将线性的数组预处理成树状的结构以降低时间复杂度。先来看一幅经典的图： &lt;img src=&quot;assets/TArry1.jpg&quot; alt=&quot;enter image description here&quot; /&gt;&lt;br /&gt;
其中的a数组为原生数组，c数组为辅助数组，计算方式为： $$c_1=a_1——{(1)}&amp;#95;{10}={(1)}&amp;#95;2$$ $$c_2=a_2+c_1——{(2)}&amp;#95;{10}={(10)}&amp;#95;2$$ $$\ldots$$              不难发现，c[k]存储的实际上是从k开始向前数k的二进制表示中右边第一个1所代表的数字个元素的和。这样写的好处便是可以利用位运算轻松计算sum。上代码。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    n, i: longint;
    a, c: array [1..10000] of longint;

//计算x最右边的1所代表的数字。
//如：lowbit(0b1100)=0b100
function lowbit(x: longint): longint; 
begin
    lowbit := x and (-x);
end;

//给a[index]加上x
procedure add(index, x: longint);
begin
    inc(a[index], x);
    while index&amp;lt;=n do 
    begin
        inc(c[index], x);
        inc(index, lowbit(index));
    end;
end;

//求a[1~index]的和
function sum(index: longint): longint;
begin
    sum := 0;
    while index&amp;gt;0 do
    begin
        inc(sum, c[index]);
        dec(index, lowbit(index));
    end;
end;

var
    s: longint;
    op: longint;
    x,y: longint;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(n);
    for i := 1 to n do
    begin
        read(a[i]);
        add(i, a[i]);
    end;

    while not eof do
    begin
        read(op);
        if op = 1 then //添加操作
        begin
           read(x, y);
           Add(x, y); 
        end
        else           //求和操作
        begin
            read(s);
            writeln(sum(s));
        end;
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/02/%25e6%25a0%2591%25e7%258a%25b6%25e6%2595%25b0%25e7%25bb%2584</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/02/%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84</guid>
                <pubDate>2014-11-02T00:31:54+08:00</pubDate>
        </item>

        <item>
                <title>二进制的启示</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;在学习数论时我们都知道：只用2的幂次可以组合出所有的正整数。这便是二进制的魅力——状态简单而又变化万千。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;实际算法中，常常有一些线性的但数据量特别大的问题，如区间求和、求最小值等。很多时候，为了把时间复杂度从$O(n^2)$甚至更高的地方降下来，我们需要对数据进行一些预处理，以提高计算的速度。在这其中，有很大一部分是来自二进制运算特点的启发。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/archives/307&quot;&gt;树状数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/archives/318&quot;&gt;RMQ&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/archives/324&quot;&gt;LCA&amp;amp;树上倍增&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/01/%25e4%25ba%258c%25e8%25bf%259b%25e5%2588%25b6%25e7%259a%2584%25e5%2590%25af%25e7%25a4%25ba</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/11/01/%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%9a%84%e5%90%af%e7%a4%ba</guid>
                <pubDate>2014-11-01T23:43:19+08:00</pubDate>
        </item>

        <item>
                <title>最小生成树（Kruscal & Prim）</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;测试位置：&lt;a href=&quot;http://codevs.cn/problem/1078/&quot;&gt;WikiOI1078&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;type
    TEdge = record
        start, terminal: longint;
        weight: int64;
    end;
    TEdgeArr = array of TEdge;

operator &amp;lt;(e1, e2: TEdge)res: boolean;
begin
    res := e1.weight &amp;lt; e2.weight;
end;

operator &amp;gt;(e1, e2: TEdge)res: Boolean;
begin
    res := e1.weight &amp;gt; e2.weight;
end;

procedure SortEdge(A: TEdgeArr; l, r: longint);
var
    i, j: longint;
    t, m: TEdge;
begin
    i := l; j := r; m := A[(i+j) &amp;gt;&amp;gt; 1];
    repeat
        while A[i]&amp;lt;m do inc(i);
        while A[j]&amp;gt;m do dec(j);
        if i&amp;lt;=j then
        begin
            t := A[i];
            A[i] := A[j];
            A[j] := t;
            inc(i); dec(j);
        end;
    until i&amp;gt;j;
    if i&amp;lt;r then SortEdge(A, i, r);
    if l&amp;lt;j then SortEdge(A, l, j);
end;

const
    INF: int64 = 1&amp;lt;&amp;lt;60 div 3;
var
    map: array [1..100, 1..100] of int64;
    n, i, j: longint;

{
    @param x: 起始搜索节点
    算法思想：用一个数组维护从各个未加入顶点到
    树的最短边长度，操作n次，每次将距离最短的
    边加入到树中，并更新与之相邻的点的距离值。
}

function prim(x: longint): int64;
{
    lowest: 储存各个节点到树的最短距离
    visited: 标记是否已加入树中
}
var
    lowest: array [1..100] of int64;
    visited: array [1..100] of boolean;
    min: int64;
    i, j, minindex: longint;
begin
    fillchar(visited, sizeof(visited), 0);
    visited[x] := true;

    //先将初始节点加入树中，更新lowest
    for i := 1 to n do
        lowest[i] := map[i, x];

    prim := 0;
    for i := 2 to n do
    begin
        min := INF;

        //找出树到外部节点最短的一条边
        //并将该边加入树中
        for j := 1 to n do
            if (not visited[j]) and (min &amp;gt; lowest[j]) then
            begin
                min := lowest[j];
                minindex := j;
            end;
        visited[minindex] := true;
        prim := prim + min;

        //对新加入的那个节点，
        //更新与其相邻的未加入树的节点的lowest值
        for j := 1 to n do
        begin
            if visited[j] then continue;
            if map[j, minindex] &amp;lt; lowest[j] then
                lowest[j] := map[j, minindex];
        end;
    end;
end;

{
    算法思想：
    1. 先将边按照长度排序。
    2. 遍历所有的边，若该边的两个顶点都在树中则跳过；
    否则将其加入树中。
}

function Kruscal: int64;
var
    Edges: TEdgeArr; 
    //并查集，储存自己的父亲，若自己为根结点则为自己
    //这是一种常用的写法：否则如果存成0的话，想把两棵
    //树并在一起需要多一步判断。
    UnionSet: array [0..100] of longint; 
    i: longint;

    procedure InitEdges; //将邻接矩阵转化为边数组。
    var
        i, j: longint;
        E: TEdge;
    begin
        for i := 1 to n do
            for j := 1 to i-1 do
            begin
                E.start := i;
                E.terminal := j;
                E.weight := map[i, j];
                SetLength(Edges, Length(Edges)+1);
                Edges[High(Edges)] := E;
            end;
        SortEdge(Edges, Low(Edges), High(Edges));
    end;

    //寻找自己的根节点，并把自己直接连到根结点上。
    function Find(x: longint): longint;
    var
        root: longint;
    begin
        root := x;
        while root &amp;lt;&amp;gt; UnionSet[root] do 
            root := UnionSet[root];
        UnionSet[x] := root;
        exit(root);
    end;

    //尝试将边的两个顶点并在一个并查集中，如果两个
    //顶点都在同一个集合中则返回False，否则执行合
    //并操作。
    function Union(x, y: longint): boolean;
    var
        px, py: longint;
    begin
        px := Find(x);
        py := Find(y);
        if px = py then
            exit(False);
        UnionSet[px] := py;
        exit(True);
    end;

begin
    Kruscal := 0;
    fillchar(UnionSet, sizeof(UnionSet), 0);
    InitEdges;
    for i := 1 to n do
        UnionSet[i] := i;
    for i := Low(Edges) to High(Edges) do
        if Union(Edges[i].start, Edges[i].terminal) then
        begin
            Kruscal := Kruscal + Edges[i].weight;
        end;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(n);
    for i := 1 to n do
        for j := 1 to n do
            read(map[i, j]);
    writeln(Kruscal);

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/26/%25e6%259c%2580%25e5%25b0%258f%25e7%2594%259f%25e6%2588%2590%25e6%25a0%2591%25ef%25bc%2588kruscal-prim%25ef%25bc%2589</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/26/%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91%ef%bc%88kruscal-prim%ef%bc%89</guid>
                <pubDate>2014-10-26T16:47:51+08:00</pubDate>
        </item>

        <item>
                <title>NOIP2013 Day1 火柴排队：快速求逆序对</title>
                <description>&lt;h2&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;涵涵有两盒火柴，每盒装有 n 根火柴，每根火柴都有一个高度。现在将每盒中的火柴各自排成一列，同一列火柴的高度互不相同，两列火柴之间的距离定义为：$\sum_{i=1}^{n}{(a_i-b_i)^2}$&lt;br /&gt;
  ，其中 ai表示第一列火柴中第 i 个火柴的高度，bi表示第二列火柴中第 i 个火柴的高度。&lt;br /&gt;
  每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 99,999,997 取模的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;这真是一道好题——断断续续想了几天才完全AC。&lt;br /&gt;
事实上，由排序不等式可知：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;当$a_i, b_i$从小到大排序时，距离最小。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个重要的信息。因此，我们只需把$a_i,b_i$进行排序，并把对应项“捆绑”成一项，再按$a_i$原有的顺序进行复原，此时，可以得到由%b_i$原先的下标组成的一个序列。也就是说，我们要求$1,2,\ldots,n$至少经过多少步才能变为该序列。这可以用逆序对来解决。&lt;br /&gt;
只可惜，传统的逆序对算法时间复杂度为$O(n^2)$，这里n可达20,0000，一定会超时（&lt;strong&gt;事实上，只过了70%的点&lt;/strong&gt;）。因此我们需寻求更好的算法。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;用归并排序求逆序对&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在归并排序的过程中，有一个步骤称为合并。在这个步骤中，需要轮流判断左右区间的第一个数的大小关系。注意到：&lt;strong&gt;左右区间已经有序，从而若左区间的第一个数大于右区间的第一个数，则左区间之后的所有数都大于右区间的第一个数&lt;/strong&gt;，从而我们可以在合并时做一些修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;procedure nx(l, r: longint);
var
    mid, i, j, k: longint;
begin
    if l = r then
    begin
        tmp[l] := a[l];
        exit;
    end;
    mid := (l + r) shr 1;
    nx(l, mid);
    nx(mid+1, r);
    i := l;
    j := mid+1;
    k := l;
    while k &amp;lt;= r do 
    begin
        if (j&amp;gt;r) or (i&amp;lt;=mid) and (a[i]&amp;lt;=a[j]) then //注意这里为等号
        begin
            tmp[k] := a[i];
            inc(i);
        end
        else
        begin
            cnt := cnt + mid - i + 1; //加上逆序数
            tmp[k] := a[j];
            inc(j);
        end;
        inc(k);
    end;
    for i := l to r do 
        a[i] := tmp[i];
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个算法复杂度为$O(nlogn)$，是一种比较理想的算法，实现起来也简单。但他有个缺点：&lt;strong&gt;会打乱原数组顺序&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;原题代码&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//AC
const
    MODN = 99999997;
type
    rec = record value, index: longint; end;
    TArr = array [1..100000] of rec;
var
    n: longint;
    a, b, c, tmp: TArr;
    ok: Boolean;
    l, r, i, j: longint;
    cnt: int64;

procedure sort(var arr: TArr; l, r: longint);
var
    i, j: longint;
    m, t: rec;
begin
    i := l;
    j := r;
    m := arr[(i+j) shr 1];
    repeat
        while arr[i].value &amp;lt; m.value do inc(i);
        while arr[j].value &amp;gt; m.value do dec(j);
        if i &amp;lt;= j then
        begin
            t := arr[i];
            arr[i] := arr[j];
            arr[j] := t;
            inc(i);
            dec(j);
        end;
    until i &amp;gt;j;
    if i &amp;lt; r then sort(arr, i, r);
    if l &amp;lt; j then sort(arr, l, j);
end;

procedure nx(l, r: longint);
var
    mid, i, j, k: longint;
begin
    if l = r then
    begin
        tmp[l] := c[l];
        exit;
    end;
    mid := (l + r) shr 1;
    nx(l, mid);
    nx(mid+1, r);
    i := l;
    j := mid+1;
    k := l;
    while k &amp;lt;= r do 
    begin
        if (j&amp;gt;r) or (i&amp;lt;=mid) and (c[i].index&amp;lt;=c[j].index) then
        begin
            tmp[k] := c[i];
            inc(i);
        end
        else
        begin
            cnt := cnt + mid - i + 1;
            cnt := cnt mod MODN;
            tmp[k] := c[j];
            inc(j);
        end;
        inc(k);
    end;
    for i := l to r do 
        c[i] := tmp[i];
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(n);
    for i := 1 to n do
    begin
        read(a[i].value);
        a[i].index := i;
    end;
    for i := 1 to n do
    begin
        read(b[i].value);
        b[i].index := i;
    end;
    sort(a, 1, n);
    sort(b, 1, n);

    for i := 1 to n do
        c[a[i].index] := b[i];

    cnt := 0;
    nx(1, n);
    writeln(cnt);

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/26/noip2013-day1-%25e7%2581%25ab%25e6%259f%25b4%25e6%258e%2592%25e9%2598%259f%25ef%25bc%259a%25e5%25bf%25ab%25e9%2580%259f%25e6%25b1%2582%25e9%2580%2586%25e5%25ba%258f%25e5%25af%25b9</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/26/noip2013-day1-%e7%81%ab%e6%9f%b4%e6%8e%92%e9%98%9f%ef%bc%9a%e5%bf%ab%e9%80%9f%e6%b1%82%e9%80%86%e5%ba%8f%e5%af%b9</guid>
                <pubDate>2014-10-26T11:42:23+08:00</pubDate>
        </item>

        <item>
                <title>NOIP2011 Day2 计算系数：快速求组合数</title>
                <description>&lt;h2&gt;&lt;strong&gt;题目大意&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入a, b, k, n, m，计算$a^n\times b^m\times C_k^n$模10007的余数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于幂数的计算并不难，关键在于对组合数$C_n^k$的计算。&lt;br /&gt;
通常来说，组合数的计算一般是这样的：$$C_n^k=\frac{n}{k}\times\frac{n-1}{k-1}\times\ldots\times\frac{n-k+1}{1}$$ 这对于单精度的计算来说是十分快捷的，但如果要对结果取模的话就不起作用了——&lt;strong&gt;取模运算对于除法不成立&lt;/strong&gt;。因此只能另辟蹊径了。&lt;br /&gt;
注意到&lt;strong&gt;加减乘法对于取模都是成立的&lt;/strong&gt;，从而想到：能否将组合数转化成加法？&lt;br /&gt;
自然而然，想到了组合恒等式：$$C_n^k=C_{n-1}^{k}+C_{n-1}^{k-1}$$ 思路到此完成。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const
    modn = 10007;
var
    a, b, k, m, n: longint;
    map: array[0..1000,0..1000] of int64; //缓存
//快速幂
function power(a, x: longint): int64;
var
    t: longint;
begin
    if x = 1 then
        exit(a);
    if x = 0 then
        exit(1);
    t := power(a, x shr 1);
    power := t * t mod modn;
    if odd(x) then
        power := power * a mod modn;
end;
//快速组合数
function C(n, k: longint): int64;
begin
    if map[n, k] &amp;gt; 0 then
        exit(map[n, k]);
    if (n &amp;lt;= k) or (k = 0) then
        C := 1
    else if k = 1 then
        C := n
    else
        C := (C(n-1, k)+C(n-1, k-1)) mod modn;
    map[n, k] := C;
end;

var
    t: longint;
    ans: int64;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(a, b, k, n, m);
    a := a mod modn;
    b := b mod modn;
    ans := power(a, n);
    ans := ans * power(b, m) mod modn;
    //C(k,n)与C(k,m)是等效的，计算较小者即可
    if n &amp;gt; m then n := m; 
    ans := ans * C(k, n) mod modn;
    writeln(ans);

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BC%96%E7%A8%8B/2014/10/25/noip2011-day1-%25e8%25ae%25a1%25e7%25ae%2597%25e7%25b3%25bb%25e6%2595%25b0%25ef%25bc%259a%25e5%25bf%25ab%25e9%2580%259f%25e6%25b1%2582%25e7%25bb%2584%25e5%2590%2588%25e6%2595%25b0</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BC%96%E7%A8%8B/2014/10/25/noip2011-day1-%e8%ae%a1%e7%ae%97%e7%b3%bb%e6%95%b0%ef%bc%9a%e5%bf%ab%e9%80%9f%e6%b1%82%e7%bb%84%e5%90%88%e6%95%b0</guid>
                <pubDate>2014-10-25T23:27:13+08:00</pubDate>
        </item>

        <item>
                <title>UVa1647 Computer Transformation</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=825&amp;amp;page=show_problem&amp;amp;problem=4522&quot;&gt;Link&lt;/a&gt; 耗时：0.679s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本质上，这是一道求数列通项的题目。我们列出前几个字符串：&lt;br /&gt;
$$01,$$&lt;br /&gt;
$$1001,$$&lt;br /&gt;
$$01101001,$$&lt;br /&gt;
$$1001011001101001,$$&lt;br /&gt;
$$\ldots$$&lt;br /&gt;
如果用$S_i$表示第i个字符串中“00”的个数，则有：&lt;br /&gt;
$$S_1=0,\ S_2=1,\ S_3=1,\ S_4=3,\ S_5=5,\ S_6=11,\ldots$$&lt;br /&gt;
经过观察可以发现有如下规律：&lt;br /&gt;
$$S_n=2\times S_{n-1}+{(-1)}^n$$&lt;br /&gt;
求通项就简单了，换个元即可：&lt;br /&gt;
$$S_n=\frac{1}{3}[{(-1)}^n+2^{n-1}]$$&lt;br /&gt;
程序采用高精度实现。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const
    JINDU = 100000;
var
    n: Integer;
//在数字前补0
procedure PrintANumber(x: longint);
var
    t: longint;
begin
    if x = 0 then
        write('00000')
    else
    begin
        t := JINDU;
        while t &amp;gt; x * 10 do 
        begin
            write(0);
            t := t div 10;
        end;
        write(x);
    end;
end;

var
    ans: array [1..300] of longint;
    len, i: integer;
//计算2^(n-1)
procedure calc2;
var
    i, x, t, mul: longint;
begin
    len := 1;
    ans[1] := 1;
    t := n-1;
    while t &amp;gt; 0 do
    begin
        if t &amp;lt; 6 then 
            mul := 1 &amp;lt;&amp;lt; t
        else 
            mul := 64;
        x := 0;
        for i := 1 to len do
        begin
            ans[i] := ans[i] * mul + x;
            x := ans[i] div JINDU;
            ans[i] := ans[i] mod JINDU;
        end;
        if x &amp;gt; 0 then
        begin
            inc(len);
            ans[len] := x;
        end;
        dec(t, 6);
    end; 
end;
//除以3
procedure div3;
var
    i, x, t: longint;
begin
    i := len;
    x := 0;
    while i &amp;gt; 0 do
    begin
        t := (x * JINDU + ans[i]);
        ans[i] := t div 3;
        x := t mod 3;
        dec(i);
    end;
    while ans[len] = 0 do dec(len);
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    while not eof do
    begin
        readln(n);
        if n=1 then   //特殊情况处理
        begin
            writeln(0);
            continue;
        end;
        fillchar(ans, sizeof(ans), 0);
        calc2;
        if odd(n) then
            dec(ans[1])
        else
            inc(ans[1]);
        div3;
        write(ans[len]);
        for i := len-1 downto 1 do 
            PrintANumber(ans[i]);
        writeln;
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BC%96%E7%A8%8B/2014/10/24/uva1647-computer-transformation</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BC%96%E7%A8%8B/2014/10/24/uva1647-computer-transformation</guid>
                <pubDate>2014-10-24T18:50:30+08:00</pubDate>
        </item>

        <item>
                <title>Sublime configuration for Pascal</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;鉴于U盘中Sublime的配置常常莫名其妙地消失，在此将其记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;cmd&quot;: [&quot;fpc&quot;, &quot;-S2&quot;, &quot;${file}&quot;, &quot;-o${file_path}/${file_base_name}.exe&quot;],
    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,
    &quot;working_dir&quot;: &quot;${file_path}&quot;,
    &quot;selector&quot;: &quot;source.pascal&quot;,

    &quot;variants&quot;: [
        {
            &quot;name&quot;: &quot;Run&quot;,
            &quot;cmd&quot;: [&quot;cmd&quot;, &quot;/c&quot;, &quot;fpc&quot;, &quot;-S2&quot;, &quot;${file}&quot;, &quot;-o${file_path}/${file_base_name}.exe&quot;, 
 &quot;&amp;amp;&amp;amp;&quot;, &quot;${file_path}/${file_base_name}.exe&quot;]
        }
    ],

    &quot;osx&quot;:
    {
        &quot;path&quot;: &quot;/usr/local/bin:/usr/bin:/bin:${path}&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/sublime/2014/10/23/sublime-configuration-for-pascal</link>
                <guid>http://hsfzxjy.github.io/sublime/2014/10/23/sublime-configuration-for-pascal</guid>
                <pubDate>2014-10-23T21:22:54+08:00</pubDate>
        </item>

        <item>
                <title>UVa11526 H(n)</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=27&amp;amp;problem=2521&amp;amp;mosmsg=Submission%20received%20with%20ID%2014374168&quot;&gt;Link&lt;/a&gt; 耗时：2.232s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;粗看题目，不过就是要求这样一个式子：$\sum_{i=1}^n{[\frac{n}{i}]}$的值。但&lt;strong&gt;注意到&lt;/strong&gt;：题目给的数据范围极大，有$2^{31}-1$之多，若遍历计算，则时间复杂度为$O(n)$，将严重超时，不可取。&lt;br /&gt;
而事实上，通过尝试我们可以发现：$\sum_{i=1}^{n}{[\frac{n}{i}]}=2*\sum_{i=1}^{\sqrt n}{[\frac{n}{i}]}-{[\sqrt n]}^2$，这是一个重要的结论。因为这条式子一旦成立，时间复杂度即可从$O(n)$降为$O(\sqrt n)$，这是一个极为可观的改善。下面我们来证明一下这个结论：&lt;br /&gt;
事实上，$$\sum_{i=[{\sqrt n}]+1}^{n}{[\frac{n}{i}]}$$ $$=1\times(n-[\frac{n}{2}])+2\times([\frac{n}{2}]-[\frac{n}{3}])+\ldots+[\sqrt{n}]\times([\frac{n}{\sqrt{n}}]-{[\frac{n}{\sqrt n}+1]})$$ $$=n+[\frac{n}{2}]+[\frac{n}{3}]+\ldots+[\frac{n}{\sqrt n}]-[\sqrt n]\times[\frac{n}{[\sqrt n]+1}]$$ $$=\sum_{i=1}^{[\sqrt n]}{[\frac{n}{i}]}-{[\sqrt n]}^2$$ 从而，命题得证。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    n, _, i: longint;

function h: int64; inline;
var
    k, t: longint;
begin
    h := 0;
    t := trunc(sqrt(n));
    k := 1;
    while k &amp;lt;=t do
    begin
        h := h + n div k;
        inc(k);
    end;
    h := h * 2 - t * t;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(_);
    while _ &amp;gt; 0 do
    begin
        dec(_);
        readln(n);
        if n &amp;lt;= 0 then
            writeln(0)
        else
            writeln(h);
    end;

    close(input);
    close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BC%96%E7%A8%8B/2014/10/19/uva11526-hn</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BC%96%E7%A8%8B/2014/10/19/uva11526-hn</guid>
                <pubDate>2014-10-19T00:03:37+08:00</pubDate>
        </item>

        <item>
                <title>UVa817 According to Bartjens</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=10&amp;amp;problem=758&amp;amp;mosmsg=Submission%20received%20with%20ID%2014367065&quot;&gt;Link&lt;/a&gt; 状态：&lt;strong&gt;WA&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;做了两个小时，很可惜最终还是WA了。非常奇怪——和网上的C++代码运行结果完全一样，但却WA了。不过，在这里我还是记录一下解题的过程。&lt;br /&gt;
这道题数据量很小，直接爆搜每个空位，用*, +, -, #0来代表符号或不填。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const
    operators: array [1..4] of char = ('*', '+', '-', #0); //符号
var
    s: string;
    _, n: integer;
    op: array [0..10] of char;
    yes: Boolean;

function toValue(ch: char): integer;
begin
    exit(ord(ch) - ord('0'));
end;

procedure calcAndPrint; 
var
    numtop, opstop: Integer;  //数字栈，符号栈
    num: array [1..10] of longint;
    ops: array [1..10] of char;
    i: integer;
begin
    i := 1;
    numtop := 1;
    num[numtop] := toValue(s[1]);
    opstop := 0;
    while i &amp;lt;= n do
    begin
        while (i &amp;lt; n) and (op[i] = #0) do
        begin
            inc(i);
            num[numtop] := num[numtop] * 10 + toValue(s[i]);
        end;
        if (op[i] in ['+', '-']) or (i &amp;gt;= n) then
        begin
            while (opstop &amp;gt; 0) and (ops[opstop] = '*') do
            begin
                dec(opstop);
                num[numtop - 1] := num[numtop] * num[numtop -1];
                dec(numtop);
            end;
        end;
        if i &amp;gt;= n then break;
        inc(opstop);
        ops[opstop] := op[i];
        inc(i);
        inc(numtop);
        num[numtop] := toValue(s[i]);
    end;
    i := 1;
    while i &amp;lt; numtop do
    begin
        if ops[i] = '+' then
            num[i+1] := num[i] + num[i+1]
        else
            num[i+1] := num[i] - num[i+1];
        inc(i);
    end;
    if (num[numtop] = 2000) and (opstop &amp;gt; 0) then
    begin
        yes := True;
        write('  ');
        for i := 1 to n do
        begin
            write(s[i]);
            if op[i] &amp;lt;&amp;gt; #0  then
                write(op[i]);
        end;
        writeln('=');
    end;
end;

procedure dfs(t: integer); //搜索第t个位置
var
    i: Integer;
    ch: char;
begin
    if t = n then
    begin
        calcAndPrint;
        exit;
    end;
    for i := 1 to 4 do
    begin
        ch := operators[i];
        if (ch = #0) and (s[t] = '0') and ((t = 1) or (t &amp;gt; 1) and (op[t-1] &amp;lt;&amp;gt; #0)) then continue;
        op[t] := ch;
        dfs(t+1);
    end;
end;

var
    i: Integer;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(s);
    _ := 0;
    while not eof and (s[1] &amp;lt;&amp;gt; '=') do
    begin
        i := 1;
        while not (s[i] in ['0'..'9', '=']) do
        begin
            inc(i);
        end;
        delete(s, 1, i-1);
        n := pos('=', s) - 1;
        inc(_);
        writeln('Problem ', _);
        yes := False;
        fillchar(op, sizeof(op), 0);
        dfs(1);
        if not yes then
            writeln('  IMPOSSIBLE');
        readln(s);
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/17/uva817-according-to-bartjens</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/17/uva817-according-to-bartjens</guid>
                <pubDate>2014-10-17T20:05:06+08:00</pubDate>
        </item>

        <item>
                <title>UVa225 Golygons</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=4&amp;amp;problem=161&amp;amp;mosmsg=Submission%20received%20with%20ID%2014355705&quot;&gt;Link&lt;/a&gt; 耗时：0.699s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dfs(t, x, y, d, s)&lt;/code&gt;表示当前走了t步，在(x,y)，上一个方向为d，s为一个求和用的辅助变量。&lt;br /&gt;
当前位置无法走完剩下的路时直接回溯。可节省接近2s的时间。&lt;br /&gt;
&lt;strong&gt;ps: 这道题虽然没有明说每个城市只走一次，但它的确那样判了，这一点坑了我好久。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//Accepted.
const
    dx: array [1..4] of integer = (1, 0, 0, -1);
    dy: array [1..4] of integer = (0, 1, -1, 0);
    dir: array [1..4] of char = ('e', 'n', 's', 'w');

var
    a: array [1..50, 1..2] of integer; //障碍物
    k, i, n, _, x, y: integer;
    ans: array [1..20] of char;
    tot: longint;
    vis: array [-220..220, -220..220] of boolean;

function judge(x1, y1, x2, y2: longint): Boolean; //判断刚刚走过的路上是否有障碍物
var
    i: Integer;
begin
    judge := False;
    if x1 = x2 then
    begin
        for i := 1 to k do 
            if (a[i, 1] = x1) and ((a[i, 2] - y1)*(a[i, 2] - y2) &amp;lt;= 0) then exit;
    end
    else
        for i := 1 to k do
            if (a[i, 2] = y2) and ((a[i, 1] - x1)*(a[i, 1] - x2) &amp;lt;= 0) then exit; 
    judge := True;
end;

procedure print;
var
    i: Integer;
begin
    for i := 1 to n do write(ans[i]);
    writeln;
    inc(tot);
end;

procedure dfs(t, x, y, d, s: integer);
var
    i, sum: Integer;
    tx, ty: longint;
begin
    if t = n then 
    begin
        if (x = 0) and (y = 0) then print;
        exit;
    end;

    sum := s - t - 1;
    inc(t);

    for i := 1 to 4 do
    begin
        if (i = d) or (i + d = 5) then continue;   //方向相同或相反
        tx := x + dx[i] * t;
        ty := y + dy[i] * t;
        if vis[tx, ty] then continue;              //走过 
        if abs(tx) + abs(ty) &amp;gt; sum then continue;  //回不去，剪枝
        if not judge(x, y, tx, ty) then continue;  //有障碍物
        ans[t] := dir[i];
        vis[tx, ty] := True;
        dfs(t, tx, ty, i, sum);
        vis[tx, ty] := False;
    end;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);

    readln(_);
    while _ &amp;gt; 0 do 
    begin
        dec(_);
        read(n, k);
        fillchar(vis, sizeof(vis), 0);
        for i := 1 to k do 
            read(a[i, 1], a[i, 2]);
        fillchar(ans, sizeof(ans), 0);
        tot := 0;
        dfs(0, 0, 0, -1, n * (n+1) div 2);
        writeln('Found ', tot, ' golygon(s).');
        writeln;
    end;

    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/15/uva225-golygons</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/15/uva225-golygons</guid>
                <pubDate>2014-10-15T22:04:51+08:00</pubDate>
        </item>

        <item>
                <title>NOIP初赛基础知识</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;从今天起至10月11日，持续连载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;关于计算机&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;ENIAC&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;出现于&lt;strong&gt;1946年&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;是&lt;strong&gt;最早&lt;/strong&gt;的计算机。&lt;/li&gt;
&lt;li&gt;是&lt;strong&gt;电子管&lt;/strong&gt;计算机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;阶码&lt;/strong&gt;，即浮点数的指数部分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IPv6是128位的。&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;求补码：二进制下：&lt;strong&gt;各位取反再加1&lt;/strong&gt; 或 &lt;strong&gt;把原码减1再取反&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;关于算法&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;各种排序的时间复杂度&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;快速排序：$O(nlogn)$，最坏为$O(n^2)$。&lt;/li&gt;
&lt;li&gt;冒泡排序：$O(n^2)$。&lt;/li&gt;
&lt;li&gt;归并排序：$O(nlogn)$。&lt;/li&gt;
&lt;li&gt;计数排序：$O(n)$。&lt;/li&gt;
&lt;li&gt;插入排序：$O(n^2)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;关于树&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完全二叉树 vs 满二叉树：&lt;strong&gt;完全二叉树最后一层不一定满&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;前序遍历：&lt;strong&gt;中左右&lt;/strong&gt;；中序遍历：&lt;strong&gt;左中右&lt;/strong&gt;；后序遍历：&lt;strong&gt;左右中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;节点数为n的二叉树上，有两个节点的至多有$[(n+1)/2]$个。&lt;/li&gt;
&lt;li&gt;节点数为n的完全二叉树有$log(n)$层，节点序号大于$n\ div\ 2$的为叶节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;计算机史&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;熵在&lt;strong&gt;1948年由克劳德·香农引入信息通信领域。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;杂项&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;3G网络&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;三种标准：&lt;strong&gt;CDMA2000、WCDMA、TD-SCDMA&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;4G网络&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类别：&lt;strong&gt;TD-LTE和FDD-LTE&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;N/NP问题&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;P：复杂度类P包含所有那些可以由一个确定型图灵机&lt;strong&gt;在多项式表达的时间&lt;/strong&gt;内解决的问题。&lt;/li&gt;
&lt;li&gt;NP：是指可以在多项式时间内被非确定机(他可以猜,他总是能猜到最能满足你需要的那种选择,如果你让他解决n皇后问题,他只要猜n次就能完成----每次都是那么幸运)解决的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;NOIP申诉条件（操蛋去年居然考了！）&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;非公示期限内提出的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;与个人名次、他人成绩和他人名次有关的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;未通过NOI科学委员会提交的、来自非正规渠道的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;因操作系统、语言环境的具体差异引起成绩变动的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;对使用随机数和随机算法的程序的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;发布成绩与选手使用非规范环境和数据、参数评测出的成绩不同，并因此提出的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;在与标准测试环境相同的机器上，自测用时超过题目时限的5%，并由此提出的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;以修改过的程序或答案为依据的申诉，不予受理； &lt;/li&gt;
&lt;li&gt;因选手错误而导致答案文件名错误，或者源文件存放目录结构不规范，且所提出的申诉与此有关的，不予受理。 &lt;/li&gt;
&lt;li&gt;未描述清楚自测状况，如“与老师评测有出入”，“感觉评测结果有错”等，不予受理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;NOIP官网：&lt;strong&gt;http://www.noi.cn/&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;中国互联网信息中心的缩写：&lt;strong&gt;CNNIC&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/08/noip%25e5%2588%259d%25e8%25b5%259b%25e5%259f%25ba%25e7%25a1%2580%25e7%259f%25a5%25e8%25af%2586</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/08/noip%e5%88%9d%e8%b5%9b%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86</guid>
                <pubDate>2014-10-08T22:03:30+08:00</pubDate>
        </item>

        <item>
                <title>UVa12219 Common Subexpression Elimination</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=3371&quot;&gt;Link&lt;/a&gt; 状态：&lt;strong&gt;Runtime Error&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这题做的可真够久的，整整三个小时。但即便如此，还是只过了一部分的点，另一部分报运行时错误——估计是哈希表设计的不太好。但这确实是一道好题，因此，在睡觉前决定记录一下。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;很容易便想到：用一个三元组$(x,y,z)$表示节点，表示内容为x的节点下跟着标号为y和z的左右子树。这样一来，一类相同的子树便可以唯一确定了，而不必每构造一棵子树就把整棵树遍历一遍。&lt;br /&gt;
对于三元组的储存，刚开始图方便，用了数组。查找也是用了$O(n)$的线性查找。磕磕碰碰写了两个多小时然后兴冲冲地提交，结果TLE了…………没办法，只好又花了半个小时写了一个哈希表，然后就是上文说过的情况了：&lt;strong&gt;Runtime Error204&lt;/strong&gt;。可能是哈希数组过大的原因，日后再微调一下，今天实在是没有脑子了。&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const
  maxn = 20000;
type
  NodeRec = record
    Value: string;
    l, r, index: longint;
  end;
  Node = record
     left, right: longint;   //Index of left and right child in the `tree` array, -1 for none.
     Rec: NodeRec;
     index: longint;
  end;
  //以下为哈希表的定义
  _PNode = ^_Node;
  _Node = record
    n: Node;
    next: _PNode;
  end;

  HashTable = object
    arr: array [0..maxn] of _PNode;
    function hash(n: NodeRec): longint;
    procedure add(n: Node);
    procedure clear;
    function find(n: NodeRec): longint;
  end;

procedure HashTable.clear;
var
  i: longint;
  p, q: _PNode;
begin
  for i := 0 to maxn do
  begin
    p := arr[i];
    while p&amp;lt;&amp;gt;nil do
    begin
      q := p^.next;
      dispose(p);
      p := q;
    end;
  end;
  fillchar(arr, sizeof(arr),0);
end;

function cmp(r1, r2: NodeRec): Boolean;
begin
  cmp := (r1.l = r2.l) and (r1.r = r2.r) and (r1.Value = r2.Value);
end;

function HashTable.hash(n: NodeRec): longint;
var
  i: longint;
begin
  hash := 0;
  for i := 1 to length(n.Value) do
    hash := (hash*5 + ord(n.Value[i]) - ord('a')) mod maxn;
  hash := (hash + n.l * 10 + n.r * 5) mod maxn;
end;

procedure HashTable.add(n: Node);
var
  h: longint;
  p, q: _PNode;
begin
  h := hash(n.rec);
  new(q);
  fillchar(q^, sizeof(_Node), 0);
  q^.next := arr[h];
  q^.n := n;
  arr[h] := q;
end;

function HashTable.find(n: NodeRec): longint;
var
  p: _PNode;
begin
  find := -1;
  p := arr[hash(n)];
  while (p&amp;lt;&amp;gt;nil) and not cmp(n, p^.n.rec) do p := p^.next;
  if p &amp;lt;&amp;gt; nil then
    find := p^.n.index;
end;
//哈系表定义结束
var
  inputs: Ansistring;
  _: longint;
  tree: array [1..50001] of Node;
  cur: longint;              //The current pointer of the input string.
  num: longint;              //The current number of the `tree` array.
  ls: longint;
  t: longint;
  tot: longint;
  ht: HashTable;

function build: longint; //建树
label lb;
var
  rec: NodeRec;
  i,j,l,r: longint;
begin
  l := 0;
  r := 0;
  fillchar(rec, sizeof(rec), 0);
  inc(tot);
  rec.index := tot;
  while (cur&amp;lt;=ls) and (inputs[cur] in ['a'..'z']) do
  begin
    rec.Value := rec.Value+inputs[cur];
    inc(cur);
  end;
  if cur&amp;gt;ls then goto lb;    //。。。这里被迫跳转控制流，由于实在不想多谢，就用了臭名昭著的label
  if inputs[cur] = '(' then
  begin
    inc(cur);
    l := build();
    rec.l := tree[l].rec.index;
    inc(cur);
    r := build();
    rec.r := tree[r].rec.index;
    inc(cur);
  end;
  j := ht.find(rec);
  if j&amp;gt;0 then
  begin
    dec(tot);
    exit(j);
  end
  else
  begin
lb:
    inc(num);
    tree[num].left := l;
    tree[num].right := r;
    tree[num].rec := rec;
    tree[num].index := num;
    ht.add(tree[num]);
    exit(num);
  end;
end;

procedure print(n: longint);
begin
  if tree[n].rec.index &amp;gt; t then
  begin
    write(tree[n].rec.Value);
    t := tree[n].rec.index;
  end
  else
  begin
    write(tree[n].rec.index);
    exit;
  end;
  if tree[n].right = 0 then
    exit;
  write('(');
  print(tree[n].left);
  write(',');
  print(tree[n].right);
  write(')');
end;
begin
  assign(input, 'main.in'); reset(input);
  assign(output, 'main.out'); rewrite(output);
  readln(_);
  fillchar(ht.arr, sizeof(ht.arr),0);
  while _&amp;gt;0 do
  begin
    dec(_);
    readln(inputs);
    fillchar(tree, sizeof(tree), 0);
    ht.clear;
    ls := length(inputs);
    cur := 1;  num := 0; tot := 0;
    build;
    t := 0;
    print(num);
    writeln;
  end;
  close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/06/uva12219-common-subexpression-elimination</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/06/uva12219-common-subexpression-elimination</guid>
                <pubDate>2014-10-06T00:20:18+08:00</pubDate>
        </item>

        <item>
                <title>UVa536 Recovery</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=7&amp;amp;page=show_problem&amp;amp;problem=477&quot;&gt;Link&lt;/a&gt; 耗时: 0.012s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;真是疯玩了几天，脑袋都残了，一道弱智题做了近一个小时。&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    pre, mid, s: string;
    tree: array [1..50] of record
        l, r: integer;
        ch: char;
    end;
    cur: integer;
function init: integer;
var
    m: integer;
begin
    readln(s);
    m := length(s) &amp;gt;&amp;gt; 1 + 1;
    pre := Copy(s, 1, m-1);
    mid := Copy(s, m+1, length(s));
    init := m-1;
end;
function build(l1, l2, r2: integer): integer;
var
    m,len: integer;
    t: integer;
begin
    if l2 &amp;gt; r2 then exit(0); //该子树不存在。**这个地方坑了我很久**
    inc(cur);
    t := cur;      // 这里也坑了我，当下面构造完左右子树后，cur已经变了，所以要缓存起来
    build := t;  
    tree[t].ch := pre[l1]; 
    if r2-l2 = 0 then //叶节点
        exit;
    m := pos(pre[l1], mid); //在中序遍历中找根节点
    len := m - l2;
    tree[t].l := build(l1+1, l2, m-1); //构造左子树
    tree[t].r := build(l1+len+1, m+1, r2); //构造右子树
end;
procedure print(x: integer);
begin
    if x = 0 then exit;
    print(tree[x].l);
    print(tree[x].r);
    write(tree[x].ch);
end;
begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);
    while not eof do
    begin
        fillchar(tree, sizeof(tree), 0);
        cur := 0;
        build(1, 1, init);
        print(1);
        writeln;
    end;
    close(input);
    close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/06/uva536-recovery</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/06/uva536-recovery</guid>
                <pubDate>2014-10-06T00:03:04+08:00</pubDate>
        </item>

        <item>
                <title>UVa11582 Colossal Fibonacci Numbers! && 大数操作</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=27&amp;amp;problem=2629&amp;amp;mosmsg=Submission%20received%20with%20ID%2014290914&quot;&gt;Link&lt;/a&gt; 耗时：0.139s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这道题的主要思路就是打表，看看Fibonacci数列模n几个一循环。但由于这题给的数太大了，从而在细节上耗了很久。在此记录一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var
    x: qword;
    y: longint;
begin
    x := 1&amp;lt;&amp;lt;64-1;
    y := 100;
    x := x mod y; //报错201
    x := x mod qword(y); //正确
end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var
    a,b: qword;
    _, n, i, k, cnt: longint;
    f: array [1..1000000] of longint;

function superMod(a, b: qword; m: longint): longint;
var
    x: qword;
begin
    if b = 0 then
        exit(1);
    x := superMod(a, b shr 1, m);
    superMod := x * x mod m;
    if odd(b) then
        superMod := superMod * a mod m;
end;

begin
    assign(input, 'main.in'); reset(input);
    assign(output, 'main.out'); rewrite(output);
    readln(_);
    while _ &amp;gt; 0 do
    begin
        dec(_);
        readln(a, b, n);
        if a = 0 then
        begin
            writeln(0);
            continue;
        end;
        if n = 1 then
        begin
            writeln(0);
            continue;
        end;
        f[1] := 1;
        f[2] := 1;
        cnt := 2;
        while not ((f[cnt-1] = 1) and (f[cnt] = 0)) do
        begin
            inc(cnt);
            f[cnt] := (f[cnt-1] + f[cnt-2]) mod n;
        end;
        //while x &amp;gt; int64(1 &amp;lt;&amp;lt;60) do
        //    x := x - int64((cnt &amp;lt;&amp;lt; 59));
        a := a mod qword(cnt);
        k := superMod(a, b, cnt);
        writeln(f[k]);
    end;
    close(output); close(input);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/01/uva11582-colossal-fibonacci-numbers-%25e5%25a4%25a7%25e6%2595%25b0%25e6%2593%258d%25e4%25bd%259c</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/01/uva11582-colossal-fibonacci-numbers-%e5%a4%a7%e6%95%b0%e6%93%8d%e4%bd%9c</guid>
                <pubDate>2014-10-01T19:12:27+08:00</pubDate>
        </item>

        <item>
                <title>扩展欧几里得算法</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;今天开始学习数论方面的算法。这部分在NOIP中并不常出现，即使出现了也不会像高联这么难（。。。）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;什么是扩展欧几里得算法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;所谓欧几里得算法，实际上就是辗转相除法——求两个数最大公约数的一种高效算法。而扩展欧几里得算法则是来源于于一类方程的解决：&lt;br /&gt;
$$ax+by=gcd(a,b)$$&lt;br /&gt;
这有点像是&lt;strong&gt;裴蜀定理&lt;/strong&gt;的一般形式。和裴蜀定理类似，这类方程也有无数多个整数解。如何高效率地求得它的一组特解呢？&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;procedure gcd_ex(a, b: longint; var d: longint; var x, y: longint);
begin
    if b = 0 then
    begin
        d := a;
        x := 1;
        y := 0;
        exit;
    end;
    gcd_ex(b, a mod b, d, y, x); //重要
    y := y-(a div b) * x;
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;详解&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;乍一看，算法似乎和一般欧几里得算法很是相似：都是递归实现，参数传递过程中都体现了“辗转相除”的思想。那为什么这个算法是正确的呢？&lt;/p&gt;
&lt;p&gt;这里先解释一下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a：方程中的参数a&lt;/li&gt;
&lt;li&gt;b：方程中的参数b&lt;/li&gt;
&lt;li&gt;d：即&lt;code&gt;gcd(a,b)&lt;/code&gt;。由于和辗转相除法的相似性，在这里最大公约数也可以“顺便”算出。当然，去掉也无大碍&lt;/li&gt;
&lt;li&gt;x&amp;amp;y：方程的一组特解(x, y)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面解释标注了&lt;strong&gt;重要&lt;/strong&gt;的那行代码。&lt;/p&gt;
&lt;p&gt;假设方程 $ax+by=gcd(a,b)$ 有一组特解$(x_0,y_0)$。则有$ax_0+by_0=gcd(a,b)$。&lt;br /&gt;
由最大公约数原理可知：$gcd(a,b)=gcd(b, a\ mod\ b)$。从而有$ax_0+by_0=gcd(b,a\ mod\ b)$。&lt;br /&gt;
又方程：$bx+(a\ mod\ b)y=gcd(b,a\ mod\ b)$一定有整数解，设其为$(x_1,y_1)$。则有&lt;br /&gt;
$$ax_0+by_0=gcd(b,a\ mod\ b)=bx_1+(a\ mod\ b)y_1$$即$$ax_0+by_0=bx_1+(a-(a\ div\ b)*b)y_1$$即$$a(x_0-y_1)=b(x_1-(a\ div\ b)y_1-y_0)$$由恒等原理可知：$$x_0=y_1$$$$y_0=x_1-(a\ div\ b)y_1$$。&lt;br /&gt;
因此，当$a,b\neq0$时，$x,y$的值可以递归求得。递归边界为：$b=0$时$x=1,y=0$。&lt;br /&gt;
注意到上面的算法用到了一个技巧：在递归传参数的时候将y,x调换了。这样做的好处是节省了一个中间变量用来储存$y_1$，否则在计算$y_0$时$y_1$也被覆盖了。从而使算法更加的精简。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;应用&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算几何中求整点的问题&lt;/li&gt;
&lt;li&gt;求一元一次同余方程$a\equiv b\pmod{m}$的一组特解。（即方程$ax+my=b$的一组特解）&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/01/%25e6%2589%25a9%25e5%25b1%2595%25e6%25ac%25a7%25e5%2587%25a0%25e9%2587%258c%25e5%25be%2597%25e7%25ae%2597%25e6%25b3%2595</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/01/%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95</guid>
                <pubDate>2014-10-01T16:55:50+08:00</pubDate>
        </item>

        <item>
                <title>UVa10285 Cake Slicing</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=825&amp;amp;page=show_problem&amp;amp;problem=4504&quot;&gt;Link&lt;/a&gt;  耗时：1.825s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题做的可真够久的：前前后后加起来将近有两个小时，因此当AC的那一刻，自己心中还是挺自豪的。&lt;br /&gt;
事实上，这是一道复杂一点的区间型动态规划，之所以说“复杂”，是因为它的状态转移是&lt;strong&gt;二维&lt;/strong&gt;的：切蛋糕既可以横切，也可以纵切。由此我想到了分治算法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设一个矩形它所需要切的刀数是f，则f可以由组成该矩形的小矩形的f值决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，这个问题具有最优子结构。由于每个状态为一个矩形，因此需要4个维度来记录状态（及左上、右下两个顶点）。下面是横切时的状态转移方程，纵切时同理可得：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;f(up, down, left, right) = min{f(up, i, left, right) + f(i, down, left, right) + right - left} (i = up + 1 .. down -1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{$R-}
const INF = maxint div 5; //正无穷
var
    f: array [0..20, 0..20, 0..20, 0..20] of integer;
    cherries: array [1..500, 1..2] of integer;
    map: array [0..20, 0..20] of boolean;
    n, m, i, k: integer;

function min(x, y: integer): integer; inline;
begin
    if x&amp;lt;y then exit(x) else exit(y);
end;

function cherryin(u, d, l, r: integer): integer; inline; //判断矩形内有没有樱桃
var
    i, j: integer;
begin
    cherryin := 0;
    for i := u+1 to d do
        for j := l+1 to r do
            if map[i, j] then
            begin
                inc(cherryin);
                if cherryin = 2 then exit;
            end;
end;

function dp(u, d, l, r: integer): integer;
var
    b: integer;
    i: integer;
begin
    if f[u, d, l, r] &amp;lt;&amp;gt; -1 then
        exit(f[u,d , l, r]);
    b := cherryin(u, d, l, r);
    if b = 1 then
    begin
        f[u, d, l, r] := 0;
        exit(0);
    end;
    if b = 0 then
    begin
        f[u, d, l, r] := INF;
        exit(INF);
    end;
    dp := INF;
    for i := u+1 to d-1 do
        dp := min(dp, dp(u, i, l, r)+dp(i, d, l, r)+r-l);
    for i := l+1 to r-1 do
        dp := min(dp, dp(u, d, l, i)+dp(u, d, i, r)+d-u);
    f[u, d, l, r] := dp;
end;

var
    _: integer;

begin
    assign(input, 'main.in');reset(input);
    assign(output, 'main.out');rewrite(output);
    _ := 0;
    readln(n, m, k);
    while n&amp;gt;0 do
    begin
        inc(_);
        fillchar(map, sizeof(map), 0);
        fillchar(f, sizeof(f), -1);
        for i := 1 to k do
        begin
            readln(cherries[i, 1], cherries[i, 2]);
            map[cherries[i, 1], cherries[i, 2]] := true;
        end;
        writeln('Case ',_,': ', dp(0,n,0,m));
        readln(n, m, k);
    end;
    close(input);close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/01/uva10285-cake-slicing</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/10/01/uva10285-cake-slicing</guid>
                <pubDate>2014-10-01T12:20:18+08:00</pubDate>
        </item>

        <item>
                <title>UVa10285 Longest Run on a Snowboard</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=14&amp;amp;problem=1226&amp;amp;mosmsg=Submission%20received%20with%20ID%2014282250&quot;&gt;Link&lt;/a&gt; 耗时：0.028s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一道简单的动态规划，主要思路就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;用f[i,j]表示到达(i,j)的最长路径的长度。&lt;/strong&gt;找到每个最高点，从其开始向四周的低处搜索。如果该点已搜过并且f值大于当前长度则退出回溯。直到达到某个最低点为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不多说了，直接上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const
    delta :array [1..4, 1..2] of integer = ((-1, 0), (1, 0), (0, 1), (0, -1)); //四个方向向量
var
    _: Integer;
    name: string;
    n, m, i, j, x: Integer;
    ans: longint;
    map: array [0..101, 0..101] of integer;
    f: array [1..100, 1..100] of longint;

function max(x, y: longint): longint; inline;
begin
    if x&amp;gt;y then exit(x) else exit(y);
end;

function can(x, y: integer): Boolean; inline; //判断是否是最高点
var
    i: Integer;
    tx, ty: integer;
begin
    can := true;
    for i := 1 to 4 do
    begin
        tx := x + delta[i, 1];
        ty := y + delta[i, 2];
        can := can and (map[x, y] &amp;gt;= map[tx, ty]);
        if not can then break;
    end;
end;

procedure dp(x, y: integer; len: longint); //回溯进行动态规划
var
    i: Integer;
    tx, ty: integer;
begin
    inc(len);
    if f[x, y] &amp;gt; len then exit;
    f[x, y] := len;
    ans := max(ans, len);
    for i := 1 to 4 do
    begin
        tx := delta[i, 1] + x;
        ty := delta[i, 2] + y;
        if (tx = 0) or (tx &amp;gt; n) or (ty = 0) or (ty &amp;gt; m) then continue;
        if map[x, y] &amp;lt;= map[tx, ty] then continue;
        dp(tx, ty, len);
    end;
end;

procedure ReadAndProcessName; //处理那行该死的名字！！
var
    s: string;
    i: integer;
begin
    readln(s);
    i := 1;
    name := '';
    n := 0;
    m := 0;
    while s[i] &amp;lt;&amp;gt; ' ' do
    begin
        name := name + s[i];
        inc(i);
    end;
    inc(i);
    while s[i] &amp;lt;&amp;gt; ' ' do
    begin
        n := n * 10 + ord(s[i]) - ord('0');
        inc(i);
    end;
    inc(i);
    while i &amp;lt;= length(s) do
    begin
        m := m * 10 + ord(s[i]) - ord('0');
        inc(i);
    end;
end;

begin
    assign(input, 'main.in');reset(input);
    assign(output, 'main.out');rewrite(output);
    readln(_);
    while _&amp;gt;0 do
    begin
        dec(_);
        fillchar(map, sizeof(map), 0);
        ReadAndProcessName;

        for i := 1 to n do
            for j := 1 to m do
            begin
                read(x);
                map[i, j] := x+1;
            end;
        readln;

        fillchar(f, sizeof(f), 0);
        ans := 0;
        for i := 1 to n do
            for j := 1 to m do
                if can(i, j) then
                    dp(i, j, 0);
        writeln(name, ': ', ans);
    end;
    close(input);close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/29/uva10285-longest-run-on-a-snowboard</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/29/uva10285-longest-run-on-a-snowboard</guid>
                <pubDate>2014-09-29T22:00:35+08:00</pubDate>
        </item>

        <item>
                <title>关于Ubuntu突然无法连接Wifi的解决方案</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;事实上我也不知道发生了什么，大概是几天前插了“小度Wifi”的缘故。没有任何征兆地，Wifi就用不了了。 其实我也不知道原理，大概是某个驱动被刷掉了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是从网上找来的答案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install wicd-daemon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;做个记录。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/ubuntu/2014/09/27/%25e5%2585%25b3%25e4%25ba%258eubuntu%25e7%25aa%2581%25e7%2584%25b6%25e6%2597%25a0%25e6%25b3%2595%25e8%25bf%259e%25e6%258e%25a5wifi%25e7%259a%2584%25e8%25a7%25a3%25e5%2586%25b3%25e6%2596%25b9%25e6%25a1%2588</link>
                <guid>http://hsfzxjy.github.io/ubuntu/2014/09/27/%e5%85%b3%e4%ba%8eubuntu%e7%aa%81%e7%84%b6%e6%97%a0%e6%b3%95%e8%bf%9e%e6%8e%a5wifi%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88</guid>
                <pubDate>2014-09-27T18:41:31+08:00</pubDate>
        </item>

        <item>
                <title>UVa12186 Another Crisis && [Dynamic Arrays in Pascal]</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=243&amp;amp;page=show_problem&amp;amp;problem=3338&quot;&gt;Link&lt;/a&gt; 耗时：0.586s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨晚做的太急了，没时间写总结，正好下午有空，补上。&lt;br /&gt;
这是一道典型的树形动态规划，不是很难，但十分坑语言。思路大致如下：&lt;/p&gt;
&lt;p&gt;对于第i个节点，用d(i)表示其上诉所需的最小工人数。若i为叶节点，则d(i)=1；否则，遍历求出i的子节点所对应的d值，并由小到大排序，取出最小的几个相加，即为d(i)。&lt;/p&gt;
&lt;p&gt;很容易想到用递归来实现。但对于“子节点的d值的排序”实现起来却十分困难：因为事先不知道有多少个数。当然啦，如果是C++组，用vector可以轻松搞定，可至于P党，实现起来却难上加难。思来想去，决定试试Pascal的动态数组。磕磕碰碰调了近1个小时，终于AC了。&lt;br /&gt;
Code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//Accepted
var
    tree: array [0..100000] of array of int64;
    T: Integer;
    f: array [0..100000] of int64;
    i,l,n,x:longint;

function min(x,y: int64): int64;
begin
    if x&amp;lt;y then exit(x) else exit(y);
end;

procedure sort(var arr: array of int64;l,r:longint); overload;
var
  i,j:longint;
  m,t: int64;
begin
  i := l;
  j := r;
  m := arr[(l+r) &amp;gt;&amp;gt; 1];
  repeat
    while arr[i]&amp;lt;m do inc(i);
    while arr[j]&amp;gt;m do dec(j);
    if i&amp;lt;=j then
    begin
      t := arr[i];
      arr[i] := arr[j];
      arr[j] := t;
      inc(i);
      dec(j);
    end;
  until i&amp;gt;j;
  if i&amp;lt;r then sort(arr, i, r);
  if l&amp;lt;j then sort(arr, l, j);
end;

procedure sort(var arr: array of int64); overload;
begin
  sort(arr, low(arr), high(arr));
end;
function dp(x: longint): int64;
var
  arr: array of int64;
  l,i, num: longint;
begin
    if f[x] &amp;lt;&amp;gt; 0 then
    begin
        dp := f[x];
        exit;
    end;
    if length(tree[x]) = 0 then
    begin
      dp := 1;
      f[x] := 1;
      exit;
    end;
    l := length(tree[x]);
    SetLength(arr, l);
    for i := Low(tree[x]) to High(Tree[x]) do
      arr[i] := dp(tree[x][i]);
    Sort(arr);
    num := (l*T-1) div 100+1;
    for i := Low(arr) to num-1 do
      f[x] := f[x] + arr[i];
    dp := f[x];
end;

begin
    assign(input, 'main.in');reset(input);
    assign(output,'main.out');rewrite(output);
    readln(n, T);
    while n&amp;gt;0 do
    begin
        fillchar(f, sizeof(f), 0);
        fillchar(tree, sizeof(tree), 0);
        for i := 1 to n do
        begin
            read(x);
            SetLength(tree[x], length(tree[x])+1);
            tree[x][high(tree[x])] := i;
        end;
        readln;
        dp(0);
        writeln(f[0]);
        readln(n, T);
    end;
    close(input); close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Dynamic Arrays&lt;/h2&gt;
&lt;p&gt;这里，再总结一下动态数组的用法。&lt;br /&gt;
1&amp;#46; 定义：&lt;code&gt;a: array of [type];&lt;/code&gt;&lt;br /&gt;
2&amp;#46; 设置长度： &lt;code&gt;SetLength(a, 10);&lt;/code&gt;&lt;br /&gt;
3&amp;#46; 长度加一： &lt;code&gt;SetLength(a, Length(a)+1);&lt;/code&gt;&lt;br /&gt;
4&amp;#46; 取得最大、最小下标： &lt;code&gt;High(a)&lt;/code&gt;, &lt;code&gt;Low(a)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;事实上，从&lt;a href=&quot;http://freepascal.org/docs-html/ref/refsu18.html#x42-480003.3.1&quot;&gt;1&amp;#46;1&lt;/a&gt;版本开始FPC就支持Dynamic Arrays了。所以在NOIP竞赛中我们大可放心使用。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/27/uva12186-another-crisis-dynamic-arrays-in-pascal</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/27/uva12186-another-crisis-dynamic-arrays-in-pascal</guid>
                <pubDate>2014-09-27T16:26:32+08:00</pubDate>
        </item>

        <item>
                <title>UVa11584 Partitioning by Palindromes</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;这是一道区间型DP，转移方程很简单，但在实现的过程中却遇见了很多坑，在此记录一下。 链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=27&amp;amp;problem=2631&amp;amp;mosmsg=Submission%20received%20with%20ID%2014256745&quot;&gt;Link&lt;/a&gt; 耗时：0.368s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容易想到，前i个数的划分情况可以由1,2,3...,i-1的划分情况来决定。因此很容易得到状态转移方程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;d[i] = min(d[i], d[j]+1) //j = 0, 1, 2...n-1 并且 s[j+1, i]为回文串，初始条件：d[i] = i。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;d[i]表示前i项的最小划分。这样一来状态转移的复杂度就为O($n^2$)。&lt;br /&gt;
但状态转移的判断呢？“回文串”是一个复杂的条件，判断一个串是否为回文串需要将该串至少遍历一遍。这样一来时间复杂度就上升为O($n^3$)了。而事实上在这种算法中有许多无谓的计算，因此我们可以先对字符串进行预处理：用huiwen[i,j]表示s[i,j]是否为回文串（奇怪的名字。。。）。如此一来，时间复杂度就降为O($n^2$)了。&lt;/p&gt;
&lt;p&gt;Code：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var
    s: AnsiString;
    n, _, i, j, l: integer;
    huiwen: array [1..1000, 1..1000] of boolean; //s[i,j]是否为回文串
    dp: array [0..1000] of integer; //一定从0开始，否则当整串为回文串时就考虑不到了。

function min(x,y: integer): integer;
begin
    if x&amp;lt;y then exit(x) else exit(y);
end;

procedure process(i,j: integer); //对回文串进行预处理
var
    mid: Integer;
    x,y: integer;
begin
    if j = i then
    begin
        huiwen[i,j] := true;
        exit;
    end;
    mid := i + (j-i+1) shr 1;
    x := i;
    y := j;
    while (x &amp;lt;= mid) and (s[x] = s[y]) do
    begin
        inc(x);
        dec(y);
    end;
    huiwen[i, j] := x &amp;gt; mid;
end;

begin
    //assign(input, 'main.in'); reset(input);
    //assign(output, 'main.out'); rewrite(output);
    readln(n);
    for _ := 1 to n do
    begin
        readln(s);
        l := length(s);
        //Pre-process
        fillchar(huiwen, sizeof(huiwen), 0);
        for i := 1 to l do
            for j := i to l do //一定是从i开始，这个错卡了我很久。
                process(i, j);
        //DP
        for i := 1 to l do
        begin
            dp[i] := i;
            for j := 0 to i-1 do
                if huiwen[j+1, i] then
                    dp[i] := min(dp[i], dp[j]+1);
        end;
        write(dp[l]);
        {if _ &amp;lt;&amp;gt;n then }writeln; //吐槽一下：一开始我还谨慎地加上这句以避免行末回车，没想到UVa居然报错了。。看来UVa的比较算法还有待改进啊。
    end;

    //close(input);close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/24/uva-11584-partitioning-by-palindromes</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/24/uva-11584-partitioning-by-palindromes</guid>
                <pubDate>2014-09-24T22:00:14+08:00</pubDate>
        </item>

        <item>
                <title>UVa437 The Tower of Babylon</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=6&amp;amp;page=show_problem&amp;amp;problem=378&quot;&gt;The Tower of Babylon&lt;/a&gt; 耗时：0.015s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是刘汝佳的紫书中“DAG中的动态规划”中的习题，我拿它用来熟悉DAG中的动态规划。&lt;/p&gt;
&lt;p&gt;我们不妨进行逆向考虑：现堆上面的方块，然后考虑在下面进行叠加。这样子一来，影响决策的就只是最下面方块的尺寸了。&lt;br /&gt;
对于这种出现了“大套小”这样的二元关系的题，我们可以将其视为一个有向无环图：&lt;strong&gt;其中每个节点为一个状态，状态的转移是有固定的方向的&lt;/strong&gt;（在此题中，状态转移为从小的方块到大的方块）。&lt;br /&gt;
但是这道题又不同于平常的DAG动态规划：若将边长视为状态的话，则要开一个巨大的数组，这是不可以接受的。因此，我们要换一种思维方式：只记录方块的序号和摆放的方式（如现将边长从小到大进行排序，然后用一个标志k表示当前是以第k小的边长作为高）。&lt;br /&gt;
至此，思路已经清晰了。用dp(i, k)表示&lt;strong&gt;“第i个方块以第k条边为高进行摆放”&lt;/strong&gt;，以下给出状态转移方程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dp(i, k) = max{dp(i, k), dp(j, k2)} j，k2遍历所有顶面矩形比dp(i, k)小的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码实现首次尝试了Pascal中的object类型，使其更加工整，但不可避免地损耗了一些性能。&lt;/p&gt;
&lt;p&gt;Code：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type
    Cube = object
        a: array [1..3] of longint;
        procedure init(x,y,z: longint);
        function height(k: integer): longint;
        function low(k: integer): longint;
        function high(k: integer): longint;
    end;

function max(x,y: longint): longint;
begin
    if x&amp;gt;y then max := x else max := y;
end;

procedure swap(var x,y: longint);
var
    t: longint;
begin
    t := x;
    x := y;
    y := t;
end;

function Cube.height(k: integer): longint;
begin
    height := self.a[k];
end;

function Cube.high(k: integer): longint;
begin
    case k of
        1: high := a[3];
        2: high := a[3];
        3: high := a[2];
    end;
end;

function Cube.low(k: integer): longint;
begin
    case k of
        1: low := a[2];
        2,3: low := a[1];
    end;
end;

procedure Cube.init(x, y, z: longint);
begin
   if x&amp;gt;y then swap(x,y);
   if y&amp;gt;z then swap(y,z);
   if x&amp;gt;y then swap(x,y);
   a[1] := x;
   a[2] := y;
   a[3] := z;
end;

var
    f: array [1..30, 1..3] of longint;
    i,j,m,n,x,y,z: longint;
    cnt: longint;
    cubes: array [1..30] of Cube;

function dp(id, k: integer): longint;
var
    l, h, hi: longint;
    i, j: integer;
begin
    if f[id, k] &amp;gt; 0 then
        exit(f[id, k]);
    l := cubes[id].low(k);
    hi := cubes[id].height(k);
    h := cubes[id].high(k);

    f[id, k] := hi;

    for i := 1 to n do
    begin
        //if i = id then continue;  //此处在一开始时忘记考虑了立方体有无穷多个这一条件。
        for j := 1 to 3 do
        begin
            if not ((cubes[i].low(j) &amp;lt; l) and (cubes[i].high(j) &amp;lt; h)) then
                continue;
            f[id, k] := max(f[id, k], dp(i, j)+hi);
        end;
    end;

    dp := f[id, k];
end;

begin
    assign(input, 'main.in');reset(input);
    assign(output, 'main.out');rewrite(output);
    read(n);
    cnt := 0;
    while n &amp;gt; 0 do
    begin
        inc(cnt);
        for i := 1 to n do
        begin
            read(x,y,z);
            cubes[i].init(x,y,z);
        end;
        fillchar(f, sizeof(f), 0);

        m := 0;
        for i := 1 to n do
            for j := 1 to 3 do
                m := max(m, dp(i, j));

        writeln('Case ', cnt, ': maximum height = ', m);

        read(n);
    end;
    close(input);close(output);
end.
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/23/uva437-the-tower-of-babylon</link>
                <guid>http://hsfzxjy.github.io/uva/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/23/uva437-the-tower-of-babylon</guid>
                <pubDate>2014-09-23T22:00:56+08:00</pubDate>
        </item>

        <item>
                <title>NOIP2011 表达式计算</title>
                <description>&lt;blockquote&gt;
&lt;p&gt;记得11年的时候，觉得这道题爆难，根本无从下手。三年后再次回顾，终于AC了，就当是对表达式求值和动态规划的复习吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;题目：&lt;a href=&quot;http://codevs.cn/problem/1133/&quot;&gt;Link&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Accepted. 
#include &amp;lt;iostream&amp;gt;
#define Mod 10007;
using namespace std;

typedef struct {
    long long v0;  //当前值为0的个数
    long long v1;  //当前值为1的个数
    char ch;  //当前字符
} vertex;

vertex f[100000];

void merge_sum(int p) {
    int w0 = f[p-1].v0 * f[p].v0;
    int w1 = f[p-1].v0*f[p].v1+f[p-1].v1*f[p].v0+f[p-1].v1*f[p].v1;
    f[p-1].v0 = w0 % Mod;
    f[p-1].v1 = w1 % Mod; 
}

inline void merge_product(int p)  //处理当前的值和前一个值取'*'的操作
{
       int w0=f[p-1].v0*f[p].v0+f[p-1].v0*f[p].v1+f[p-1].v1*f[p].v0;
       int w1=f[p-1].v1*f[p].v1;
       f[p-1].v0=w0%Mod;
       f[p-1].v1=w1%Mod;
}

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    f[0].v0=f[0].v1=1;
    while (n--)
    {
          now++;   //新建一个空位读入新符号
          cin&amp;gt;&amp;gt;f[now].ch;
          f[now].v0=f[now].v1=1;  //初始化当前符号的前面的值(虽然')'除外,但也不影响)
          if (f[now].ch=='+')
          {
             if (f[now-1].ch=='*') //处理'*'
             {
                now--;
                merge_product(now);
                f[now]=f[now+1];
             }
             if (f[now-1].ch=='+') //处理'+'
             {
                now--;
                merge_sum(now);
                f[now]=f[now+1];
             }
          }
          if (f[now].ch=='*')
           if (f[now-1].ch=='*') //处理'*'
           {
              now--;
              merge_product(now);
              f[now]=f[now+1];
           }
          if (f[now].ch==')') //处理')'(比较麻烦)
          {
             now--;
             if (f[now].ch=='*')
             {
                merge_product(now);
                now--;
             }
             if (f[now].ch=='+')
             {
                merge_sum(now);
                now--;
             }
             now--;
             f[now].v0=f[now+1].v0;
             f[now].v1=f[now+1].v1;
             if (f[now].ch=='*')
             {
                merge_product(now);
                now--;
             }
          }
    }
    if (f[now].ch=='*')  //处理完了以后,可能还有残留的'*'和'+'
    {
       merge_product(now);
       now--;
    }
    if (f[now].ch=='+')
    {
       merge_sum(now);
       now--;
    }
    cout&amp;lt;&amp;lt;f[0].v0;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/22/noip2011-%25e8%25a1%25a8%25e8%25be%25be%25e5%25bc%258f%25e8%25ae%25a1%25e7%25ae%2597</link>
                <guid>http://hsfzxjy.github.io/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E7%BC%96%E7%A8%8B/2014/09/22/noip2011-%e8%a1%a8%e8%be%be%e5%bc%8f%e8%ae%a1%e7%ae%97</guid>
                <pubDate>2014-09-22T21:57:50+08:00</pubDate>
        </item>

        <item>
                <title>Extended和Double的奇怪问题</title>
                <description>&lt;p&gt;最近在做一个项目，其中有一段判断一个Extended浮点数是否为整数的代码。我用如下方式实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function IsInt(F: Extended): Boolean;
begin
  result := Trunc(F)-F = 0; //整数部分等于自身
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试了许多样例都过了，唯独这个没过：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IsInt(4.000000002*1000000000); //False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调试时发现： Trunc(F)居然等于4000000001！开始以为是精度的问题，找了许多资料也没能解决。后来将Extended换成了Double，就通过了。百思不得其解中。&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/delphi/%E7%BC%96%E7%A8%8B/2014/08/20/extended%25e5%2592%258cdouble%25e7%259a%2584%25e5%25a5%2587%25e6%2580%25aa%25e9%2597%25ae%25e9%25a2%2598</link>
                <guid>http://hsfzxjy.github.io/delphi/%E7%BC%96%E7%A8%8B/2014/08/20/extended%e5%92%8cdouble%e7%9a%84%e5%a5%87%e6%80%aa%e9%97%ae%e9%a2%98</guid>
                <pubDate>2014-08-20T13:37:46+08:00</pubDate>
        </item>

        <item>
                <title>MySQLDump导出时不加锁</title>
                <description>&lt;p&gt;在SAE上进行应用开发时，常常需要导入数据库，这时候就需要用MySQLDump工具进行本地数据库导出。&lt;/p&gt;
&lt;p&gt;首先MySQLDump最基本的语法是这样的 &lt;code&gt;mysqldump &amp;lt;database_name&amp;gt;&lt;/code&gt;，执行之后可以在控制台上看到SQL源码。但我第一次尝试将导出的源码上传至SAE时SAE却报错，原因是SAE的数据库管理不支持LOCK和UNLOCK语句。曾有一段时间，我是手动一行行删除LOCK语句。。30多张表那叫一个蛋疼。。后来，我翻阅了mysqlDump的help文档，发现可以添加这么一个参数&lt;code&gt;--ADD-LOCKS=FALSE&lt;/code&gt;。几经尝试后发现果然没有LOCK语句了。 在此记录下整句命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysqldump --add-locks=FALSE -uroot -p &amp;lt;database_name&amp;gt; &amp;gt;example.sql
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hsfzxjy.github.io/a/1/</link>
                <guid>http://hsfzxjy.github.io/a/mysqldump%e5%af%bc%e5%87%ba%e6%97%b6%e4%b8%8d%e5%8a%a0%e9%94%81</guid>
                <pubDate>2014-08-19T17:50:37+08:00</pubDate>
        </item>

        <item>
                <title>Jekyll Introduction</title>
                <description>
&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we&amp;#8217;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;h3 id=&quot;what-is-jekyll&quot;&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;#8220;a simple, blog aware, static site generator&amp;#8221;.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;what-does-jekyll-do&quot;&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files,
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id=&quot;jekyll-is-not-blogging-software&quot;&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id=&quot;why-should-i-care&quot;&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
  &lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
  &lt;li&gt;No internet connection required.&lt;/li&gt;
  &lt;li&gt;Ability to publish via git.&lt;/li&gt;
  &lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
  &lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
  &lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-jekyll-works&quot;&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id=&quot;initial-setup&quot;&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you&amp;#8217;ll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id=&quot;the-jekyll-application-base-format&quot;&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 2011-10-25-open-source-is-good.markdown
|   |-- 2011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;
  Stores configuration data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;
  This folder is for partial views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt;
  This folder is for the main templates your content will be inserted into.
  You can have different layouts for different pages or page sections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;
  This folder contains your dynamic content/posts.
  the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;
  This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;
  This folder is not part of the standard jekyll structure.
  The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
  Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;jekyll-configuration&quot;&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here:
(&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;content-in-jekyll&quot;&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content &amp;#8220;objects&amp;#8221; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id=&quot;posts-and-pages&quot;&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id=&quot;working-with-posts&quot;&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory.
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post&amp;#8217;s YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy &amp;#8220;set&amp;#8221;.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy &amp;#8220;lessons/beginner&amp;#8221;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won&amp;#8217;t find &amp;#8220;lessons&amp;#8221; and &amp;#8220;beginner&amp;#8221; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id=&quot;working-with-pages&quot;&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;templates-in-jekyll&quot;&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#8217;s or post&amp;#8217;s content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
Templates should be coded in HTML and contain YAML Front Matter.
All templates can contain Liquid code to work with your site&amp;#8217;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sub-templates&quot;&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they
define another &amp;#8220;root&amp;#8221; layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id=&quot;includes&quot;&gt;Includes&lt;/h3&gt;
&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id=&quot;using-liquid-for-templating&quot;&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id=&quot;what-is-liquid&quot;&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data.&lt;/p&gt;

&lt;h3 id=&quot;why-do-we-have-to-use-liquid&quot;&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;.
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id=&quot;liquid-is-not-programmer-friendly&quot;&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can&amp;#8217;t do jackshit in liquid that hasn&amp;#8217;t been allowed explicitly by the implementation.
What&amp;#8217;s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#8217;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins.
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;
My personal stance is to not invest time trying to hack liquid. It&amp;#8217;s really unnecessary
&lt;em&gt;from a programmer&amp;#8217;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I&amp;#8217;ve built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-assets&quot;&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-parses-files&quot;&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt;
  This is done with textile or markdown.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;
  These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
  Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id=&quot;formatting-files-for-parsing&quot;&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#8217;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;defining-layouts-for-posts-and-templates-parsing&quot;&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#8217;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-generates-the-final-static-files&quot;&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#8217;s job is to generate a static representation of your website.
The following is an outline of how that&amp;#8217;s done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt;
  Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt;
  Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one
  big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
  At this stage your site is one big computed ruby object.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;
  Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
  Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;#8220;liquified&amp;#8221;.
 &lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
  hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt;
 Finally the liquid templates are &amp;#8220;rendered&amp;#8221;, thereby processing any liquid syntax provided in the templates
 and saving the final, static representation of the file.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#8217;ll iterate through and format
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
  &lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at []()
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you&amp;#8217;d like.&lt;/p&gt;
</description>
                <link>http://hsfzxjy.github.io/lessons/2011/12/29/jekyll-introduction</link>
                <guid>http://hsfzxjy.github.io/lessons/2011/12/29/jekyll-introduction</guid>
                <pubDate>2011-12-29T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
